<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dokey_</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-12T15:47:04.445Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dokey_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang内存管理</title>
    <link href="http://example.com/e2894e3d.html"/>
    <id>http://example.com/e2894e3d.html</id>
    <published>2024-03-12T14:49:09.000Z</published>
    <updated>2024-03-12T15:47:04.445Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>Golang内存分配机制</strong></p><p>Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用;</p></div><span id="more"></span><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>内存分配算法采用Google的<code>TCMalloc</code>算法, 每个线程都会自行维护一个独立的内存池, 进行内存分配时优先从该内存池中分配, 当内存池不足时才会向加锁的全局内存池申请, 减少系统调用并且避免不同线程对全局内存池的锁竞争;</li><li>把内存切分的非常细小, 分为多级管理, 以降低锁的粒度;</li><li>回收对象时, 并没有将其真正释放, 只是放回预先分配的大块内存中, 以便复用。只有内存闲置过多的时候, 才会尝试归还部分内存给操作系统, 降低整体开销;</li></ul><h2 id="分配组件"><a href="#分配组件" class="headerlink" title="分配组件"></a>分配组件</h2><blockquote><p>Go的内存管理组件主要有: <code>mspan</code>、<code>mcache</code>、<code>mcentral</code>和<code>mheap</code>;</p></blockquote><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/Golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.png' data-fancybox='default' data-caption='内存分配'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/Golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/Golang%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存分配"></a><span class='image-caption'>内存分配</span></div></div><h3 id="内存管理单元-mspan"><a href="#内存管理单元-mspan" class="headerlink" title="内存管理单元: mspan"></a>内存管理单元: mspan</h3><p><code>mspan</code>是内存管理的基本单元, 该结构体中包含<code>next</code>和<code>prev</code>两个字段, 它们分别指向前一个和后一个<code>mspan</code>, 每个<code>mspan</code>都管理<code>npages</code>个大小为8kb的页, 一个span是由多个page组成, 这里的页不是操作系统中的内存页, 它们是操作系统内存页的整数倍;</p><p><code>page</code>是内存存储的基本单元, “对象”放到<code>page</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next        *mspan          <span class="comment">// 后指针</span></span><br><span class="line">    prev        *mspan          <span class="comment">// 后指针</span></span><br><span class="line">    startAddr   <span class="type">uintptr</span>         <span class="comment">// 管理页的起始地址, 指向page</span></span><br><span class="line">    npages      <span class="type">uintptr</span>         <span class="comment">// 页数</span></span><br><span class="line">    spanclass   spanClass       <span class="comment">// 规格</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> spanClass <span class="type">uint8</span></span><br></pre></td></tr></table></figure><p>Go有68种不同大小的spanClass, 用于小对象分配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">68</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="type">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>,<span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure><p>如果按照序号为1的spanClass(对象规格为8B)分配, 每个span占用堆的字节数: 8k, mspan可以保存1024个对象;<br>如果按照序号为2的spanClass(对象规格为16B)分配, 每个span占用堆的字节数: 8k, mspan可以保存512个对象;<br>…<br>如果按照序号为67的spanClass(对象规格为32K)分配, 每个span占用堆的字节数: 32k, mspan可以保存1个对象;</p><table><thead><tr><th align="right">class</th><th align="right">bytes&#x2F;obj</th><th align="right">bytes&#x2F;span</th><th align="right">objects</th><th align="right">tail waste</th><th align="right">max waste</th></tr></thead><tbody><tr><td align="right">1</td><td align="right">8</td><td align="right">8192</td><td align="right">1024</td><td align="right">0</td><td align="right">87.50%</td></tr><tr><td align="right">2</td><td align="right">16</td><td align="right">8192</td><td align="right">512</td><td align="right">0</td><td align="right">43.75%</td></tr><tr><td align="right">3</td><td align="right">24</td><td align="right">8192</td><td align="right">341</td><td align="right">0</td><td align="right">29.24%</td></tr><tr><td align="right">4</td><td align="right">32</td><td align="right">8192</td><td align="right">256</td><td align="right">0</td><td align="right">46.88%</td></tr><tr><td align="right">5</td><td align="right">48</td><td align="right">8192</td><td align="right">170</td><td align="right">32</td><td align="right">31.52%</td></tr><tr><td align="right">6</td><td align="right">64</td><td align="right">8192</td><td align="right">128</td><td align="right">0</td><td align="right">23.44%</td></tr><tr><td align="right">7</td><td align="right">80</td><td align="right">8192</td><td align="right">102</td><td align="right">32</td><td align="right">19.07%</td></tr><tr><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td><td align="right">…</td></tr><tr><td align="right">67</td><td align="right">32768</td><td align="right">8192</td><td align="right">1</td><td align="right">0</td><td align="right">12.50%</td></tr></tbody></table><p>字段含义:</p><ul><li>class: class ID, 每个span结构种都有一个class ID, 表示该span可处理的对象类型;</li><li>bytes&#x2F;obj: 该class代表对象的字节数;</li><li>bytes&#x2F;span: 每个span占用堆的字节数, 也即页数*页大小;</li><li>objects: 每个span可分配的对象个数, 也即(bytes&#x2F;spans) &#x2F; (bytes&#x2F;obj);</li><li>waste bytes: 每个span产生的内存碎片, 也即(bytes&#x2F;spans) % (bytes&#x2F;obj)</li></ul><blockquote><p>大于32k的对象出现时, 会直接从heap分配一个特殊的span, 这个特殊的span的类型(class)是0, 只包含了一个大对象;</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;Golang内存分配机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Go语言内置运行时(就是runtime), 抛弃了传统的内存分配方式, 改为自主管理。这样可以自主实现更好的内存使用模式, 比如内存池、预分配等等。这样, 不会每次内存分配都需要系统调用;&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://example.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang内存逃逸</title>
    <link href="http://example.com/b731d75e.html"/>
    <id>http://example.com/b731d75e.html</id>
    <published>2024-03-12T13:56:08.000Z</published>
    <updated>2024-03-12T14:47:56.175Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>什么是内存逃逸</strong></p><p>在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。</p></div><span id="more"></span><h2 id="内存逃逸的危害"><a href="#内存逃逸的危害" class="headerlink" title="内存逃逸的危害"></a>内存逃逸的危害</h2><blockquote><p>堆是一块没有特定结构, 也没有固定大小的内存区域, 可以根据需要进行调整。全局变量, 占用较大的局部变量, 函数调用结束后不能立刻回收的局部变量就会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于go这种带GC的语言来说, 会增加GC压力, 同时容易造成内存碎片。</p></blockquote><h2 id="如何分析程序是否发生内存逃逸"><a href="#如何分析程序是否发生内存逃逸" class="headerlink" title="如何分析程序是否发生内存逃逸"></a>如何分析程序是否发生内存逃逸</h2><blockquote><p>build时添加<code>-gcflags=&quot;-m&quot;</code>选项可分析内存逃逸情况。比如输出<code>./main.go:3:6: moved to heap: x</code>表示局部变量x逃逸到了堆上。</p></blockquote><h2 id="内存逃逸发生时机"><a href="#内存逃逸发生时机" class="headerlink" title="内存逃逸发生时机"></a>内存逃逸发生时机</h2><h3 id="1-向channel发送指针数据"><a href="#1-向channel发送指针数据" class="headerlink" title="1. 向channel发送指针数据"></a>1. 向<code>channel</code>发送指针数据</h3><blockquote><p>因为在编译时, 不知道channel中的数据会被哪个goroutine接收, 因此编译器没法知道变量什么时候会被释放, 因此只能放到堆中;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    x := <span class="number">5</span></span><br><span class="line">    ch &lt;- <span class="number">5</span>         <span class="comment">// x不发生逃逸, 因为只是复制值</span></span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">    y := <span class="number">5</span></span><br><span class="line">    py := &amp;y</span><br><span class="line">    ch1 &lt;- py       <span class="comment">// y逃逸, 因为y地址传入chan中, 编译时无法确定什么时候会被接收, 所以无法在函数返回后回收y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">2</span>: moved to heap: y</span><br></pre></td></tr></table></figure><h3 id="2-局部变量在函数调用结束后还被其他地方使用"><a href="#2-局部变量在函数调用结束后还被其他地方使用" class="headerlink" title="2. 局部变量在函数调用结束后还被其他地方使用"></a>2. 局部变量在函数调用结束后还被其他地方使用</h3><blockquote><p>局部变量在函数调用结束后还被其他地方使用, 比如函数返回局部变量指针或闭包中引用包外的值。因为变量的生命周期可能会超过函数周期, 因此只能放入堆中;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">5</span>              <span class="comment">// x发生逃逸, 因为在foo调用完成后, 被闭包函数用到, 还不能回收, 只能放到堆上存放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inner := foo()</span><br><span class="line">    inner()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">6</span>: can inline Foo</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline Foo.func1</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">18</span>:<span class="number">14</span>: inlining call to Foo</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline main.Foo.func1</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">7</span>: inlining call to main.Foo.func1</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: x</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">18</span>:<span class="number">14</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">does</span> <span class="title">not</span> <span class="title">escape</span></span></span><br></pre></td></tr></table></figure><h3 id="在slice或map中存储指针"><a href="#在slice或map中存储指针" class="headerlink" title="在slice或map中存储指针"></a>在slice或map中存储指针</h3><blockquote><p>比如[]*string, 其后面的数组可能是在栈上分配的, 但其引用的值还是堆上;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> ls []*<span class="type">int</span></span><br><span class="line">    ls = <span class="built_in">append</span>(ls, &amp;x)         <span class="comment">// x发生逃逸, ls存储的是指针, 所以ls底层的数组虽然在栈上存储, 但本身却逃逸到堆上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: moved to heap: x</span><br></pre></td></tr></table></figure><h3 id="4-切片扩容"><a href="#4-切片扩容" class="headerlink" title="4. 切片扩容"></a>4. 切片扩容</h3><blockquote><p>切片扩容后长度太长, 导致栈空间不足, 逃逸到堆上;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure><h3 id="5-在interface类型上调用方法"><a href="#5-在interface类型上调用方法" class="headerlink" title="5. 在interface类型上调用方法"></a>5. 在interface类型上调用方法</h3><blockquote><p>在interface类型上调用方法时会把interface变量使用堆分配, 因为方法的真正实现只能在运行时知道;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo <span class="keyword">interface</span> &#123;</span><br><span class="line">    fooFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f1 foo1)</span></span> fooFunc() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f foo1</span><br><span class="line">    f = foo1&#123;&#125;</span><br><span class="line">    f.fooFunc()             <span class="comment">// 调用方法时, f发生逃逸, 因为方法是动态分配的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">6</span>: can inline foo1.fooFunc</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">6</span>: can inline main</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: inlining call to foo1.fooFunc</span><br><span class="line">./test_Demo_04.<span class="keyword">go</span>:<span class="number">18</span>:<span class="number">10</span>: foo1&#123;&#125; escapes to heap</span><br></pre></td></tr></table></figure><h2 id="避免内存逃逸的方法"><a href="#避免内存逃逸的方法" class="headerlink" title="避免内存逃逸的方法"></a>避免内存逃逸的方法</h2><ul><li>对于小型数据, 使用传值而不是传指针, 避免内存逃逸;</li><li>避免使用长度不固定的slice切片, 在编译期无法确定切片长度, 只能将切片使用堆分配;</li><li>interface调用方法会发生内存逃逸;</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是内存逃逸&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在程序中, 每个函数块都会有自己的内存区域来存自己的局部变量(内存占用少)、返回地址、返回值之类的数据, 这一块内存区域有特定的结构和寻址方式, 寻址起来十分迅速, 开销很少。这一块内存地址称为栈, 栈是线级别的, 大小在创建的时候已经确定, 当变量太大的时候, 会”逃逸”到堆上, 这种现象称为内存逃逸, 简单来说, 局部变量通过堆分配和回收, 就叫内存逃逸。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://example.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang八股文汇总</title>
    <link href="http://example.com/f25d7e27.html"/>
    <id>http://example.com/f25d7e27.html</id>
    <published>2024-02-17T13:10:13.000Z</published>
    <updated>2024-03-05T15:44:47.932Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong></strong></p><p>记录Golang面试八股文</p></div><span id="more"></span><h2 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h2><h3 id="init和main函数的相关特点"><a href="#init和main函数的相关特点" class="headerlink" title="init和main函数的相关特点"></a>init和main函数的相关特点</h3><h4 id="init函数（没有输入参数、返回值）的主要作用"><a href="#init函数（没有输入参数、返回值）的主要作用" class="headerlink" title="init函数（没有输入参数、返回值）的主要作用:"></a>init函数（没有输入参数、返回值）的主要作用:</h4><ul><li>初始化不能采用初始化表达式初始化的变量;</li><li>在程序运行前注册;</li><li>实现<code>sync.Once</code>功能;</li><li>其他</li></ul><h4 id="init顺序"><a href="#init顺序" class="headerlink" title="init顺序"></a>init顺序</h4><ol><li>在同一个<code>package</code>中, 可以多个文件中定义<code>init</code>方法;</li><li>在同一个<code>go</code>文件中, 可以重复定义<code>init</code>方法;</li><li>在同一个<code>package</code>中, 不同文件中的<code>init</code>方法执行按照文件名先后执行各个文件中的<code>init</code>方法;</li><li>在同一个文件中的多个<code>init</code>方法, 按照在代码中编写的顺序依次执行不同的<code>init</code>方法;</li><li>对于不同的<code>package</code>, 如果不相互依赖的话, 按照<code>main</code>包中<code>import</code>的顺序调用其包中的<code>init()</code>函数;</li><li>如果<code>package</code>存在依赖, 调用顺序为最后被依赖的最先被初始化, 例如: 导入顺序main -&gt; A -&gt; B -&gt; C, 则初始化顺序为C -&gt; B -&gt; A -&gt; main, 一次执行对应的<code>init</code>方法;</li></ol><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/golang-init%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png' data-fancybox='default' data-caption='Golang-init函数执行顺序'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/golang-init%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/golang-init%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Golang-init函数执行顺序"></a><span class='image-caption'>Golang-init函数执行顺序</span></div></div><h3 id="Golang的数据结构的零值是什么"><a href="#Golang的数据结构的零值是什么" class="headerlink" title="Golang的数据结构的零值是什么?"></a>Golang的数据结构的零值是什么?</h3><div class="note info"><p><strong></strong></p><p>所有整型类型: 0<br>浮点类型: 0.0<br>布尔类型: false<br>字符串类型: “”<br>指针、interface、切片(slice)、channel、map、function: nil</p><p>Go的零值初始是递归的, 即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化</p></div><h3 id="byte和rune有什么区别"><a href="#byte和rune有什么区别" class="headerlink" title="byte和rune有什么区别"></a>byte和rune有什么区别</h3><div class="note info"><p><strong></strong></p><ul><li><code>rune</code>和<code>byte</code>在Go语言中都是字符类型, 且都是别名类型;</li><li><code>byte</code>型本质上是<code>uint8</code>类型的别名, 代表了ASCII码的一个字符;</li><li><code>rune</code>型本质上是<code>int32</code>型的别名, 代表一个UTF-8字符;</li></ul></div><h3 id="Go-struct-能不能比较"><a href="#Go-struct-能不能比较" class="headerlink" title="Go struct 能不能比较"></a>Go struct 能不能比较</h3><p>需要根据具体情况分析, 如果struct中含有不能被比较的字段类型, 就不能被比较;<br>如果struct中所有的字段类型都支持比较, 那么就支持比较;</p><div class="note inof"><p><strong>不能被比较的类型</strong></p><ul><li>slice, 因为slice是引用类型, 除非是和nil比较;</li><li>map, 和slice同理, 如果要比较两个map只能通过循环遍历实现;</li><li>函数类型;</li></ul></div><div class="note info"><p><strong>注意</strong></p><ul><li>结构体之间只能比较它们是否相等, 而不能比较它们的大小;</li><li>只能所有属性相等而且属性顺序一致的结构体才能进行比较;</li></ul></div><h3 id="Go-import的三种方式"><a href="#Go-import的三种方式" class="headerlink" title="Go import的三种方式"></a>Go import的三种方式</h3><h4 id="加下划线"><a href="#加下划线" class="headerlink" title="加下划线"></a>加下划线</h4><div class="note info"><p><strong></strong></p><p>import下划线（如：_ “github.com&#x2F;xxx&#x2F;xxx”）的作用: 当导入一个包时, 该包下的文件里所有的<code>init()</code>函数都会被执行。然而有些时候我们并不需要把整个包都导入进来, 仅仅是希望它执行<code>init()</code>函数而已。这个时候就可以使用<code>import _</code>引用该包。<br>即: 使用[import _ 包路径]只是引用该包, 仅仅是为了调用<code>init函数</code>, 所以无法通过包名来调用包中的其他函数;</p></div><h4 id="加点"><a href="#加点" class="headerlink" title="加点(.)"></a>加点(.)</h4><div class="note info"><p><strong></strong></p><p>import和引用的包名之间加点（.）操作的含义就是这个包导入之后在调用这个包的函数时, 可以省略前戳的包名;</p></div><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><div class="note info"><p><strong></strong></p><p>别名操作可以把包命名成另一个用起来容易记忆的名字;</p></div><h3 id="Golang的常量地址"><a href="#Golang的常量地址" class="headerlink" title="Golang的常量地址"></a>Golang的常量地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(&amp;j, j)</span><br><span class="line">    fmt.Println(&amp;i, i) <span class="comment">// panic</span></span><br><span class="line">    <span class="comment">// Go语言中, 常量无法寻址, 是不能进行取指针操作的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string和-byte如何取舍"><a href="#string和-byte如何取舍" class="headerlink" title="string和[]byte如何取舍"></a>string和[]byte如何取舍</h3><h4 id="string擅长的场景"><a href="#string擅长的场景" class="headerlink" title="string擅长的场景:"></a>string擅长的场景:</h4><div class="note info"><p><strong></strong></p><ul><li>需要字符串比较的场景;</li><li>不需要nil字符串的场景;</li></ul></div><h4 id="byte擅长的场景"><a href="#byte擅长的场景" class="headerlink" title="[]byte擅长的场景"></a>[]byte擅长的场景</h4><div class="note info"><p><strong></strong></p><ul><li>修改字符串的场景, 尤其是修改粒度为1个字节;</li><li>函数返回值, 需要用nil表示含义的场景;</li><li>需要切片操作的场景;</li></ul></div><h3 id="字符串转成byte数组-会发生内存拷贝吗"><a href="#字符串转成byte数组-会发生内存拷贝吗" class="headerlink" title="字符串转成byte数组, 会发生内存拷贝吗"></a>字符串转成byte数组, 会发生内存拷贝吗</h3><blockquote><p>字符串转成切片, 会产生拷贝。严格来说, 只要是发生类型强化转都会发生内存拷贝。频繁的内存拷贝操作听起来对性能不太友好。有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢?</p></blockquote><figure class="highlight go"><figcaption><span>代码实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;aaa&quot;</span></span><br><span class="line">    ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">    b := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;ssh))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><p><code>StringHeader</code>是<code>字符串</code>在go的底层结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SliceHeader</code>是<code>切片</code>在go的底层结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len <span class="type">int</span></span><br><span class="line">    Cap <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么如果想要在底层转换二者, 只需要把<code>StringHeader</code>的地址强转成<code>SliceHeader</code>就行。那么go有个包很强的包叫<code>unsafe</code>。</p><ol><li>unsafe.Pointer(&amp;a)方法可以得到变量<code>a</code>的地址;</li><li>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))可以把字符串a转成底层结构的形式;</li><li>(*[]byte)(unsafe.Pointer(&amp;ssh))可以把ssh底层结构转成byte的切片的指针;</li><li>再通过<code>*</code>转成指针指向的实际内容;</li></ol></li></ul><h3 id="翻转含有中文、数字、英文字符的字符串"><a href="#翻转含有中文、数字、英文字符的字符串" class="headerlink" title="翻转含有中文、数字、英文字符的字符串"></a>翻转含有中文、数字、英文字符的字符串</h3><blockquote><p>翻转含有<code>中文、数字、英文字母</code>的字符串</p></blockquote><figure class="highlight go"><figcaption><span>代码实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    src := <span class="string">&quot;你好abc啊哈哈&quot;</span></span><br><span class="line">    dst := reverse([]<span class="type">rune</span>(src))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="type">string</span>(dst))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">rune</span>)</span></span> []<span class="type">rune</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>;i&lt;j; i,j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ul><li><code>rune</code>关键字, 从golang源码中看出, 它是int32的别名(-2^31 ~ 2^31-1), 比如byte(-128 ~ 127), 可表示更多的字符。</li><li>由于rune可表示的范围更大, 所以能处理一切字符, 当然也包括中文字符。在平时计算中文字符, 可用rune。</li><li>因此将<code>字符串</code>转成<code>rune的切片</code>, 再进行翻转;</li></ul><h3 id="json包变量不加tag会怎么样"><a href="#json包变量不加tag会怎么样" class="headerlink" title="json包变量不加tag会怎么样?"></a>json包变量不加tag会怎么样?</h3><blockquote><p><code>json</code>包里使用的时候, 结构体里的变量不加<code>tag</code>能不能正常转成<code>json</code>里的字段?</p></blockquote><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><ul><li>如果变量<code>首字母小写</code>, 则为<code>private</code>。无论如何<code>不能转</code>, 因为取不到<code>反射信息</code>。</li><li>如果变量<code>首字母大写</code>, 则为<code>public</code>:<ol><li><code>不加tag</code>, 可以正常转为<code>json</code>里的字段, <code>json</code>内字段名跟结构体内字段<code>原名一致</code>;</li><li><code>加了tag</code>, 从<code>struct</code>转<code>json</code>的时候, <code>json</code>的字段名就是<code>tag</code>里的字段名, 原字段名已经没用;</li></ol></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">string</span>                <span class="comment">// 小写无tag</span></span><br><span class="line">    b <span class="type">string</span> <span class="string">`json:&quot;B&quot;`</span>     <span class="comment">// 小写加tag</span></span><br><span class="line">    C <span class="type">string</span>                <span class="comment">// 大写无tag</span></span><br><span class="line">    D <span class="type">string</span> <span class="string">`json:&quot;DD&quot;`</span>    <span class="comment">// 大写加tag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j := J &#123;</span><br><span class="line">        a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        b: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        C: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        D: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json前j结构体的内容 = %+v\n&quot;</span>, j)             <span class="comment">// 转为json前j结构体的内容 = &#123; a:1 b:2 C:3 D:4 &#125;</span></span><br><span class="line">    jsonInfo, _ := json.Marshal(j)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json后的内容 = %+v\n&quot;</span>, <span class="type">string</span>(jsonInfo))    <span class="comment">// 转为json后的内容 = &#123; &quot;C&quot;: &quot;3&quot;, &quot;DD&quot;: &quot;4&quot; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><ul><li>结构体里定义了四个字段, 分别对应<code>小写无tag</code>, <code>小写加tag</code>、<code>大写无tag</code>、<code>大写加tag</code>;</li><li>转为<code>json</code>后首字母<code>小写的</code>不管加不加tag<code>都不能</code>转为<code>json</code>里的内容, 而<code>大写的</code>加了tag可以<code>取别名</code>, 不加<code>tag</code>则<code>json</code>内的字段跟结构体字段<code>原名一致</code>;</li></ul><h3 id="Go语言中cap函数可以作用于哪些内容"><a href="#Go语言中cap函数可以作用于哪些内容" class="headerlink" title="Go语言中cap函数可以作用于哪些内容?"></a>Go语言中cap函数可以作用于哪些内容?</h3><ul><li>array返回数组的元素个数</li><li>slice返回slice的最大容量</li><li>channel返回chennel的容量</li></ul><h3 id="Go语言的引用类型有什么"><a href="#Go语言的引用类型有什么" class="headerlink" title="Go语言的引用类型有什么?"></a>Go语言的引用类型有什么?</h3><blockquote><p>Go语言中的引用类型有func(函数类型)、interface(接口类型)、slice(切片类型)、map(字典类型)、channel(管道类型)、*(指针类型)</p></blockquote><h3 id="for-select-如果通道已经关闭会怎么样-如果select中只有一个case呢"><a href="#for-select-如果通道已经关闭会怎么样-如果select中只有一个case呢" class="headerlink" title="for-select, 如果通道已经关闭会怎么样?如果select中只有一个case呢?"></a>for-select, 如果通道已经关闭会怎么样?如果select中只有一个case呢?</h3><blockquote><p>for循环select时, 如果通道已经关闭会怎么样?如果select中的case只有一个, 又会怎么样?</p></blockquote><h4 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h4><ul><li>for循环select时, 如果其中一个case通道已经关闭, 则每次都会执行到这个case;</li><li>如果select里边只有一个case, 而这个case被关闭了, 则会出现死循环;</li></ul><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><ol><li>for循环里被关闭的通道<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    fmat = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        c &lt;- <span class="number">10</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x, ok := &lt;-c:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%v, 通道读取到: x=%v, ok=%v\n&quot;</span>,time.Now().Format(fmat) x, ok)</span><br><span class="line">                time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">44</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">44</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">45</span>, 通道读取到: x=<span class="number">10</span>, ok=<span class="literal">true</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">45</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">46</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">46</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">47</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">47</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">48</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">48</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">49</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">49</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">50</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">50</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">51</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">51</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><code>c通道</code>是一个缓冲为0的通道, 在<code>main</code>开始时, 启动一个协程对<code>c通道</code>写入10, 然后就关闭掉这个通道;</li><li>在<code>main</code>中通过通过<code>x, ok := &lt;-c</code>接受<code>通道c</code>里的值, 从输出结果里看出, 确实从通道里读出了之前塞入通道的10, 但是这个通道关闭后, 这个通道一直能读出内容;</li></ul><ol start="2"><li>怎样才能不读关闭后的通道<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    fmat = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        c &lt;- <span class="number">10</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x, ok := &lt;-c:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%v, 通道读取到: x=%v, ok=%v\n&quot;</span>, time.Now().Format(fmat), x, ok)</span><br><span class="line">                time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    c = <span class="literal">nil</span>     <span class="comment">// 把关闭后的通道赋值为nil, 则select读取则会阻塞</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%v, 没读到信息进入default\n&quot;</span>, time.Now().Format(fmat))</span><br><span class="line">                time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">06</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">07</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">07</span>, 通道读取到: x=<span class="number">10</span>, ok=<span class="literal">true</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">08</span>, 通道读取到: x=<span class="number">0</span>, ok=<span class="literal">false</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">08</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">09</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">09</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">10</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">10</span>, 没读到信息进入<span class="keyword">default</span></span><br><span class="line"><span class="number">2024</span><span class="number">-02</span><span class="number">-27</span> <span class="number">23</span>:<span class="number">08</span>:<span class="number">11</span>, 没读到信息进入<span class="keyword">default</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="go的内存逃逸是什么-什么情况下会发生内存逃逸"><a href="#go的内存逃逸是什么-什么情况下会发生内存逃逸" class="headerlink" title="go的内存逃逸是什么? 什么情况下会发生内存逃逸?"></a>go的内存逃逸是什么? 什么情况下会发生内存逃逸?</h3><h4 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h4><p><code>golang程序变量</code>会携带有一组校验数据, 用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验, 它就可以在<code>栈上</code>分配, 否则就说它逃逸了, 必须在堆上分配。</p><p>能引起变量逃逸到堆上的典型情况: </p><ul><li>在方法内把局部变量指针返回: 局部变量原本应该在栈中分配, 在栈中回收。但是由于返回时被外部调用, 因此其生命周期大于栈, 则溢出;</li><li>发送指针或带有指针的值到chennel中: 在编译时, 是没有办法知道哪个goroutinue会在channel上接收数据。所以编译器没法知道变量什么时候才会释放;</li><li>在一个切片上存储指针或带指针的值: 一个典型的例子就是[]*string。这会导致切片内容逃逸。尽管其后面的数组可能是在栈上分配的, 但其引用的值一定是在堆上;</li><li>slice的背后数组被重新分配了, 因为append时可能会超出其容量(cap): slice初始化的地方在编译时是可以知道的, 它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充, 就会在堆上分配;</li><li>在interface类型上调用方法: 在interface类型上调用方法都是动态调度的–方法的真正实现只能在运行时知道。想象一个io.Reader类型的变量r, 调用r.Read(b)会使得r的值和切片b背后存储的数据逃逸掉, 所以会在堆上分配;</li></ul><h4 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h4><blockquote><p>通过一个例子加深理解, 接下来尝试怎么通过<code>go build -gcflags=-m</code>查看逃逸的情况</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(s <span class="type">string</span>)</span></span> *A &#123;</span><br><span class="line">a := <span class="built_in">new</span>(A)</span><br><span class="line">a.s = s</span><br><span class="line"><span class="keyword">return</span> a <span class="comment">// 返回局部变量a, 在C语言为野指针, 在golang则ok但a会逃逸到堆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := foo(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">b := a.s + <span class="string">&quot;world&quot;</span></span><br><span class="line">c := b + <span class="string">&quot;!&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m test_Demo_01.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags=-m test_Demo_01.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">6</span>: can inline foo</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">10</span>: inlining call to foo</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">10</span>: leaking param: s</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: <span class="built_in">new</span>(A) escapes to heap</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">10</span>: <span class="built_in">new</span>(A) does not escape</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">11</span>: a.s + <span class="string">&quot;world&quot;</span> does not escape</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">18</span>:<span class="number">9</span>: b + <span class="string">&quot;!&quot;</span> escapes to heap</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">./test_Demo_01.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">14</span>: c escapes to heap</span><br></pre></td></tr></table></figure><ul><li><code>./test_Demo_01.go:10:10: new(A) escapes to heap</code>说明<code>new(A)</code>逃逸了, 符合上述提到的常见情况的第一种;</li><li><code>./test_Demo_01.go:17:11: a.s + &quot;world&quot; does not escape</code> 说明<code>b</code>变量没有逃逸, 因为它只存在方法内存中, 会在方法结束时被回收;</li><li><code>./test_Demo_01.go:18:9: b + &quot;!&quot; escapes to heap</code>说明<code>c</code>变量逃逸, 通过<code>fmt.Println(a ...interface&#123;&#125;)</code>打印的变量, 都会发生逃逸;</li></ul><h3 id="Go关键字fallthrough有什么作用"><a href="#Go关键字fallthrough有什么作用" class="headerlink" title="Go关键字fallthrough有什么作用"></a>Go关键字fallthrough有什么作用</h3><blockquote><p>fallthrough关键字只能用在switch中, 且只能在每一个case分支中的最后一行, 作用是如果这个case分支被执行, 将继续执行下一个case分支, 而且不会取判断下一个分支额case条件是否成立;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="string">&quot;a&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;匹配a&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;a成功了, 也执行b分支&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;c&quot;</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;a成功了, c分支会执行吗&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;默认执行&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    匹配a</span></span><br><span class="line"><span class="comment">    a成功了, 也执行b分支</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="空结构体占不占内存空间-为什么使用空结构体"><a href="#空结构体占不占内存空间-为什么使用空结构体" class="headerlink" title="空结构体占不占内存空间? 为什么使用空结构体?"></a>空结构体占不占内存空间? 为什么使用空结构体?</h3><blockquote><p>空结构体是没有内存大小的结构体;</p></blockquote><p>通过unsafe.Sizeof()可以查看空结构体的宽度, 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(s)) <span class="comment">// printfs 0</span></span><br></pre></td></tr></table></figure><p>准确的来说, 空结构体有一个特殊起点: <code>zerobase</code>变量; <code>zerobase</code>是一个占用8个字节的<code>uintptr</code>全局变量。每次定义<code>struct&#123;&#125;</code>类型的变量, 编译器只是把<code>zerobase</code>变量的地址给出去。也就是说空结构体的变量的内存地址都是一样的。</p><p>空结构体的使用场景主要有三种: </p><ul><li>实现方法接收者: 在业务场景下, 我们需要将方法组合起来, 代表其一个”分组”的, 便于后续拓展和维护;</li><li>实现集合类型: 在Go语言的标准库中并没有提供集合(Set)的相关实现, 因此一般在代码中图方便, 会直接用map来替代: <code>type Set map[string]struct&#123;&#125;</code>。</li><li>实现通道: 在Go channel的使用场景中, 常常会遇到通知型channel, 其不需要发送任何数据, 只是用于协调Goroutinue的运行, 用于流转各类状态或是控制并发情况;</li></ul><h3 id="Go语言中-下面哪个关于指针的说法是错误的"><a href="#Go语言中-下面哪个关于指针的说法是错误的" class="headerlink" title="Go语言中, 下面哪个关于指针的说法是错误的?"></a>Go语言中, 下面哪个关于指针的说法是错误的?</h3><ul><li>指针不能进行算术运算</li><li>指针可以比较</li><li>指针可以是nil</li><li><strong>指针可以指向任何类型</strong></li></ul><p>针对在Go语言中只能指向相同类型的结构体或者基本类型。例如，一个int类型的变量, 只能指向int类型的指针。如果尝试将一个不同类型的指针赋给一个变量, 将会导致编译错误。</p><h3 id="Go语言的接口类型是如何实现的"><a href="#Go语言的接口类型是如何实现的" class="headerlink" title="Go语言的接口类型是如何实现的?"></a>Go语言的接口类型是如何实现的?</h3><blockquote><p>在Go语言中, 接口类型是通过**类型嵌入(embedding)**的方式实现的。每个实现了接口的类型的结构体中都有一个隐含的成员, 该成员是指向接口类型的指针。通过这种方式, 接口实现了堆类型的约束和定义。</p></blockquote><blockquote><p>具体来说, 当一个类型实现了某个接口的所有方法后, 该类型就被认为是实现了该接口。结构体中, 可以通过嵌入接口类型的方式来实现接口方法。在实现接口方法时, 方法的签名需要与接口定义中的方法签名保持一致。</p></blockquote><h3 id="Go-string的底层实现"><a href="#Go-string的底层实现" class="headerlink" title="Go string的底层实现"></a>Go string的底层实现</h3><p>源码包src&#x2F;runTime&#x2F;string.go stringStruct定义了string的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer      <span class="comment">// 字符串的首地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span>                 <span class="comment">// 字符串的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明:<br>如下代码所示, 可以声明一个string变量赋予初值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">str = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>字符串构建过程是根据字符串构建stringStruct, 再转化成string, 转化源码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostringnocopy</span><span class="params">(str *<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ss := stringStruct&#123;                 <span class="comment">// 先构造stringStruct</span></span><br><span class="line">        str: unsafe.Pointer(str),</span><br><span class="line">        <span class="built_in">len</span>: findnull(str)</span><br><span class="line">    &#125;</span><br><span class="line">    s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;ss))    <span class="comment">// 再将stringStruct转换成string</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go如何避免panic"><a href="#Go如何避免panic" class="headerlink" title="Go如何避免panic"></a>Go如何避免panic</h3><blockquote><p>首先明确panic定义: go把真正的异常叫做panic, 是指出现重大错误, 比如数据越界之类的编程BUG或者是那些需要人工介入才能修复的问题, 比如程序启动时加载资源出错等等。</p></blockquote><p>几个容易出现panic的点:</p><ul><li>函数返回值或参数为指针类型, nil, 未初始化结构体, 此时调用容易出现panic, 可加 !&#x3D;nil 进行判断;</li><li>数组切片越界</li><li>如果我们关闭未初始化通道, 重复关闭通道, 向已经关闭的通道中发送数据, 这三种情况会引发panic, 导致程序崩溃;</li><li>如果我们直接操作未初始化的映射(map), 也会引发panic, 导致程序崩溃;</li><li>另外, 操作映射可能会遇到的更为严重的一个问题是, 同时对同一个映射并发读写, 它会触发runtime.throw, 不像panic可以使用recover捕获。所以, 我们再对同一个映射并发读写时, 一定要使用锁;</li><li>如果类型断言使用不当, 比如我们不接受布尔值的话, 类型断言失败也会引发panic, 导致程序崩溃;</li><li>如果很多时候不可避免地出现了panic, 记得使用defer&#x2F;recover;</li></ul><h3 id="空结构体的使用场景"><a href="#空结构体的使用场景" class="headerlink" title="空结构体的使用场景"></a>空结构体的使用场景</h3><blockquote><p>空结构体(empty struct)是在Go语言中一个特殊地概念, 它没有任何字段。在Go中, 它通常被称为匿名结构体或零宽度结构体。尽管没有字段, 但它在某些请款下仍然有其他用途</p></blockquote><h4 id="1-占位符"><a href="#1-占位符" class="headerlink" title="1. 占位符"></a>1. 占位符</h4><blockquote><p>空结构体可以用作占位符, 用于表示某个数据结构或数据集合地存在而不实际存储任何数据。这在某些数据结构的实现中非常有用, 特别是要实现某种数据结构的集合或映射时, 但并不需要存储实际的值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示集合中是否包含某个元素的映射</span></span><br><span class="line">set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">set[<span class="string">&quot;apple&quot;</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h4><blockquote><p>空结构体可以用作信号量, 用于控制并发操作。通过向通道发送或接收空结构体, 可以实现信号的传递和同步;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用通道作为信号量</span></span><br><span class="line">semaphore := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">5</span>)     <span class="comment">// 控制并发数为5</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    semaphore &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;     <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;- semaphero</span><br><span class="line">    &#125;()                         <span class="comment">// 释放信号量</span></span><br><span class="line">    <span class="comment">// 执行并发操作</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h4 id="3-强调结构"><a href="#3-强调结构" class="headerlink" title="3.强调结构"></a>3.强调结构</h4><blockquote><p>有时, 空结构体可用于强调某个结构的重要性或存在。它可以用作结构体的标签, 表示关注该结构的存在而不是其内容;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一篇文章的元信息, 不包含实际内容</span></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title       <span class="type">string</span></span><br><span class="line">    Author      <span class="type">string</span></span><br><span class="line">    PublishedAt time.Time</span><br><span class="line">    MetaData    <span class="keyword">struct</span>&#123;&#125;        <span class="comment">// 空结构体强调元信息的存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-JSON序列化"><a href="#4-JSON序列化" class="headerlink" title="4. JSON序列化"></a>4. JSON序列化</h4><blockquote><p>在处理JSON数据时, 有时需要表示一个空对象, 可以使用空结构体来表示JSON中的空对象<code>&#123;&#125;</code>;</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emptyJSON := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">jsonBytes, _ := json.Marshal(emptyJSON)</span><br><span class="line">fmt.Println(<span class="type">string</span>(jsonBytes))      <span class="comment">// 输出: &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>尽管空结构体没有字段, 但它在上述情况下提供了一种轻量级的方式来处理特定的需求, 而无需分配额外的内存或定义具体的数据结构。</p><p>struct的特点:</p><ul><li>用来自定义复杂数据结构;</li><li>struct里面可以包含多个字段(属性);</li><li>struct类型可以定义方法, 注意和函数的区分;</li><li>struct类型是值类型;</li><li>struct类型可以嵌套;</li><li>Go语言没有calss类型, 只有struct类型;</li></ul><p>特殊之处:</p><ul><li>结构体是用户单独定义的类型, 不能和其他类型进行强制转换;</li><li>golang中的struct没有构造函数, 一般可以使用工厂模式来解决这个问题;</li><li>我们可以为struct的每个字段, 写上一个tag。这个tag可以通过反射的机制获取到, 最常用的场景就是json序列化和反序列化;</li><li>结构体中的字段可以没有名字, 即匿名字段;</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;记录Golang面试八股文&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://example.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>移动导出表</title>
    <link href="http://example.com/cfe5db75.html"/>
    <id>http://example.com/cfe5db75.html</id>
    <published>2024-01-03T12:51:25.000Z</published>
    <updated>2024-01-29T14:55:58.870Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>为什么要移动导出表</strong></p><ol><li>导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;</li><li>在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;</li><li>为了保护程序, 可以对.EXE的二进制代码进行加密操作;<ul><li>如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;</li><li>因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密;</li></ul></li></ol></div><span id="more"></span><h2 id="移动导出表步骤"><a href="#移动导出表步骤" class="headerlink" title="移动导出表步骤"></a>移动导出表步骤</h2><div class="note info"><p><strong>移动导出表步骤</strong></p><ol><li>读取Dll文件并在FileBuffer中新增一个节(.export);</li><li>复制<code>AddressOfFunctions</code>(函数地址表); <ul><li>长度: <code>NumberOfFunctions * 4</code>;</li></ul></li><li>复制<code>AddressOfNameOrdinals</code>(函数序号表);<ul><li>长度: <code>NumberOfNames * 2</code>;</li></ul></li><li>复制<code>AddressOfNames</code>(函数名称表);<ul><li>长度: <code>NumberOfNames * 4</code>;</li></ul></li><li>复制所有函数名;<ul><li>长度不确定, 复制时直接修复<code>AddressOfNames</code>;</li></ul></li><li>复制<code>IMAGE_EXPORT_DIRECTORY</code>结构;</li><li>修复<code>IMAGE_EXPORT_DIRECTORY</code>结构中的<code>AddressOfFunctions</code>、<code>AddressOfNameOrdinals</code>、<code>AddressOfNames</code>;</li><li>修复目录项中的值, 指向新的<code>IMAGE_EXPORT_DIRECTORY</code>;</li></ol></div><h2 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h2><blockquote><p>将RVA转换成FOA</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">RVA2FOA</span><span class="params">(DOWRD dwRVA, LPVOID lpBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpBuffer;</span><br><span class="line">    IMAGE_NT_HEADERS pNt = (IMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    IMAGE_SECTION_HEADER pSec = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNt);</span><br><span class="line">    <span class="keyword">if</span>(dwRVA &lt; pSec[<span class="number">0</span>].VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dwRVA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dwRVA &gt;= pSec[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSec[i].VirtualAddress + pSec[i].misc.VirtualSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> dwRVA - pSec[i].VirtualAddress + pSec[i].PointerToRawData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwRVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FOA转RVA"><a href="#FOA转RVA" class="headerlink" title="FOA转RVA"></a>FOA转RVA</h2><blockquote><p>将FOA转换成RVA</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">FOA2RVA</span><span class="params">(DWORD dwFOA, LPVOID lpBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpBuffer;</span><br><span class="line">    IMAGE_NT_HEADERS pNt = (IMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    IMAGE_SECTION_HEADER pSec = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNt);</span><br><span class="line">    <span class="keyword">if</span>(dwFOA &lt; pSec[<span class="number">0</span>].PointerToRawData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dwFOA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;pNt-&gt;FileHeader.NumberOfSections;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dwFOA &gt;= pSec[i].PointerToRawData &amp;&amp; dwFOA &lt; (pSec[i].PointerToRawData + pSec[i].SizeOfRawData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pSec[i].VirtualAddress + dwFOA - pSec[i].PointerToRawData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动导出表具体步骤"><a href="#移动导出表具体步骤" class="headerlink" title="移动导出表具体步骤"></a>移动导出表具体步骤</h2><h3 id="1-将Dll文件读入内存"><a href="#1-将Dll文件读入内存" class="headerlink" title="1. 将Dll文件读入内存"></a>1. 将Dll文件读入内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* szFilePath = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileA</span>(</span><br><span class="line">    szFilePath,</span><br><span class="line">    GENERIC_READ,</span><br><span class="line">    FILE_SHARE_READ,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_EXISTING,</span><br><span class="line">    FILE_ATTRIBUTE_ARCHIVE,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>(hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateFileA Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dwFileSize: %d\n&quot;</span>, dwFileSize);</span><br><span class="line">LPVOID lpData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line"><span class="keyword">if</span>(lpData == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(FALSE == <span class="built_in">ReadFile</span>(hFile, lpData, dwFileSize, &amp;dwRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ReadFile Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpData: %x\n&quot;</span>, *(<span class="type">short</span>*)lpData);</span><br></pre></td></tr></table></figure><h3 id="2-新增节表"><a href="#2-新增节表" class="headerlink" title="2. 新增节表"></a>2. 新增节表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析PE文件</span></span><br><span class="line">IMAGE_DOS_HEADER pDos = (IMAGE_DOS_HEADER)lpData;</span><br><span class="line">IMAGE_NT_HEADERS pNt = (IMAGE_NT_HAEDERS)(pDos-&gt;e_lfanew + (DWORD)lpData);</span><br><span class="line">PIMAGE_SECTION_HEADER pSec = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增节表</span></span><br><span class="line">PIMAGE_SECTION_HEADER pNewSec = pSec + pNt-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="keyword">if</span>(((DWORD)lpData + pNt-&gt;OptionalHeader.SizeOfHeaders - (DWORD)pNewSec) &lt; <span class="number">80</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;空间不足新增节表失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新接节表</span></span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span>*)(pNewSec-&gt;Name), <span class="string">&quot;.export&quot;</span>);</span><br><span class="line">pNewSec-&gt;Misc.VirtualSize = <span class="number">0x1000</span>;</span><br><span class="line">pNewSec-&gt;VirtualAddress = pNt-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">pNewSec-&gt;SizeOfRawData = <span class="number">0x1000</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER pLastSec = pSec + (pNt-&gt;FileHeader.NumberOfSections - <span class="number">1</span>);</span><br><span class="line">pNewSec-&gt;PointerToRawData = pLastSec-&gt;PointerToRawData + pLastSec-&gt;SizeOfRawData;</span><br><span class="line">pNewSec-&gt;Characteristics = pSec[<span class="number">1</span>].Characteristics;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全0节表</span></span><br><span class="line"><span class="built_in">memset</span>((LPVOID)(pNewSec + <span class="number">1</span>), <span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正头部信息</span></span><br><span class="line">pNt-&gt;FileHeader.NumberOfSections += <span class="number">1</span>;</span><br><span class="line">pNt-&gt;OptionalHeader.SizeOfImage += <span class="number">0x1000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-复制导出表"><a href="#3-复制导出表" class="headerlink" title="3. 复制导出表"></a>3. 复制导出表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">LPVOID lpSecMemory = <span class="keyword">new</span> BYTE[<span class="number">0x1000</span>];</span><br><span class="line"><span class="keyword">if</span>(lpSecMemory == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析导出表</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(<span class="built_in">RVA2FOA</span>(pDir-&gt;VirtualAddress, lpData) + (DWORD)lpData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NumberOfNames: %d\n&quot;</span>, pExport-&gt;NumberOfNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数地址表</span></span><br><span class="line"><span class="comment">// 长度 NumberOfFunctions * 4</span></span><br><span class="line">LPVOID lpCopyDest = lpSecMemory;</span><br><span class="line">LPDWORD lpNewFuncAddr = (LPDWORD)lpCopyDest;</span><br><span class="line">LPVOID lpFuncAddr = (LPVOID)(<span class="built_in">RVA2FOA</span>(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData);</span><br><span class="line"><span class="built_in">memcpy</span>(lpCopyDest, lpFuncAddr, pExport-&gt;NumberOfFunctions * <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpSecMemory =&gt; AddressOfFunctions: %x\n&quot;</span>, *(<span class="type">int</span>*)lpSecMemory);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pExport-&gt;AddressOfFuntions: %x\n&quot;</span>, *(<span class="type">int</span>*)(<span class="built_in">RVA2FOA</span>(pExport-&gt;AddressOfFunctions, lpData) + (DWORD)lpData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数序号表</span></span><br><span class="line"><span class="comment">// 长度 NumberOfNames * 2</span></span><br><span class="line">lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;AddressOfFunctions * <span class="number">4</span>);</span><br><span class="line">LPDWORD lpNewOrdAddr = (LPDWORD)lpCopyDest;</span><br><span class="line">LPVOID lpOrdAddr = (LPVOID)(<span class="built_in">RVA2FOA</span>(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData);</span><br><span class="line"><span class="built_in">memcpy</span>(lpCopyDest, lpOrdAddr, pExport-&gt;NumberOfNames * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpSecMemory =&gt; AddressOfNameOrdinals: %x\n&quot;</span>, *(<span class="type">char</span>*)((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * <span class="number">4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pExport-&gt;AddressOfNameOrdinals: %x\n&quot;</span>, *(<span class="type">char</span>*)(<span class="built_in">RVA2FOA</span>(pExport-&gt;AddressOfNameOrdinals, lpData) + (DWORD)lpData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数名称表</span></span><br><span class="line"><span class="comment">// 长度 NumberOfNames * 4</span></span><br><span class="line">lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * <span class="number">2</span>);</span><br><span class="line">LPDWORD lpNewNameAddr = (LPDWORD)lpCopyDest;</span><br><span class="line">LPDWORD lpNameAddr = (LPDWORD)(<span class="built_in">RVA2FOA</span>(pExport-&gt;AddressOfNames, lpData) + (DWORD)lpData);</span><br><span class="line"><span class="built_in">memcpy</span>(lpCopyDest, <span class="number">0</span>, pExport-&gt;NumberOfNames * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数名称并修复名称表</span></span><br><span class="line">lpCopyDest = (LPVOID)((DWORD)lpSecMemory + pExport-&gt;NumberOfNames * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;pExoprt-&gt;NumberOfNames; i++)</span><br><span class="line">&#123;</span><br><span class="line">    LPSTR lpFuncName = (LPSTR)(<span class="built_in">RVA2FOA</span>(lpNameAddr[i], lpData) + (DWORD)lpData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lpFuncName: %s\n&quot;</span>, lpFuncName);</span><br><span class="line">    DWORD dwFuncLen = <span class="built_in">strlen</span>(lpFuncName) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(lpCopyDest, lpFuncName, dwFuncLen);</span><br><span class="line">    *(lpNewFuncAddr + i) = <span class="built_in">FOA2RVA</span>((dwFileSize + (DWORD)lpCopyDest - (DWORD)lpSecMemory), lpData);</span><br><span class="line">    lpCopyDest = (LPVOID)((DWORD)lpCopyDest + dwFuncLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpSecMemory =&gt; AddressOfNames: %s\n&quot;</span>, ((DWORD)lpSecMemory + pExport-&gt;NumberOfFunctions * <span class="number">4</span> + pExport-&gt;NumberOfNames * <span class="number">2</span> + pExport-&gt;NumberOfNames * <span class="number">4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pExport-&gt;AddressName: %s\n&quot;</span>, (<span class="built_in">RVA2FOA</span>(lpNewFuncAddr[<span class="number">0</span>], lpData) + (DWORD)lpData));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制导出表</span></span><br><span class="line"><span class="built_in">memcpy</span>(lpCopyDest, pExport, pDir-&gt;Size);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pNewExport = (PIMAGE_EXPORT_DIRECTORY)lpCopyDest;</span><br><span class="line">pNewExport-&gt;AddressOfFunctions = <span class="built_in">FOA2RVA</span>((dwFileSize + (DWORD)lpNewFuncAddr - (DWORD)lpSecMemory), lpData);</span><br><span class="line">pNewExoprt-&gt;AddressOfNameOrdinals = <span class="built_in">FOA2RVA</span>((dwFileSize + (DWORD)lpNewOrdAddr - (DWORD)lpSecMemory), lpData);</span><br><span class="line">pNewExport-&gt;AddressOfNames = <span class="built_in">FOA2RVA</span>((dwFileSize + (DWORD)lpNewNameAddr - (DWORD)lpSecMemory), lpData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复数据目录</span></span><br><span class="line">pNt-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress = <span class="built_in">FOA2RVA</span>((dwFileSize + (DWORD)pNewExport - (DWORD)lpSecMemory), lpData);</span><br></pre></td></tr></table></figure><h3 id="4-将数据写入文件"><a href="#4-将数据写入文件" class="headerlink" title="4. 将数据写入文件"></a>4. 将数据写入文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FILE* newFile = <span class="built_in">fopen</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;a+b&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!newFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开新文件失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> m = <span class="built_in">fwrite</span>(lpData, dwFileSize, <span class="number">1</span>, newFile);</span><br><span class="line"><span class="keyword">if</span>(!m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写出文件第一部分失败\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(newFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写出新节</span></span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">fwrite</span>(lpSecMemory, <span class="number">0x1000</span>, <span class="number">1</span> , newFile);</span><br><span class="line"><span class="keyword">if</span>(!n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写出文件第二部分失败\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(newFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件并返回</span></span><br><span class="line"><span class="built_in">fclose</span>(newFile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;移动导出表成功\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="5-调用新导出表"><a href="#5-调用新导出表" class="headerlink" title="5. 调用新导出表"></a>5. 调用新导出表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*MyShowMessage)</span><span class="params">()</span></span>;</span><br><span class="line">HMODULE hDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(hDll == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyShowMessage myShowMessage = (MyShowMessage)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;ShowMessage&quot;</span>);</span><br><span class="line"><span class="built_in">myShowMessage</span>();</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hDll);</span><br></pre></td></tr></table></figure><h2 id="运行成功"><a href="#运行成功" class="headerlink" title="运行成功"></a>运行成功</h2><p><img src="https://raw.githubusercontent.com/Dooookey/Photos/main/%E7%A7%BB%E5%8A%A8%E5%AF%BC%E5%87%BA%E8%A1%A8.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/%E7%A7%BB%E5%8A%A8%E5%AF%BC%E5%87%BA%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="移动导出表"></p><h2 id="dllmain-cpp"><a href="#dllmain-cpp" class="headerlink" title="dllmain.cpp"></a>dllmain.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">ShowMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;I`m DLL File&quot;</span>, <span class="string">L&quot;HELLO&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么要移动导出表&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;导出表由编译器生成, 导出表中存储了该PE文件有哪些导出函数以及函数的地址;&lt;/li&gt;&lt;li&gt;在程序启动时, 系统会根据导出表做初始工作; 将用到的Dll中的函数地址存储到IAT表中;&lt;/li&gt;&lt;li&gt;为了保护程序, 可以对.EXE的二进制代码进行加密操作;&lt;ul&gt;&lt;li&gt;如果进行加密, 各种表的信息以及数据是混在一起的, 加密后会导致程序无法正常执行;&lt;/li&gt;&lt;li&gt;因此需要新增一个节, 并将PE中的表移动到新节中, 然后将代码和数据进行加密;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows PE" scheme="http://example.com/categories/Windows-PE/"/>
    
    
    <category term="Windows PE" scheme="http://example.com/tags/Windows-PE/"/>
    
  </entry>
  
  <entry>
    <title>手工模拟PE加载器</title>
    <link href="http://example.com/dbdbea24.html"/>
    <id>http://example.com/dbdbea24.html</id>
    <published>2023-12-14T13:13:16.000Z</published>
    <updated>2024-01-03T12:27:10.539Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>内存直接加载运行</strong></p><ul><li>病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;</li><li>假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;</li><li>内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程;</li></ul></div><span id="more"></span><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先, 需要将DLL文件加载到内存中, 按照映像大小进行对齐后映射到内存中, 然后根据重定位表修改硬编码数据, 最后根据导出表函数地址修正导入表;</p><h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><div class="note guide"><p><strong></strong></p><ol><li>根据映像大小SizeOfImage申请可读可写可执行的内存空间, 首地址即DLL加载基址;</li><li>获取其映像对齐大小<code>SectionAlignment</code>并复制到该内存空间中（FileBuffer &#x3D;&gt; ImageBuffer）;</li><li>修正重定位表;</li><li>修正导入表, 根据PE结构中的导入表, 加载所需的Dll, 并获取导入函数的地址将其写入导入表中;</li><li>修改DLL的加载基址ImageBase;</li><li>获取DLL入口地址, 构造DllMain函数实现加载;</li></ol></div><p>对于exe文件, 重定位表不是必须的。因为对于exe进程来说, 进程最早加载的模块是exe模块, 所以它可以按照默认加载基址加载到内存中; exe和Dll唯一的区别在于构造入口函数的差别, exe不需要构造入口函数, 而是根据PE结构获取exe的入口地址偏移AddressOfEntryPoint并计算出入口地址, 然后直接跳转。</p><h3 id="1-将Dll文件读入内存"><a href="#1-将Dll文件读入内存" class="headerlink" title="1. 将Dll文件读入内存"></a>1. 将Dll文件读入内存</h3><figure class="highlight c++"><figcaption><span>PELodader_Demo.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchat_t</span> szFileName[MAX_PATH] =  <span class="string">L&quot;C:\\Users\\dell\\OneDrive\\桌面\\哔哩哔哩学习\\PE Learn\\PELoader_Demo\\Debug\\TestDLL_01.dll&quot;</span>;</span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">    szFileName,</span><br><span class="line">    GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_EXISTING,</span><br><span class="line">    FILE_ATTRIBUTE_ARCHIVE,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetFileSize: %d\n&quot;</span>, dwFileSize);</span><br><span class="line"><span class="comment">// 申请动态内存</span></span><br><span class="line">PBYTE lpData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == lpData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;申请内存出错\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将文件读取到内存中</span></span><br><span class="line">DWORD dwRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (FALSE == <span class="built_in">ReadFile</span>(hFile, lpData, dwFileSize, &amp;dwRead, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ReadFile Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lpData: %08x\n&quot;</span>, *(<span class="type">short</span>*)lpData); <span class="comment">// 5A4D</span></span><br></pre></td></tr></table></figure><span class='p medium'>CreateFile</span><blockquote><p>创建或打开文件或I&#x2F;O设备, 此函数区分多字节和Unicode两种模式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UNICODE</span></span><br><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCWSTR lpFileName,        <span class="comment">// 要创建或打开的文件或设备名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess,     <span class="comment">// 请求对文件或设备的访问权限, 常用值GENERIC_READ、GENERIC_WRITE</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwShareMode,         <span class="comment">// 请求的文件或设备的共享模式（可以是读取、写入、删除）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,    <span class="comment">// 指向LPSECURITY_ATTRIBUTES结构的指针, 此参数可以为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationDisposition,   <span class="comment">// 要对存在或不存在的文件或设备执行的操作, 此参数通常设置为OPEN_EXISTING</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFlagsAndAttributes,    <span class="comment">// 文件或设备属性和标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HANDLE hTemplateFile       <span class="comment">// 具有GENERIC_READ访问权限的模板文件的有效句柄, 此参数可以为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info"><p><strong></strong></p><ul><li>如果函数成功, 则返回值是指定文件、设备、命名管道或邮件槽的打开句柄;</li><li>如果函数失败, 则返回值为INVALID_HANDLE_VALUE;</li></ul></div><span class='p medium'>GetFileSize</span><blockquote><p>检索指定文件的大小（以字节为单位）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">GetFileSize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile,      <span class="comment">// 文件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ LPDWORD lpFileSizeHigh        <span class="comment">// 指向变量的指针, 其中返回了文件大小的高位双字。如果应用程序不需要高位双字, 此参数可以为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong></strong></p><ul><li>如果函数成功, 则返回值为文件大小的低位双字, 如果lpFileSizeHigh为非NULL, 则该函数会将文件大小的高位双字放入该参数指向的变量中;</li><li>如果函数失败且lpFileSizeHigh为NULL, 则返回值INVALID_FILE_SIZE;</li></ul></div><span class='p medium'>ReadFile</span><blockquote><p>从指定的文件或输入&#x2F;输出 (I&#x2F;O) 设备读取数据</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hFile,      <span class="comment">// 文件/设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) __out_data_source(FILE) LPVOID lpBuffer,  <span class="comment">// 指向接收从文件或设备读取的数据的缓冲区的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nNumberOfBytesToRead,    <span class="comment">// 要读取的最多字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ LPDWORD lpNumberOfBytesRead,  <span class="comment">// 指向变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ LPOVERLAPPED lpOverlapped   <span class="comment">// 此参数可为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong></strong></p><ul><li>如果函数成功，则返回值为非零 (TRUE);</li><li>如果函数失败或正在异步完成，则返回值为零 (FALSE);</li></ul></div><h3 id="2-FileBuffer-ImageBuffer"><a href="#2-FileBuffer-ImageBuffer" class="headerlink" title="2. FileBuffer &#x3D;&gt; ImageBuffer"></a>2. FileBuffer &#x3D;&gt; ImageBuffer</h3><div class="note info"><p><strong></strong></p><p>将FileBuffer转换成ImageBuffer可以分为两步: </p><ol><li>先将PE头部复制至内存中;</li><li>然后循环将节内容复制过去;</li></ol></div><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MmMapFile</span><span class="params">(LPVOID lpData, LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析PE文件格式</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpData;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpData);</span><br><span class="line">    <span class="comment">// 获取PE header大小</span></span><br><span class="line">    DWORD dwSizeOfHeaders = pNt-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line">    <span class="comment">// 获取节数量</span></span><br><span class="line">    DWORD dwNumOfSections = pNt-&gt;FileHeader.NumberOfSections;</span><br><span class="line">    <span class="comment">// 将头部数据复制过去</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(lpBaseAddress, lpData, dwSizeOfHeaders);</span><br><span class="line">    <span class="comment">// 解析第一个节</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pSec = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNt);</span><br><span class="line">    <span class="comment">// 循环节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dwNumOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">0</span> == pSec[i].VirtualAddress) || (<span class="number">0</span> == pSec[i].PointerToRawData))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LPVOID lpSrcMem = (LPVOID)(pSec[i].PointerToRawData + (DWORD)lpData);</span><br><span class="line">        LPVOID lpDesMem = (LPVOID)(pSec[i].VirtualAddress + (DWORD)lpBaseAddress);</span><br><span class="line">        DWROD dwSizeOfRawData = pSec[i].SizeOfRawData;</span><br><span class="line">        <span class="built_in">RtlCopyMemory</span>(lpDesMem, lpSrcMem, dwSizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-修正重定位表"><a href="#3-修正重定位表" class="headerlink" title="3. 修正重定位表"></a>3. 修正重定位表</h3><div class="note info"><p><strong>重定位表</strong></p><ul><li>Relocation(重定位)是一种将程序中的一些地址修正为运行时可用的实际地址的机制。在程序编译过程中, 由于程序中使用了各种全局变量和函数, 这些变量和函数的地址还没有确定, 因此它们的地址只能暂时使用一个相对地址。当程序被加载到内存中运行时, 这些相对地址需要被修正为实际的绝对地址, 这个过程就是重定位;</li><li>在Windows操作系统中, 程序被加载到内存中运行时, 需要将程序中的各种内存地址进行重定位, 以使程序能正确运行。Windows系统使用PE(Portable Executable)文件格式来存储可执行程序, 其中包括重定位信息。当程序被加载到内存中时, 系统会解析这些重定位信息, 并将程序中的各种内存地址进行重定位。</li><li>重定位表一般出现在<code>Dll</code>中, 因为<code>Dll</code>都是动态加载, 所以地址不固定, Dll的入口点在整个执行过程中至少要执行2次, 一次时在开始时执行初始化工作, 一次则是在结束时做最后的收尾工作, 重定位表则是解决Dll的地址问题;</li></ul></div><p>重定位表的结构</p><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84.png' data-fancybox='default' data-caption='重定位结构'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="重定位结构"></a><span class='image-caption'>重定位结构</span></div></div><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DoRelocationTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析PE</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)lpBaseAddress);</span><br><span class="line">    <span class="comment">// 定位重定位位置</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC);</span><br><span class="line">    <span class="comment">// 获取重定位表</span></span><br><span class="line">    PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)(pDataDir-&gt;VirtualAddress + (DWORD)lpBaseAddress);</span><br><span class="line">    <span class="comment">// 判断是否有重定位表, 数据目录表不存在时, VirtualAddress为0, 也就是指向映像基址</span></span><br><span class="line">    <span class="keyword">if</span> ((LPVOID)pLoc == lpBaseAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环重定位表, 重定位表VirtualAddress和SizeOfBlock都为0表示重定位表结束</span></span><br><span class="line">    <span class="keyword">while</span>((pLoc.VirtualAddress + pLoc-&gt;SizeOfBlock) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 重定位数据, 位于IMAGE_BASE_RELOCATION表开头8字节之后</span></span><br><span class="line">        PWORD pLocData = (PWORD)((PBYTE)pLoc + <span class="built_in">szieof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line">        <span class="comment">// 计算本节需要修正的重定位项（地址）的数目, 每个数据都是16字节（4+12字节, 高4位表示重定位类型, 低12位为RVA）</span></span><br><span class="line">        <span class="comment">// SizeOfBlock的值包括了SizeOfBlock和VirtualAddress的大小, 8字节需要减去</span></span><br><span class="line">        DWORD dwNumOfpLoc = (pLoc-&gt;SizeOfBlock - <span class="built_in">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dwNumOfpLoc; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 高位为3表示有效重定位</span></span><br><span class="line">            <span class="keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x00003000</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 需要修正的数据</span></span><br><span class="line">                <span class="comment">// 修正重定位数据, 重定位表记录的是存在硬编码的地址, 以基址+偏移的形式</span></span><br><span class="line">                <span class="comment">// 存在硬编码的地址 = 重定位基址 + 重定位表数据偏移</span></span><br><span class="line">                <span class="comment">//      = 基址 + 重定位地址 + 重定位数据（数据后12位）</span></span><br><span class="line">                PDWORD pAddress = (PDWORD)((PBYTE)pDos + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">                <span class="comment">// 重定位地址 = 硬编码地址 - ImageBase + 实际基地址</span></span><br><span class="line">                <span class="comment">//           = 实际基地址 - ImageBase + 硬编码地址</span></span><br><span class="line">                <span class="comment">// *pAddress = *pAddress - pNt-&gt;OptionalHeader.ImageBase + (DWORD)pDos;</span></span><br><span class="line">                DWROD dwDelta = (DWORD)pDos + pNt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">                *pAddress += dwDelta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环下一个重定位区段</span></span><br><span class="line">        pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-修正导入表"><a href="#4-修正导入表" class="headerlink" title="4. 修正导入表"></a>4. 修正导入表</h3><p>PE加载器在加载PE的时候会将导入函数的地址填入导入地址表中, 导入表结构如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA) 导入名称表RVA</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses) 导入地址表RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>主要用到的是OriginalFirstThunk和FirstThunk; 这两个表用到的结构体是一样的(IMAGE_THUNK_DATA):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>如果指向导入名称表; 则内容是AddressOfData, 指向IMAGE_IMPORT_BY_NAME结构体;<br>如果指向导入地址表:</p><ul><li>序号导入的话, Ordinal首位是1, 低4位是导入序号;</li><li>名称导入的话, Function的值是函数地址;</li></ul><p>这里我们需要将导入函数的地址填入导入地址表中, 所以需要知道这个函数是怎么导入的, 然后通过GetProcAddress API获取函数地址, 然后将函数地址填入导入地址表中;</p><p>通过GetProcAddress获取函数地址, 需要知道Dll名称, 通过Dll名称获取模块句柄</p><p>所以代码流程是:</p><div class="note info"><p><strong>修正导入表流程</strong></p><ul><li>先获取导入表数组的数量和第一个成员的地址;</li><li>根据导入表的数量, 进行循环遍历;<ol><li>获取导入名称表;</li><li>获取导入地址表;</li><li>进行导入名称表的遍历(导入名称表数组以0作为最后一个成员结束);<ul><li>获取导入函数的名称或序号；</li><li>加载这个Dll, 通过名称或序号, 获取其函数地址;</li><li>将地址填入导入地址表;</li><li>进入下一次循环;</li></ul></li><li>进入下一次循环;</li></ol></li><li>两次遍历完成后, 导入表就已经完成了修正;</li></ul></div><p>代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DoImportTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析PE结构</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT);</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(pDir-&gt;VirtualAddress + (DWORD)pDos);</span><br><span class="line">    <span class="comment">// 循环遍历Dll导入表中的Dll以及获取导入表中的函数地址</span></span><br><span class="line">    <span class="type">char</span>* szDllName = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_THUNK_DATA pImportNameArray = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_IMPORT_BY_NAME pImportByName = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_THUNK_DATA pImportFuncAddrArray = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC pfFuncAddress = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pImport-&gt;OriginalFirstThunk)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取导入表中Dll的名称并加载Dll</span></span><br><span class="line">        szDllName = (<span class="type">char</span>*)(pImport-&gt;Name + (DWORD)pDos);</span><br><span class="line">        hDll = <span class="built_in">GetModuleHandleA</span>(szDllName);</span><br><span class="line">        <span class="keyword">if</span>(hDll == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hDll = <span class="built_in">LoadLibraryA</span>(szDllName);</span><br><span class="line">            <span class="keyword">if</span>(hDll == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pImport++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取OriginalFirstThunk以及对应的导入函数名称表首地址</span></span><br><span class="line">        pImportNameArray = (PIMAGE_THUNK_DATA)(pImport-&gt;OriginalFirstThunk + (DWORD)pDos);</span><br><span class="line">        <span class="comment">// 获取FirstThunk以及对应的导入函数地址表首地址</span></span><br><span class="line">        pImportFuncAddrArray = (PIMAGE_THUNK_DATA)(pImport-&gt;FirstThunk + (DWORD)pDos);</span><br><span class="line">        <span class="keyword">while</span>(TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == pImportNameArray[i].u1.AddressOfData)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">            pImportByName = (PIMAGE_IMPORT_BY_NAME)(pImportNameArray[i].u1.AddressOfData);</span><br><span class="line">            <span class="comment">// 判断导出函数是序号导出还是函数名称导出</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0x80000000</span> &amp; pImportNameArrar[i].u1.Ordinal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 序号导出</span></span><br><span class="line">                <span class="comment">// 当IMPORT_THUNK_DATA值的最高位为1时, 表示函数以序号方式导出, 此时低位被看作是一个函数序号</span></span><br><span class="line">                pfFuncAddress = <span class="built_in">GetProcAddress</span>(hDll, (LPCSTR)(pImportNameArray[i].u1.Ordinal &amp; <span class="number">0x0000FFFF</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 名称导出</span></span><br><span class="line">                pfFuncAddress = <span class="built_in">GetProcAddress</span>(hDll, (LPCSTR)pImportByName-&gt;Name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意此处的函数地址表的赋值, 要对照PE格式进行装载</span></span><br><span class="line">            pImportFuncAddrArray[i].u1.Function = (DWORD)pfFuncAddress;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pImport++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-修改Dll的加载基址ImageBase"><a href="#5-修改Dll的加载基址ImageBase" class="headerlink" title="5. 修改Dll的加载基址ImageBase"></a>5. 修改Dll的加载基址ImageBase</h3><div class="note info"><p><strong></strong></p><ul><li>PE加载器在加载PE的时候会将进程分配的基地址填入扩展头的ImageBase中;</li></ul></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetImageBase</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    pNt-&gt;OptionalHeader.ImageBase = (DWORD)lpBaseAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-修改DllMain入口点"><a href="#6-修改DllMain入口点" class="headerlink" title="6. 修改DllMain入口点"></a>6. 修改DllMain入口点</h3><div class="note info"><p><strong></strong></p><ul><li>调用Dll的入口函数DllMain, 函数地址则是PE文件的入口点;</li></ul></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CallDllMain</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    typedef_DllMain DllMain = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    DllMain = (typedef_DllMain)(pNt-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD)pDos);</span><br><span class="line">    <span class="comment">// 调用入口函数, 附加进程DLL_PROCESS_ATTACH</span></span><br><span class="line">    BOOL bRet = <span class="built_in">DllMain</span>((HINSTANCE)lpBaseAddress, DLL_PROCESS_ATTACH, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-获取Dll导出函数"><a href="#7-获取Dll导出函数" class="headerlink" title="7. 获取Dll导出函数"></a>7. 获取Dll导出函数</h3><div class="note info"><p><strong>导出表</strong></p><ul><li>PE文件运行, 需要依赖Dll; 系统Dll包括Kernel32.dll、User32.dll等;</li><li>导出表时当前PE文件提供了哪些函数给别人使用;</li><li>不管是exe还是Dll, 本质都是PE文件; exe文件也可以导出函数给别人使用; 一般exe没有, 但不是不可以;</li></ul></div><p>导出表结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics;        <span class="comment">// </span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 时间戳, 编译时间; 把秒转为时间, 可以知道这个Dll是什么时候编译出来的</span></span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;                   <span class="comment">// 指向该导出表文件名的字符串, 也就是这个Dll的名称(RVA)</span></span><br><span class="line">    DWORD   Base;                   <span class="comment">// 导出函数的起始序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;      <span class="comment">// 所有导出函数的个数</span></span><br><span class="line">    DWORD   NumberOfNames;          <span class="comment">// 以名称导出的函数个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image（导出的函数地址表）</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image（导出的函数名称表）</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image（导出的函数序号表）</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>遍历流程</strong></p><ol><li>获取导出函数名称;</li><li>比较是否是要找函数名称;</li><li>如果是, 则获取函数序号(2字节);</li><li>根据函数序号获取函数地址;</li></ol></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">MmGetProcAddress</span><span class="params">(LPVOID lpBaseAddress, <span class="type">wchar_t</span>* lpszFuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + (DWORD)pDos);</span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pDir-&gt;VirtualAddress + (DWORD)pDos);</span><br><span class="line"></span><br><span class="line">    PDWORD dwAddressOfFunctions = (PDWORD)(pExport-&gt;AddressOfFunctions + (DWORD)pDos);</span><br><span class="line">    PDWORD dwAddressOfNames = (PDWORD)(pExport-&gt;AddressOfNames + (DWORD)pDos);</span><br><span class="line">    PWORD pwAddressOfNameOrdinals = (PWORD)(pExport-&gt;AddressOfNameOrdinals + (DWORD)pDos);</span><br><span class="line"></span><br><span class="line">    DWORD dwNumberOfNames = pExport-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dwNumberOfNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dwAddressOfFunctions[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PWCHAR szFuncName = (PWCHAR)(dwAddressOfNames[i] + (DWORD)pDos);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lstrcmpi</span>(lpszFuncName, szFuncName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (LPVOID)(dwAddressOfFunctions[pwAddressOfNameOrdinals[i]] + (DWORD)pDos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LPVOID</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-释放内存加载的Dll"><a href="#8-释放内存加载的Dll" class="headerlink" title="8. 释放内存加载的Dll"></a>8. 释放内存加载的Dll</h3><p>释放资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MmFreeLibrary</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL bRet = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == lpBaseAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line">bRet = <span class="built_in">VirtualFree</span>(lpBaseAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">lpBaseAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存加载Dll执行演示"><a href="#内存加载Dll执行演示" class="headerlink" title="内存加载Dll执行演示"></a>内存加载Dll执行演示</h2><h3 id="示例Dll源代码"><a href="#示例Dll源代码" class="headerlink" title="示例Dll源代码"></a>示例Dll源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport)<span class="function"><span class="type">void</span> <span class="title">ShowMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;I&#x27;m DLL File&quot;</span>, <span class="string">L&quot;HELLO&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PELoader-Demo-cpp"><a href="#PELoader-Demo-cpp" class="headerlink" title="PELoader_Demo.cpp"></a>PELoader_Demo.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PELoader_Demo.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MmLoadDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> szFileName[MAX_PATH] = <span class="string">L&quot;C:\\Users\\dell\\OneDrive\\桌面\\哔哩哔哩学习\\PE Learn\\PELoader_Demo\\Debug\\TestDLL_01.dll&quot;</span>;</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        szFileName, </span><br><span class="line">        GENERIC_READ | GENERIC_WRITE, </span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE, </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        OPEN_EXISTING, </span><br><span class="line">        FILE_ATTRIBUTE_ARCHIVE, </span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Failed: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FileSize: %d\n&quot;</span>, dwFileSize);</span><br><span class="line">    <span class="comment">// 申请动态内存并读取DLL到内存中</span></span><br><span class="line">    PBYTE lpData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">    <span class="keyword">if</span> (lpData == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存出错: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    BOOL bRet =  <span class="built_in">ReadFile</span>(hFile, lpData, dwFileSize, &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadFile Failed: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lpData: %08x\n&quot;</span>, *(<span class="type">short</span>*)lpData);</span><br><span class="line">    <span class="comment">// 将内存DLL加载到程序中</span></span><br><span class="line">    LPVOID lpBaseAddress = <span class="built_in">MmLoadLibrary</span>(lpData, dwFileSize);</span><br><span class="line">    <span class="keyword">if</span> (lpBaseAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MmLoadLibrary Failed: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DLL加载成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL导出函数并调用</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*typedef_ShowMessage)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* szName = <span class="string">&quot;ShowMessage&quot;</span>;</span><br><span class="line">    typedef_ShowMessage ShowMessage = (typedef_ShowMessage)<span class="built_in">MmGetProcAddress</span>(lpBaseAddress, (<span class="type">wchar_t</span>*)szName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ShowMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MmGetProcAddress Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ShowMessage</span>();</span><br><span class="line">    <span class="comment">// 释放从内存加载的DLL</span></span><br><span class="line">    BOOL bRet1 = <span class="built_in">MmFreeLibrary</span>(lpBaseAddress);</span><br><span class="line">    <span class="keyword">if</span> (FALSE == bRet1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MmFreeLibrary Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">delete</span>[] lpData;</span><br><span class="line">    lpData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用导出函数"><a href="#调用导出函数" class="headerlink" title="调用导出函数"></a>调用导出函数</h3><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/%E8%B0%83%E7%94%A8%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0.png' data-fancybox='default' data-caption='调用导出函数'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/%E8%B0%83%E7%94%A8%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/%E8%B0%83%E7%94%A8%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="调用导出函数"></a><span class='image-caption'>调用导出函数</span></div></div><h3 id="内存加载exe执行"><a href="#内存加载exe执行" class="headerlink" title="内存加载exe执行"></a>内存加载exe执行</h3><p>待补充…</p><h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Dooookey/PELoader_Demo"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Dooookey&repo=PELoader_Demo&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=Dooookey&repo=PELoader_Demo&show_owner=true" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><div class="note info"><p><strong>参考书籍</strong></p><ul><li>《Windwos黑客编程技术详解》第4章第3节</li></ul></div><p>参考Blog</p><div class="btns rounded wide grid5">            <a class="button" href='https://www.kn0sky.com/?p=37#%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0' title='kn0sky'><img src='https://www.kn0sky.com/upload/anvtor.jpg'>kn0sky</a><a class="button" href='https://www.lyshark.com/post/3c1b31b5.html' title='lyshark'><img src='https://www.lyshark.com/about/about.png'>lyshark</a>          </div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;内存直接加载运行&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;病毒木马具有模拟PE加载器的功能, 它们可以把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去执行, 不需要通过LoadLibrary等现成的API函数去操作;&lt;/li&gt;&lt;li&gt;假如程序需要动态调用DLL文件, 内存加载运行技术可以把DLL作为资源插入到自己的程序中, 此时可直接在内存中加载运行即可;&lt;/li&gt;&lt;li&gt;内存加载技术的核心就在于模拟PE加载器PE文件, 也就是对导入表、导出表、重定位表的操作过程;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows PE" scheme="http://example.com/categories/Windows-PE/"/>
    
    
    <category term="Windows PE" scheme="http://example.com/tags/Windows-PE/"/>
    
  </entry>
  
  <entry>
    <title>IAT-Hook</title>
    <link href="http://example.com/3aecea41.html"/>
    <id>http://example.com/3aecea41.html</id>
    <published>2023-05-28T02:05:22.000Z</published>
    <updated>2023-05-29T15:34:39.071Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>IAT Hook</strong></p><ul><li><code>IMAGE_IMPORT_DESCRIPTOR</code>中两个<code>IMAGE_THUNK_DATA</code>结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，<code>FirstThunk</code>字段指向的<code>IMAGE_THUNK_DATA</code>的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址</li><li>IAT Hook步骤<ol><li>获取欲Hook的函数地址</li><li>找到该函数的所保存的IAT地址</li><li>把IAT中该函数的地址修改为Hook函数的地址</li></ol></li></ul></div><span id="more"></span><h2 id="遍历64位IAT函数名和地址"><a href="#遍历64位IAT函数名和地址" class="headerlink" title="遍历64位IAT函数名和地址"></a>遍历64位IAT函数名和地址</h2><div class="note red bug"><p><strong>遍历64位IAT函数名和地址</strong></p><ul><li><code>GetModuleHandle</code>：参数只有1个，是目标模块名，此处填NULL表示当前进程，返回的是一个进程句柄，也就是当前进程的首地址</li></ul><hr><ul><li>区别：<ul><li>64位程序的基地址是<code>Unsigned Long Long</code>类型，用DWORD64表示</li><li>运行中的程序，IAT里记录的是VA而不是RVA</li><li>运行中的程序，INT里记录的是RVA而不是VA</li></ul></li></ul></div><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前程序的首地址</span></span><br><span class="line">    HMODULE hModuel = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 定位DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    <span class="comment">// 定位NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导入表RVA</span></span><br><span class="line">    DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">    <span class="comment">// 定位导入表</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(dwImportRVA + (DWORD64)hModule);</span><br><span class="line">    <span class="keyword">while</span>(pImport-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* szDllName = (<span class="type">char</span>*)((DWORD64)hModule + pImport-&gt;Name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, szDllName);</span><br><span class="line">        PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk);</span><br><span class="line">        PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;OriginalFirstThunk);</span><br><span class="line">        <span class="keyword">if</span>(pIAT-&gt;u1.Oridianl != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pIAT-&gt;u1.Function)</span><br><span class="line">                </span><br><span class="line">                PIMAGE_IMPORT_BY_NAME pFuncName = (PIMAGE_IMPORT_BY_NAME)((DWORD64)hModule + pINT-&gt;AddressOfData);</span><br><span class="line">                PDWORD64 dwFuncAddr = (PDWORD64)(pIAT-&gt;Function);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;函数名称：%-50s&quot;</span>, pFuncName);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;函数地址：%p\n&quot;</span>, dwFuncAddr);</span><br><span class="line">                pINT++;</span><br><span class="line">                pIAT++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImport++;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hook-CreateFileW"><a href="#Hook-CreateFileW" class="headerlink" title="Hook CreateFileW"></a>Hook CreateFileW</h2><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MyCreateFileW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPCWSTR lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HANDLE hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;打开文件操作被拦截&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_YESNO) == IDYES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CreateFileW</span>(</span><br><span class="line">            lpFileName,</span><br><span class="line">            dwDesiredAccess,</span><br><span class="line">            dwShareMode,</span><br><span class="line">            lpSecurityAttributes,</span><br><span class="line">            dwCreationDisposition,</span><br><span class="line">            dwFlagsAndAttributes,</span><br><span class="line">            hTemplateFile</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;文件打开失败&quot;</span>, <span class="string">L&quot;警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">IATHook</span><span class="params">(LPCWSTR lpModuleName, <span class="type">const</span> <span class="type">char</span>* szFuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD64 dwFuncAddr = (DWROD64)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(lpModuleName), szFuncName);</span><br><span class="line">    <span class="comment">// 获取程序基址</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 定位DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">    <span class="comment">// 定位NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD64)hModule + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导入表RVA</span></span><br><span class="line">    DWORD64 dwImportRVA = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line">    <span class="comment">// 定位导入表</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD64)hModule + dwImportRVA);</span><br><span class="line">    <span class="keyword">while</span>(pImport-&gt;Nmae)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* szDllName = (<span class="type">char</span>*)((DWORD64)hModule + pImport-&gt;Name);</span><br><span class="line">        <span class="type">char</span> szName[MAXBYTE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">strcpy_s</span>(szName, szDllName)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(_strlwr(szName), <span class="string">&quot;kernel32.dll&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((DWORD64)hModule + pImport-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">while</span>(pThunk-&gt;Function)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pThunk-&gt;Function == dwFuncAddr)</span><br><span class="line">                &#123;</span><br><span class="line">                    DWORD64 dwOldProtect;</span><br><span class="line">                    <span class="built_in">VirtualProtectEx</span>(<span class="built_in">GetCurrentProcess</span>(), (LPVOID)&amp;pThunk-&gt;Function, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">                    pThunk-&gt;Function = (DWORD64)MyCreateFileW;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pThunk++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pImport++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">IATHook</span>(<span class="string">L&quot;kernel32.dll&quot;</span>, <span class="string">L&quot;CreateFileW&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;IAT Hook&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;IMAGE_IMPORT_DESCRIPTOR&lt;/code&gt;中两个&lt;code&gt;IMAGE_THUNK_DATA&lt;/code&gt;结构体，第一个位导入名称表（INT），第二个位导入地址表（IAT）。两个结构在磁盘文件中时是没有差别的，但是当PE文件被装载到内存中后，&lt;code&gt;FirstThunk&lt;/code&gt;字段指向的&lt;code&gt;IMAGE_THUNK_DATA&lt;/code&gt;的值会被Windows进行填充。该值为一个RVA，该RVA加上映像基址后，虚拟地址就保存了真正的导入函数的入口地址&lt;/li&gt;&lt;li&gt;IAT Hook步骤&lt;ol&gt;&lt;li&gt;获取欲Hook的函数地址&lt;/li&gt;&lt;li&gt;找到该函数的所保存的IAT地址&lt;/li&gt;&lt;li&gt;把IAT中该函数的地址修改为Hook函数的地址&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows" scheme="http://example.com/categories/Windows/"/>
    
    
    <category term="windows Hook" scheme="http://example.com/tags/windows-Hook/"/>
    
  </entry>
  
  <entry>
    <title>Inline Hook</title>
    <link href="http://example.com/1b00de47.html"/>
    <id>http://example.com/1b00de47.html</id>
    <published>2023-05-21T03:22:04.000Z</published>
    <updated>2023-05-27T13:24:14.208Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>Inline Hook(内联钩子注入)流程</strong></p><ol><li>构造跳转指令[JMP后的偏移量 &#x3D; 目标地址 - 原地址 - jcc的指令长度]</li><li>在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节</li><li>将构造的跳转指令写入需HOOK的位置处</li><li>当被HOOK位置被执行时会转到自己的流程执行</li><li>如果要执行原来的流程，取消HOOK，还原被修改的字节</li><li>执行原来的流程</li><li>继续HOOK住原来的位置</li></ol></div><span id="more"></span><h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/Dooookey/Inline_Hook"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Dooookey&repo=Inline_Hook&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=Dooookey&repo=Inline_Hook&show_owner=true" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></a><h2 id="5字节Inline-Hook（x86）"><a href="#5字节Inline-Hook（x86）" class="headerlink" title="5字节Inline Hook（x86）"></a>5字节Inline Hook（x86）</h2><div class="note message"><p><strong></strong></p><ul><li>5字节<code>Inline Hook</code>中jcc指令长度为5</li><li>根据计算公式：JMP后的偏移量 &#x3D; 目标地址 - 原地址- 5</li></ul></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">PROC m_FuncAddress;     <span class="comment">// 要Hook的函数地址</span></span><br><span class="line">BYTE m_OldBytes[<span class="number">5</span>];     <span class="comment">// 要Hook函数的头5个字节</span></span><br><span class="line">BYTE m_NewBytes[<span class="number">5</span>];     <span class="comment">// 要替换到目标函数头五个字节的新字节（jmp xxxxxxxx/ E9 xxxxxxxx）</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Hook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszModuleName, <span class="type">const</span> <span class="type">char</span>* pszFuncName, PROC pfnHookFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_FuncAddress = (PROC)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(pszModuleName), pszFuncName);</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">5</span>, &amp;dwSize);</span><br><span class="line">    m_NewBytes[<span class="number">0</span>] = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(m_NewBytes + <span class="number">1</span>) = (DWORD)pfnHookFunc - (DWORD)m_FuncAddress - <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">5</span>, &amp;dwSize);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_FuncAddress != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">5</span>, &amp;dwSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_FuncAddress != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">5</span>, &amp;dwSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MyMessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UnHook</span>();</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;Hello Dokey&quot;</span>, <span class="string">&quot;Hello Dokey&quot;</span>, uType);</span><br><span class="line">    <span class="built_in">ReHook</span>();</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VA Virtual Address </span></span><br><span class="line"><span class="comment">// HMODULE hModule 模块加载基址 ImageBase  模块句柄</span></span><br><span class="line"><span class="comment">// DWORD  ul_reason_for_call 以什么原因触发的</span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// MessageBox(NULL, &quot;Dokey&quot;, &quot;Dokey&quot;, MB_OK);</span></span><br><span class="line">        m_FuncAddress = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_OldBytes, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">memset</span>(m_NewBytes, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">Hook</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxA&quot;</span>, (PROC)MyMessageBoxA);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="built_in">UnHook</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7字节Inline-Hook（x86）"><a href="#7字节Inline-Hook（x86）" class="headerlink" title="7字节Inline Hook（x86）"></a>7字节Inline Hook（x86）</h2><div class="note message"><p><strong></strong></p><ul><li>5字节<code>Inline Hook</code>通过构造一个jmp指令来修改目标函数入口的字节内容，jmp指令后面的偏移量是由于CPU机器码要求jmp指令后是一个偏移量</li><li>7字节<code>Inline Hook</code>通过修改函数入口的两条指令来完成<ul><li>一条是把目标地址存入寄存器<code>eax</code>中: <code>mov eax, xxxxxxxx / B8 xxxxxxxx</code></li><li>然后用jmp指令直接跳转到寄存器<code>eax</code>中保存的地址: <code>jmp eax / FF E0</code></li><li>通过指令的机器码是不变的，变化的只有地址，需要将目标函数地址保存在从第一至第四字节的位置就可以了</li><li><code>Byte bJmpCode[] = {&#39;\xb8&#39;, &#39;\0&#39;, &#39;\0&#39;, &#39;\0&#39;, &#39;\0&#39;, &#39;\xff&#39;, &#39;\xe0&#39;}</code></li></ul></li></ul></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PROC m_FuncAddress;</span><br><span class="line">BYTE m_OldBytes[<span class="number">7</span>];</span><br><span class="line">BYTE m_NewBytes[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Hook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszModuleName, <span class="type">const</span> <span class="type">char</span>* pszFuncName, PROC pfnHookFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_FuncAddress = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(pszModuleName), pszFuncName);</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">7</span>, &amp;dwSize);</span><br><span class="line">    m_NewBytes[<span class="number">0</span>] = <span class="string">&#x27;\xb8&#x27;</span>;</span><br><span class="line">    m_NewBytes[<span class="number">5</span>] = <span class="string">&#x27;\xff&#x27;</span>;</span><br><span class="line">    m_NewBytes[<span class="number">6</span>] = <span class="string">&#x27;\xe0&#x27;</span>;</span><br><span class="line">    *(DWORD*)(m_NewBytes + <span class="number">1</span>) = (DWORD)pfnHookFunc;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">7</span>, &amp;dwSize);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">7</span>, &amp;dwSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">7</span>, &amp;dwSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12字节Inline-Hook（x64）"><a href="#12字节Inline-Hook（x64）" class="headerlink" title="12字节Inline Hook（x64）"></a>12字节Inline Hook（x64）</h2><div class="note message"><p><strong></strong></p><ul><li>原理： <code>mov rax, Address/jmp rax</code>;</li><li>硬编码： <code>Byte[12] = {0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xe0}</code></li></ul></div><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">PROC m_FuncAddress;</span><br><span class="line">BYTE m_OldBytes[<span class="number">12</span>];</span><br><span class="line">BYTE m_NewBytes[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Hook</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszModulesName, <span class="type">const</span> <span class="type">char</span>* pszFuncName, PROC pfnHookFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_FuncAddress = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(pszModuleName), pszFuncName);</span><br><span class="line">    <span class="keyword">if</span> (m_FuncAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">12</span>, &amp;dwSize);</span><br><span class="line">    m_NewBytes[<span class="number">0</span>] = <span class="string">&#x27;\x48&#x27;</span>;</span><br><span class="line">    m_NewBytes[<span class="number">1</span>] = <span class="string">&#x27;\xb8&#x27;</span>;</span><br><span class="line">    m_NewBytes[<span class="number">10</span>] = <span class="string">&#x27;\xff&#x27;</span>;</span><br><span class="line">    m_NewBytes[<span class="number">11</span>] = <span class="string">&#x27;\xe0&#x27;</span>;</span><br><span class="line">    *(DWORD64*)(m_NewBytes + <span class="number">2</span>) = (DWORD64)pfnHookFunc;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">12</span>, &amp;dwSize);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SITE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_OldBytes, <span class="number">12</span>, &amp;dwSize);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_FuncAddress == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZTE_T dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), m_FuncAddress, m_NewBytes, <span class="number">12</span>, &amp;dwSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MyMessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UnHook</span>();</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">MessageBoxA</span>(hWnd, <span class="string">&quot;Dokey 12&quot;</span>, <span class="string">&quot;Dokey 12&quot;</span>, uType);</span><br><span class="line">    <span class="built_in">ReHook</span>();</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MyMessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UnHook</span>();</span><br><span class="line">    <span class="type">int</span> nRet = <span class="built_in">MessageBoxW</span>(hWnd, <span class="string">L&quot;Dokey 12&quot;</span>, <span class="string">L&quot;Dokey 12&quot;</span>, uType);</span><br><span class="line">    <span class="built_in">ReHook</span>();</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MyMessageBox MyMessageBoxW</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MessageBoxText = <span class="string">&quot;MessageBoxW&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MyMessageBox MyMessageBoxA</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MessageBoxText = <span class="string">&quot;MessageBoxA&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;Inline Hook(内联钩子注入)流程&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;构造跳转指令[JMP后的偏移量 &amp;#x3D; 目标地址 - 原地址 - jcc的指令长度]&lt;/li&gt;&lt;li&gt;在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5个字节&lt;/li&gt;&lt;li&gt;将构造的跳转指令写入需HOOK的位置处&lt;/li&gt;&lt;li&gt;当被HOOK位置被执行时会转到自己的流程执行&lt;/li&gt;&lt;li&gt;如果要执行原来的流程，取消HOOK，还原被修改的字节&lt;/li&gt;&lt;li&gt;执行原来的流程&lt;/li&gt;&lt;li&gt;继续HOOK住原来的位置&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows" scheme="http://example.com/categories/Windows/"/>
    
    
    <category term="windows Hook" scheme="http://example.com/tags/windows-Hook/"/>
    
  </entry>
  
  <entry>
    <title>远程线程注入</title>
    <link href="http://example.com/cf459526.html"/>
    <id>http://example.com/cf459526.html</id>
    <published>2023-05-17T13:46:55.000Z</published>
    <updated>2023-05-28T02:23:25.367Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong></strong></p><ul><li>远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。</li></ul></div><span id="more"></span><h2 id="CreateRemoteThread-远程线程注入"><a href="#CreateRemoteThread-远程线程注入" class="headerlink" title="CreateRemoteThread 远程线程注入"></a>CreateRemoteThread 远程线程注入</h2><h3 id="OpenProcess-函数"><a href="#OpenProcess-函数" class="headerlink" title="OpenProcess 函数"></a>OpenProcess 函数</h3><blockquote><p>打开现有的本地进程对象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwProcessId</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>OpenProcess</strong></p><ul><li><code>dwDesiredAccess</code>: 访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或多个进程访问权限。</li><li><code>bInheritHandle</code>: 此进程创建的进程是否可以继承该句柄</li><li><code>dwProcessId</code>: 要打开的本地进程PID</li></ul><hr><ul><li>如果函数成功，则返回值是打开指定进程的句柄</li><li>如果函数失败，则返回值为NULL</li></ul></div><h3 id="VirtualAllocEx-函数"><a href="#VirtualAllocEx-函数" class="headerlink" title="VirtualAllocEx 函数"></a>VirtualAllocEx 函数</h3><blockquote><p>在指定进程的虚拟地址空间内保留、提交或更改内存状态</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>VirtualAllocEx</strong></p><ul><li><code>hProcess</code>: 进程句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有<code>PROCESS_VM_OPERATION</code>权限</li><li><code>lpAddress</code>: 指定要分配页面所需起始地址的指针。如果<code>lpAddress</code>为NULL，则该函数自动分配内存</li><li><code>dwSize</code>: 要分配内存大小，以字节为单位</li><li><code>flAllocationType</code>: 内存分配类型。此参数必须为以下值之一</li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>MEM_COMMIT</td><td>在磁盘分页和整体内存中，为指定预留内存页分配内存</td></tr><tr><td>MEM_RESERVE</td><td>保留进程中虚拟地址空间的范围，但不会在磁盘或内存上的分页文件中分配任何实际物理存储位置</td></tr><tr><td>MEM_RESET</td><td>表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入</td></tr><tr><td>MEM_RESET_UNDO</td><td>只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO</td></tr></tbody></table><ul><li><code>flProtect</code>: 要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则<code>flProtect</code>不能是以下值之一<ul><li><code>PAGE_NOACCESS</code></li><li><code>PAGE_GUARD</code></li><li><code>PAGE_NOCACHE</code></li><li><code>PAGE_WRITECOMBINE</code></li></ul></li></ul><hr><p>如果函数成功，则返回值是分配页面的基址<br>如果函数失败，则返回值为NULL</p></div><h3 id="WriteProcessMemory-函数"><a href="#WriteProcessMemory-函数" class="headerlink" title="WriteProcessMemory 函数"></a>WriteProcessMemory 函数</h3><blockquote><p>在指定进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_(nSize) LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ SIZE_T* lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>WriteProcessMemory</strong></p><ul><li><code>hProcess</code>: 要修改的进程内存句柄。句柄必须具有PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION访问权限</li><li><code>lpBaseAddress</code>: 指向指定进程中写入数据的基地址指针。在数据传输之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败</li><li><code>lpBuffer</code>: 指向缓冲区指针。其中包含要写入指定进程的地址空间中的数据</li><li><code>nSize</code>: 要写入指定进程的字节数</li><li><code>lpNumberOfBytesWritten</code>: 指向变量指针，该变量接收传输到指定进程的字节数。如果<code>lpNumberOfBytesWritten</code>为NULL，则忽略该参数</li></ul><hr><p>如果函数成功，则返回值不为零<br>如果函数失败，则返回值为零</p></div><h3 id="CreateRemoteThread-函数"><a href="#CreateRemoteThread-函数" class="headerlink" title="CreateRemoteThread 函数"></a>CreateRemoteThread 函数</h3><blockquote><p>在另一个进程的虚拟地址空间中创建运行的线程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>CreateRemoteThread</strong></p><ul><li><code>hProcess</code>: 要创建线程的进程句柄。句柄必须具有<code>PROCESS_CREATE_THREAD</code>、<code>PROCESS_QUERY_INFORMATION</code>、<code>PROCESS_VM_OPERATION</code>、<code>PROCESS_VM_WRITE</code>和<code>PEOCESS_VM_READ</code>访问权限</li><li><code>lpThreadAttributes</code>: 指向<code>SECURITY_ATTRIBUTES</code>结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果<code>lpThreadAttributes</code>为NULL，则线程将获得默认的安全描述符，并且不能继承该句柄</li><li><code>dwStackSize</code>: 堆栈的初始化大小，以字节为单位。如果此参数为0，则新线程使用可执行文件的默认大小</li><li><code>lpStartAddress</code>: 指向由线程执行类型为<code>LPTHREAD_START_ROUTINE</code>的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中</li><li><code>lpParameter</code>: 指向要传递给线程函数的变量指针</li><li><code>dwCreationFlags</code>: 控制线程创建的标志，若是0，则表示线程在创建后立即执行</li><li><code>lpThreadId</code>: 指向接收线程标识符的变量指针。如果此参数为NULL，则不返回线程标识符</li></ul><hr><p>如果函数成功，则返回值是新线程的句柄<br>如果函数失败，则返回值为NULL</p></div><h3 id="远程线程注入代码实现"><a href="#远程线程注入代码实现" class="headerlink" title="远程线程注入代码实现"></a>远程线程注入代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Inject</span><span class="params">(DWORD dwPid, <span class="type">const</span> WCHAR* szPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开进程</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    LPVOID lpAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_CONMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpAddress == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把动态链接库写入到目标内存中</span></span><br><span class="line">    SIZE_T szWriteLength = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lpAddress, szPath, ((<span class="built_in">wcslen</span>(szPath) + <span class="number">1</span>) * <span class="number">2</span>), &amp;szWrithLength);</span><br><span class="line">    <span class="comment">// 创建远程线程，把LoadLibrary作为回调函数，并且把刚才的地址作为参数进行调用</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程执行结束</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 清理、释放空间</span></span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, lpAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZwCreateThreadEx-突破-SESSION-0-隔离的远程线程注入"><a href="#ZwCreateThreadEx-突破-SESSION-0-隔离的远程线程注入" class="headerlink" title="ZwCreateThreadEx 突破 SESSION 0 隔离的远程线程注入"></a>ZwCreateThreadEx 突破 SESSION 0 隔离的远程线程注入</h2><blockquote><p>与传统的<code>CreateRemoteThread</code>函数实现的远程线程注入DLL的唯一区别在于，突破<code>SESSION 0</code>远程线程注入是使用比<code>CreateRemoteThred</code>函数更为底层的<code>ZwCreateThreadEx</code>函数来创建远程线程。<code>ZwCreateThreadEx</code>函数可以突破<code>SESSION 0</code>隔离，将DLL成功注入到<code>SESSION 0</code>隔离的系统服务进程中。其中<code>ZwCreateThreadEx</code>在<code>ntdll.dll</code>中并没有声明，所以需要使用<code>GetProcAddress</code>从<code>ntdll.dll</code>中获取该函数的导出地址</p></blockquote><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p><strong>64位系统下函数声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p><strong>32位系统下函数声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h3 id="ZwCreateThreadEx-注入代码实现"><a href="#ZwCreateThreadEx-注入代码实现" class="headerlink" title="ZwCreateThreadEx 注入代码实现"></a>ZwCreateThreadEx 注入代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInjectDll</span><span class="params">(DWORD dwPid, <span class="type">char</span>* szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开进程句柄</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在目标进程申请内存</span></span><br><span class="line">    DWORD dwSize = <span class="number">1</span> + <span class="built_in">lstrlen</span>(szDllPath);</span><br><span class="line">    LPVOID lpDllAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="comment">// 将数据写入目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, lpDllAddress, szDllPath, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 获取ntdll.dll</span></span><br><span class="line">    HMODULE hNtDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(hNtDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Load ntdll Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取LoadLibrary地址</span></span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pFuncProcAddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Get LoadLibrary Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取ZwCreateThreadEx地址</span></span><br><span class="line">    typedef_ZwCreateThreadEx zwCreateThreadEx = (typedef_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    HANDLE hRemoteThread = <span class="number">0</span>;</span><br><span class="line">    DWORD dwZwCreateThreadEx = <span class="built_in">zwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, lpDllAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(hRemoteThread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;zwCreateThreadEx Failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, lpDllAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenProcess打开高权限的进程需要提权</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnablePrivileges</span><span class="params">(HANDLE hProcess, <span class="type">const</span> <span class="type">char</span>* pszPrivilegesName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    LUID luidValue = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TOKEN_PRIVILEGES tokenPrivileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 打开进程令牌并获取进程令牌句柄</span></span><br><span class="line">    bRet = ::<span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">    <span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取本地系统的 pszPrivilegesName 特权的LUID值</span></span><br><span class="line">    bRet = ::<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, pszPrivilegesName, &amp;luidValue);</span><br><span class="line">    <span class="keyword">if</span> (FALSE == bRet) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置提升权限信息</span></span><br><span class="line">    tokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tokenPrivileges.Privileges[<span class="number">0</span>].Luid = luidValue;</span><br><span class="line">    tokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="comment">// 提升进程令牌访问权限</span></span><br><span class="line">    bRet = ::<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tokenPrivileges, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (FALSE == bRet) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据错误码判断是否特权都设置成功</span></span><br><span class="line">        dwRet = ::<span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (ERROR_SUCCESS == dwRet) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SUCCESS!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ERROR_NOT_ALL_ASSIGNED == dwRet) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR_NOT_ALL_ASSIGNED&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">    <span class="built_in">EnablePrivileges</span>(hProcess, SE_DEBUG_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* szDllPath = <span class="string">&quot;C:\\Users\\dell\\OneDrive\\桌面\\Dll1.dll&quot;</span>;</span><br><span class="line">    <span class="built_in">ZwCreateThreadExInjectDll</span>(<span class="number">1364</span>, szDllPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卸载被注入的DLL文件"><a href="#卸载被注入的DLL文件" class="headerlink" title="卸载被注入的DLL文件"></a>卸载被注入的DLL文件</h2><h3 id="FreeLibrary-函数"><a href="#FreeLibrary-函数" class="headerlink" title="FreeLibrary 函数"></a>FreeLibrary 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">FreeLibrary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HMODULE hLibModule     <span class="comment">// dll 模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>FreeLibrary</strong></p><ul><li><code>FreeLibrary</code>函数使用的模块句柄可以通过前面介绍的<code>Module32First</code>和<code>Module32Next</code>两个函数获取，需要用到<code>MODULEENTRY32</code>结构体</li></ul></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMODULEENTRY32</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD   dwSize;</span><br><span class="line">    DWORD   th32ModuleID;       <span class="comment">// This module</span></span><br><span class="line">    DWORD   th32ProcessID;      <span class="comment">// owning process</span></span><br><span class="line">    DWORD   GlblcntUsage;       <span class="comment">// Global usage count on the module</span></span><br><span class="line">    DWORD   ProccntUsage;       <span class="comment">// Module usage count in th32ProcessID&#x27;s context</span></span><br><span class="line">    BYTE  * modBaseAddr;        <span class="comment">// Base address of module in th32ProcessID&#x27;s context</span></span><br><span class="line">    DWORD   modBaseSize;        <span class="comment">// Size in bytes of module starting at modBaseAddr</span></span><br><span class="line">    HMODULE hModule;            <span class="comment">// The hModule of this module in th32ProcessID&#x27;s context</span></span><br><span class="line">    <span class="type">char</span>    szModule[MAX_MODULE_NAME32 + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>    szExePath[MAX_PATH];</span><br><span class="line">&#125; MODULEENTRY32;</span><br></pre></td></tr></table></figure><div class="note red bug"><p><strong>MODULEENTRY32</strong></p><ul><li><code>hModule</code>: 模块句柄</li><li><code>szModule</code>: 模块名称</li><li><code>szExePath</code>: 完整的模块的路径（包括路径和模块名称）</li></ul></div><h3 id="卸载DLL文件代码实现"><a href="#卸载DLL文件代码实现" class="headerlink" title="卸载DLL文件代码实现"></a>卸载DLL文件代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">UnInjectDll</span><span class="params">(DWORD dwPid, <span class="type">char</span>* szDllName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dwPid == <span class="number">0</span> || <span class="built_in">lstrlen</span>(szDllName) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拍摄进程快照，需要包含TlHelp32.h头文件</span></span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SANPMODULE, dwPid)</span><br><span class="line">    MODULEENTRY32 me32;</span><br><span class="line">    me32.dwSize = <span class="built_in">sizeof</span>(me32);</span><br><span class="line">    <span class="comment">// 查找匹配的模块名</span></span><br><span class="line">    BOOL bRet = <span class="built_in">Module32First</span>(hSnap, &amp;me32);</span><br><span class="line">    <span class="keyword">while</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lstrcmp</span>(<span class="built_in">strupr</span>(me32.szExePath), <span class="built_in">strupr</span>(szDllName)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = <span class="built_in">Module32Next</span>(hSnap, &amp;me32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnap);</span><br><span class="line">    <span class="comment">// 打开进程</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="comment">// 获取FreeLibrary函数地址</span></span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;FreeLibrary&quot;</span>);</span><br><span class="line">    <span class="comment">// 卸载dll</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pFuncProcAddr, me32.hModule, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无DLL的代码注入"><a href="#无DLL的代码注入" class="headerlink" title="无DLL的代码注入"></a>无DLL的代码注入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> STRLEN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Data</span> &#123;</span><br><span class="line">    FARPROC dwLoadLibrary;</span><br><span class="line">    FARPROC dwGetProcAddress;</span><br><span class="line">    FARPROC dwGetModuleHandle;</span><br><span class="line">    FARPROC dwGetModuleFileName;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> User32Dll[STRLEN];</span><br><span class="line">    <span class="type">char</span> MessageBox[STRLEN];</span><br><span class="line">    <span class="type">char</span> Str[STRLEN];</span><br><span class="line">&#125;DATA, *PDATA;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">RemoteThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDATA pData = (PDATA)lpParam;</span><br><span class="line">    <span class="comment">// 定义API函数原型</span></span><br><span class="line">    <span class="built_in">HMODULE</span>(__stdcall * MyLoadLibrary)(LPCTSTR);</span><br><span class="line">    <span class="built_in">FARPROC</span>(__stdcall * MyGetProcAddress)(HMODULE, LPCSTR);</span><br><span class="line">    <span class="built_in">HMODULE</span>(__stdcall * MyGetModuelHandle)(LPCTSTR);</span><br><span class="line">    <span class="built_in">int</span>(__stdcall * MyMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT);</span><br><span class="line">    <span class="built_in">DWORD</span>(__stdcall * MyGetModuleFileName)(HMODULE, LPTSTR, DWORD);</span><br><span class="line">    <span class="comment">// 对各函数地址进行赋值</span></span><br><span class="line">    MyLoadLibrary = (<span class="built_in">HMODULE</span>(__stdcall*)(LPCTSTR))pData-&gt;dwLoadLibrary;</span><br><span class="line">    MyGetProcAddress = (<span class="built_in">FARPROC</span>(__stdcall*)(HMODULE, LPCSTR))pData-&gt;dwGetProcAddress;</span><br><span class="line">    MyGetModuelHandle = (<span class="built_in">HMODULE</span>(__stdcall*)(LPCTSTR))pData-&gt;dwGetModuleHandle;</span><br><span class="line">    MyGetModuleFileName = (<span class="built_in">DWORD</span>(__stdcall*)(HMODULE, LPTSTR, DWORD))pData-&gt;dwGetModuleFileName;</span><br><span class="line">    <span class="comment">// 加载user32.dll</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">MyLoadLibrary</span>((LPCTSTR)pData-&gt;User32Dll);</span><br><span class="line">    MyMessageBox = (<span class="built_in">int</span>(__stdcall*)(HWND, LPCTSTR, LPCTSTR, UINT))<span class="built_in">MyGetProcAddress</span>(hModule, pData-&gt;MessageBox);</span><br><span class="line">    <span class="type">char</span> szModuleFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">MyGetModuleFileName</span>(hModule, (LPTSTR)szModuleFileName, MAX_PATH);</span><br><span class="line">    <span class="built_in">MyMessageBox</span>(<span class="literal">NULL</span>, (LPCTSTR)pData-&gt;Str, (LPCTSTR)szModuleFileName, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">noDllInjectCode</span><span class="params">(DWORD dwPid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开进程获取进程句柄</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DATA Data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 获取kernel32.dll中相关的导出函数</span></span><br><span class="line">    Data.dwLoadLibrary = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32.dll&quot;</span>)), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    Data.dwGetProcAddress = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32.dll&quot;</span>)), <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">    Data.dwGetModuleHandle = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32.dll&quot;</span>)), <span class="string">&quot;GetModuleHandleA&quot;</span>);</span><br><span class="line">    Data.dwGetModuleFileName = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32.dll&quot;</span>)), <span class="string">&quot;GetModuleFileNameA&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要其他DLL和导出函数</span></span><br><span class="line">    <span class="built_in">lstrcpy</span>((LPSTR)Data.User32Dll, <span class="built_in">TEXT</span>(<span class="string">&quot;user32.dll&quot;</span>));</span><br><span class="line">    <span class="built_in">lstrcpy</span>((LPSTR)Data.MessageBox, <span class="built_in">TEXT</span>(<span class="string">&quot;MessageBoxA&quot;</span>));</span><br><span class="line">    <span class="built_in">lstrcpy</span>((LPSTR)Data.Str, <span class="built_in">TEXT</span>(<span class="string">&quot;Dokey Inject Code&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标进程申请内存空间</span></span><br><span class="line">    LPVOID lpData = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(Data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpData == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx1 Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据写入目标内存中</span></span><br><span class="line">    SIZE_T dwWriteLen = <span class="number">0</span>;</span><br><span class="line">    BOOL bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, lpData, &amp;Data, <span class="built_in">sizeof</span>(Data), &amp;dwWriteLen);</span><br><span class="line">    <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在目标进程申请内存用于保存代码长度</span></span><br><span class="line">    DWORD dwFunction = <span class="number">0x4000</span>;</span><br><span class="line">    LPVOID lpCode = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwFunction, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpCode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx2 Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, lpCode, &amp;RemoteThreadProc, dwFunction, &amp;dwWriteLen);</span><br><span class="line">    <span class="keyword">if</span> (bRet == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)lpCode, lpData, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">noDllInjectCode</span>(<span class="number">3076</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;远程线程注入是指一个进程在另一个进程中创建线程的技术。是一种病毒木马所青睐的注入技术。&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows" scheme="http://example.com/categories/Windows/"/>
    
    
    <category term="windows Inject" scheme="http://example.com/tags/windows-Inject/"/>
    
  </entry>
  
  <entry>
    <title>数据目录表解析</title>
    <link href="http://example.com/9180d97d.html"/>
    <id>http://example.com/9180d97d.html</id>
    <published>2023-05-09T13:40:35.000Z</published>
    <updated>2023-12-13T12:24:22.516Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>基础知识</strong></p><ul><li>基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。</li><li>虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。</li><li>相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。</li><li>文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。</li></ul><p>它们之间的关系：虚拟地址(VA) &#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA)</p></div><span id="more"></span><h2 id="数据目录表结构"><a href="#数据目录表结构" class="headerlink" title="数据目录表结构"></a>数据目录表结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;     <span class="comment">// 虚拟地址，就是数据目录表的起始位置</span></span><br><span class="line">    DWORD   Size;               <span class="comment">// 尺寸，起始地址 + 尺寸 = 结束的位置</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><h3 id="Directory-Entries"><a href="#Directory-Entries" class="headerlink" title="Directory Entries"></a>Directory Entries</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory       导出表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory       导入表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory     资源表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory    异常</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory     安全</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table  重定位表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory        调试信息</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data 版权信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory  TLS表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory   </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table 导入函数地址表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><h2 id="地址函数转换"><a href="#地址函数转换" class="headerlink" title="地址函数转换"></a>地址函数转换</h2><div class="note info"><p><strong>与PE结构有关的三种地址</strong></p><p><code>VA(虚拟地址)</code>：PE文件映射到内存后的地址<br><code>RVA(相对虚拟地址)</code>：内存地址相对于映射基地址的偏移地址<br><code>FileOffset(文件偏移地址)</code>：相对PE文件在磁盘上的文件开头的偏移地址</p><ul><li>FOA &#x3D; RVA - H</li><li>FOA &#x3D; VA - ImageBase - H</li></ul></div><hr><ol><li><p>判断RVA是否在头部<br> FOA &#x3D; RVA</p></li><li><p>判断RVA位于哪个节<br> RVA &gt;&#x3D; Section[i]-&gt;VirtualAddress<br> RVA &lt;&#x3D; Section[i]-&gt;VirtualAddress + 当前节内存对齐后的大小</p><p> FOA &#x3D; RVA - Section[i]-&gt;VirtualAddress + Section[i]-&gt;PointerToRawData</p></li></ol><h3 id="转换函数代码"><a href="#转换函数代码" class="headerlink" title="转换函数代码"></a>转换函数代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">RVAToFOA</span><span class="params">(DWORD dwRVA, <span class="type">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// dwRVA 相对虚拟函数 buffer 已加载的文件内存映像</span></span><br><span class="line">    <span class="comment">// DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">// NT 头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">// 区段</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line">    <span class="comment">// 判断是否落在头部</span></span><br><span class="line">    <span class="keyword">if</span>(dwRVA &lt; pSectionHeader[<span class="number">0</span>].VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dwRVA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断落在哪个区段</span></span><br><span class="line">        <span class="keyword">if</span>(dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt;= pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> dwRVA - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dwRVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IMAGE-IMPORT-DESCRIPTOR-导入表"><a href="#IMAGE-IMPORT-DESCRIPTOR-导入表" class="headerlink" title="_IMAGE_IMPORT_DESCRIPTOR(导入表)"></a>_IMAGE_IMPORT_DESCRIPTOR(导入表)</h2><h3 id="IMAGE-IMPORT-DESCRIPTOR结构体"><a href="#IMAGE-IMPORT-DESCRIPTOR结构体" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR结构体"></a>IMAGE_IMPORT_DESCRIPTOR结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>IMAGE_IMPORT_DESCRIPTOR</strong></p><ul><li><code>OriginalFirstThunk</code>: 该字段指向导入名称表（INT）的RVA，该RVA指向的是一个<code>IMAGE_THUNK_DATA</code>的结构体</li><li><code>TimeDateStamp</code>: 该字段可以被忽略，一般为0即可</li><li><code>ForwarderChain</code>: 该字段一般为0</li><li><code>Name</code>: 该字段指向DLL名称的RVA地址</li><li><code>FirstThunk</code>: 该字段包含导入地址表（IAT）的RVA，IAT是一个<code>IMAGE_THUNK_DATA</code>的结构体数组</li></ul></div><h3 id="IMAGE-THUNK-DATA结构体"><a href="#IMAGE-THUNK-DATA结构体" class="headerlink" title="IMAGE_THUNK_DATA结构体"></a>IMAGE_THUNK_DATA结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_THUNK_DATA32</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>IMAGE_THUNK_DATA</strong></p><ul><li><code>ForwarderString</code>: 是转向它的第一个索引的函数的名称的RVA</li><li><code>Function</code>: 代表输入函数的地址</li><li><code>Ordinal</code>: 代表该函数在导入DLL中的序号。只有当<code>IMAGE_THUNK_DATA</code>的最高位为1时才代表使用序号导入，此时低31位代表在导入DLL中该函数的序号</li><li><code>AddressOfData</code>: 指向<code>IMAGE_IMPORT_BY_NAME</code>的一个指针，它表示用函数名进行导入。当<code>IMAGE_THUNK_DATA</code>的最高位为0时代表使用函数名进行导入，此时这四个字节代表着<code>IMAGE_IMPORY_BY_NAME</code>的RVA</li></ul><hr><ol><li>每一个<code>IMAGE_THUNK_DATA</code>对应一个DLL中的导入函数。<code>IMAGE_THUNK_DATA</code>与<code>IMAGE_IMPORT_DESCRIPORT</code>类似，同样是一个以全”0”的<code>IMAGE_THUNK_DATA</code>为结束</li><li>当<code>IMAGE_THUNK_DATA</code>值的最高位为1时，表示函数以序号方式导入，这时低31位被看作一个导入序号。当其最高位为0时；表示函数以函数名称字符串的方式导入，这时DWORD的值表示一个RVA，并指向一个<code>IMAGE_IMPORT_BY_NAME</code>结构体</li></ol></div><h3 id="IMAGE-IMPORT-BY-NAME结构体"><a href="#IMAGE-IMPORT-BY-NAME结构体" class="headerlink" title="IMAGE_IMPORT_BY_NAME结构体"></a>IMAGE_IMPORT_BY_NAME结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>IMAGE_IMPORT_BY_NAME</strong></p><ul><li><code>Hint</code>: 该字段表示该函数在其导入表中的序号</li><li><code>Name</code>: 该字段表示导入函数的函数名。导入函数是一个以ASCII编码的字符串，并以NULL结尾。在<code>IMAGE_IMPORT_BY_NAME</code>中使用Name[1]来定义该字段，表示这是只有1个长度大小的字符串，但是函数名不可能只有一个字节的长度，通过越界访问来达到访问变长字符串的功能</li></ul></div><div class="note warning"><p><strong>注意</strong></p><ol><li><code>IMAGE_IMPORT_DESCRIPTOR</code>结构体中的<code>OriginalFirstThunk</code>和<code>FirstThunk</code>都指向了<code>IMAGE_THUNK_DATA</code>这个结构体，但是两者是有区别的。当文件在磁盘上时，两者指向的<code>IMAGE_THUNK_DATA</code>是相同的内容，而当文件被载入内存后，两者指向的就是不同的内容</li><li>在磁盘上时，<code>OriginalFirstThunk</code>指向的<code>IMAGE_THUNK_DATA</code>中保存的是指向函数名的RVA，称其为INT。<code>FirstThunk</code>通常指向的<code>IMAGE_THUNK_DATA</code>中保存的也是指向函数名的RVA，它们在磁盘上是没有差异的</li><li>当文件被载入内存后，<code>OriginalFirstThunk</code>指向的<code>IMAGE_THUNK_DATA</code>中保存的是指向函数名的RVA；<code>FirstThunk</code>通常指向的<code>IMAGE_THUNK_DATA</code>中由装载器填充的导入函数地址，称其为IAT。</li></ol></div><h3 id="解析导入表代码"><a href="#解析导入表代码" class="headerlink" title="解析导入表代码"></a>解析导入表代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">PrintImportTable</span><span class="params">(<span class="type">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// DOS 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">// NT 头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">// 定位导入表</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT);</span><br><span class="line">    <span class="comment">// 填充结构体</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(<span class="built_in">RVAToFOV</span>(pData.Dir.VirtualAddress, buffer) + buffer);</span><br><span class="line">    <span class="keyword">while</span>(pImport-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* szDllName = (<span class="type">char</span>*)(<span class="built_in">RVAToFOA</span>(pImport-&gt;Name, buffer) + buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DllName: %s\n&quot;</span>, szDllName);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TimeDateStamp：%08x\n&quot;</span>, pImport-&gt;TimeDateStamp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ForwarderChain：%08x\n&quot;</span>, pImport-&gt;ForwarderChain);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name Offset：%08x\n&quot;</span>, pImport-&gt;Name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FirstThunk：%08x\n&quot;</span>, pImport-&gt;FirstThunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OriginalFirstThunk：%08x\n\n&quot;</span>, pImport-&gt;OriginalFirstThunk);</span><br><span class="line"></span><br><span class="line">        PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(<span class="built_in">RVAToFOA</span>(pImport-&gt;FirstThunk, buffer) + buffer);</span><br><span class="line">        <span class="keyword">while</span>(pIAT-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">IMAGE_SNAP_BY_ORDINAL32</span>(pIAT-&gt;u1.Ordinal))</span><br><span class="line">            &#123;</span><br><span class="line">                PIMAGE_IMPORT_BY_NAME pFunctionName = (PIMAGE_IMPORT_BY_NAME)(<span class="built_in">RVAToFOA</span>(pIAT-&gt;u1.AddressOfData, buffer) + buffer);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Function Name: %s\n&quot;</span>, pFunctionName);</span><br><span class="line">            &#125;</span><br><span class="line">            pIAT++;</span><br><span class="line">        &#125;</span><br><span class="line">        pImport++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IMAGE-EXPORT-DIRECTORY-导出表"><a href="#IMAGE-EXPORT-DIRECTORY-导出表" class="headerlink" title="_IMAGE_EXPORT_DIRECTORY(导出表)"></a>_IMAGE_EXPORT_DIRECTORY(导出表)</h2><h3 id="IMAGE-EXPORT-DIRECTORY结构体"><a href="#IMAGE-EXPORT-DIRECTORY结构体" class="headerlink" title="IMAGE_EXPORT_DIRECTORY结构体"></a>IMAGE_EXPORT_DIRECTORY结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>IMAGE_EXPORT_DIRECTORY</strong></p><ul><li><code>Characteristics</code>: 保留，必须为0</li><li><code>TimeDateStamp</code>: 时间戳</li><li><code>MajorVersion</code>: 主要版本号，主要和次要版本号可由用户设置</li><li><code>MinorVersion</code>: 次要版本号</li><li><code>Name</code>: 名称RVA，包含导出文件名称的ASCII字符串地址</li><li><code>Base</code>: 此映像中导出的起始序号，指定导出地址表（AddressOfFunctions）的起始序号，通常设置为1</li><li><code>NumberOfFunctions</code>: 导出函数的个数，导出地址表（AddressOfFunctions）中的条目数</li><li><code>NumberOfNames</code>: 按名称导出的函数个数，名称表（AddressOfFunctions）中的条目数，同样也是序号表（AddressOfNameOrdinals）中的条目数</li><li><code>AddressOfFunctions</code>: 导出地址表RVA</li><li><code>AddressOfNames</code>: 导出名称表RVA</li><li><code>AddressOfNameOrdinals</code>: 序号表RVA</li></ul></div><h3 id="解析导出表"><a href="#解析导出表" class="headerlink" title="解析导出表"></a>解析导出表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintExportTable</span><span class="params">(<span class="type">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// DOS</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">// NT</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">// 定位导出表</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT);</span><br><span class="line">    <span class="comment">// 填充结构体</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(<span class="built_in">RVAToFOA</span>(pDataDir-&gt;VirtualAddress, buffer) + buffer);</span><br><span class="line">    <span class="keyword">if</span> (pExport-&gt;AddressFunctions == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前没有导出表!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* szDllName = (<span class="type">char</span>*)(<span class="built_in">RVAToFOA</span>(pExport-&gt;Name, buffer) + buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DllName: %s\n&quot;</span>, DllName);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base: %#08x\n&quot;</span>, pExport-&gt;Base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NumberOfFunctions: %#08x\n&quot;</span>, pExport-&gt;NumberOfFunctions);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NumberOfNames: %#08x\n&quot;</span>, pExport-&gt;NumberOfNames);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AddressOfFunctions: %#08x\n&quot;</span>, pExport-&gt;AddressOfFunctions);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AddressOfNames: %#08x\n&quot;</span>, pExport-&gt;AddressOfNames);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AddressOfNameOrdinals: %#08x\n&quot;</span>, pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="comment">// 函数数量</span></span><br><span class="line">    DWORD dwNumberOfFunctions = pExport-&gt;NumberOfFunctions;</span><br><span class="line">    <span class="comment">// 函数名数量</span></span><br><span class="line">    DWORD dwNumberOfNames = pExport-&gt;NumberOfNames;</span><br><span class="line">    <span class="comment">// Base</span></span><br><span class="line">    DWORD dwBase = pExport-&gt;Base;</span><br><span class="line">    <span class="comment">// 导出地址表</span></span><br><span class="line">    PDWORD pExportAddrTable = (PDWORD)(<span class="built_in">RVAToFOA</span>(pExport-&gt;AddressOfFunctions, buffer) + buffer);</span><br><span class="line">    <span class="comment">// 导出名称表</span></span><br><span class="line">    PDWORD pExportNameTable = (PDWORD)(<span class="built_in">RVAToFOA</span>(pExport-&gt;AddressOfNames, buffer) + buffer);</span><br><span class="line">    <span class="comment">// 导出序号表</span></span><br><span class="line">    PWORD pExportIdTable = (PWORD)(<span class="built_in">RVAToFOA</span>(pExport-&gt;AddressOfNameOrdinals, buffer) + buffer);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dwNumberOfFunctions; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pExportAddrTable[i] == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DWORD id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; id &lt; dwNumberOfNames; id++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pExportIdTable[i] == id) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id == dwNumberOfNames)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ID: %x Address: %#08x Name[NULL]\n&quot;</span>, i + dwBase, pExportAddrTable[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* szFunName = (<span class="type">char</span>*)(<span class="built_in">RVAToFileOffset</span>(pExportNameTable[id], buffer) + buffer);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ID: %x Address: %#08x Name[%s]\n&quot;</span>, i + dwBase, pExportAddrTable[i], szFunName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IMAGE-BASE-RELOCATION-重定位表"><a href="#IMAGE-BASE-RELOCATION-重定位表" class="headerlink" title="_IMAGE_BASE_RELOCATION(重定位表)"></a>_IMAGE_BASE_RELOCATION(重定位表)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>_IMAGE_BASE_RELOCATION</strong></p><ul><li><code>VirtualAddress</code>: 指向需要重定位地址的RVA，每个INAGE_BASE_RELOCATION只负责4kb大小分页内的重定位信息。因此结构中的VirtualAddress值为0x1000的倍数</li><li><code>SizeOfBlock</code>: imageBase结构体和TypeOffset的总和 重定位块的大小</li><li><code>TypeOffset[1]</code>: 自定义的一个字段，表示这个结构体下面会出现WORD类型的数组，该数组元素的就是硬编码在程序当中的偏移</li></ul><hr><p>自定义TypeOffset结构<br>typedef struct _TYPE<br>{<br>    WORD Offset: 12;    &#x2F;&#x2F; 大小2bit重定位的偏移<br>    WORD Type: 4;<br>} TYPE, *PTYPE;</p></div><div class="note warning"><p><strong>Windows的PE装载器进行PE重定位处理的操作原理流程</strong></p><ol><li>在应用程序当中查找硬编码位置</li><li>读取之后减去ImageBase，也就是用VA - 基址 &#x3D; RVA</li><li>加上实际加载地址得到真正的VA</li></ol><hr><p>其中最关键的就是找到硬编码的位置，而要找到硬编码的位置，首先要找到基址重定位表，该表位于.reloc区段，找到基址重定位表的正确打开方式是通过数据目录表<code>IMAGE_DATA_DIRECTORY</code>条目查找</p></div><h3 id="解析重定位表"><a href="#解析重定位表" class="headerlink" title="解析重定位表"></a>解析重定位表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintBaseRelocTable</span><span class="params">(<span class="type">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义TypeOffset结构</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TYPE</span>&#123;</span><br><span class="line">        WORD Offset: <span class="number">12</span>;</span><br><span class="line">        WORD Type: <span class="number">4</span>;</span><br><span class="line">    &#125; TYPE, *PTYPE;</span><br><span class="line">    <span class="comment">// DOS</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">// NT</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">// SECTION Header</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pSectionHeader = <span class="built_in">IMAGE_FIRSET_SECTION</span>(pNtHeader);</span><br><span class="line">    <span class="comment">// 定位重定位表</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirtory + IMAGE_DIRECTORY_ENTRY_BASERELOC);</span><br><span class="line">    <span class="comment">// 填充结构体</span></span><br><span class="line">    PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(<span class="built_in">RVAToFOA</span>(pDataDir-&gt;VirtualAddress, buffer) + buffer);</span><br><span class="line">    <span class="keyword">while</span>(pBaseReloc-&gt;SizeOfBlock != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到本0x1000个字节的起始位置</span></span><br><span class="line">        <span class="comment">// 重定位个数 = （SizeOfBlock - 8（IMAGE_BASE_RELOCATION）） / 2（每个TypeOffset是2个字节）</span></span><br><span class="line">        DWORD dwCount = (DWORD)(pBaseReloc-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line">        DWORD dwRVA = pBaseReloc-&gt;VirtualAddres;</span><br><span class="line">        PTYPE pRelocAddr = (PTYPE)(pBaseReloc + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SECTION: %#08X\n&quot;</span>, pSectionHeader-&gt;Name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RVA: %#08X\n&quot;</span>, dwRVA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ITEMS: %x H / %d D\n&quot;</span>, pBaseReloc-&gt;SizeOfBlock, pBaseReloc-&gt;SizeOfBlock);</span><br><span class="line">        <span class="comment">// 找到下一个0x1000个字节</span></span><br><span class="line">        pBaseReloc = (PIMAGE_BASE_RELOCATION)((<span class="type">char</span>*)pBaseReloc + pBaseReloc-&gt;SizeOfBlock);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dwCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PDWORD pData = (PDWORD)(<span class="built_in">RVAToFOA</span>(pRelocAddr[i].Offset + dwRVA, buffer) + buffer);</span><br><span class="line">            DWORD pDataOffset = <span class="built_in">RVAToFOA</span>(pRelocAddr[i].Offset + dwRVA, buffer);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SECTION: %#08x\n&quot;</span>, *pData);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RVA: %#08x\n&quot;</span>, pRelocAddr[i].Offset + dwRVA);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OFFSET: %#08x\n\n&quot;</span>, pDataOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IMAGE-TLS-DIRECTORY-TLS表"><a href="#IMAGE-TLS-DIRECTORY-TLS表" class="headerlink" title="_IMAGE_TLS_DIRECTORY(TLS表)"></a>_IMAGE_TLS_DIRECTORY(TLS表)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_TLS_DIRECTORY32</span> &#123;</span><br><span class="line">    DWORD   StartAddressOfRawData;</span><br><span class="line">    DWORD   EndAddressOfRawData;</span><br><span class="line">    DWORD   AddressOfIndex;             <span class="comment">// PDWORD</span></span><br><span class="line">    DWORD   AddressOfCallBacks;         <span class="comment">// PIMAGE_TLS_CALLBACK *</span></span><br><span class="line">    DWORD   SizeOfZeroFill;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure><div class="note message"><p><strong>_IMAGE_TLS_DIRECTORY32</strong></p><ul><li><code>StartAddressOfRawData</code>: TLS初始化数据起始地址</li><li><code>EndAddressOfRawData</code>: TLS初始化结束地址，两个正好定位一个范围，范围放初始化的值</li><li><code>AddressOfIndex</code>: TLS索引位置</li><li><code>AddressOfCallBacks</code>: TLS回调函数的数组指针</li><li><code>SizeOfZeroFill</code>: 填充0的个数</li><li><code>Characteristics</code>: 保留</li></ul><hr><p>TLS: 线程本地存储器，可以将数据与执行的特定线程联系起来。怎么理解？</p><ol><li>如果一个变量是全局的，那么所有线程访问的是同一份，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程中都能访问，并且值在每个线程中互不影响，这就是TLS。</li><li>线程局部存储在不同平台有不同的实现，可移植性不好。线程局部存储不难实现，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程ID不同，查到的数据自然也不同。</li></ol></div><h3 id="解析TLS表"><a href="#解析TLS表" class="headerlink" title="解析TLS表"></a>解析TLS表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTLSTable</span><span class="params">(<span class="type">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// DOS</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">// NT</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">// 定位TLS表</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.VirtualAddres + IMAGE_DIRECTORY_ENTRY_TLS);</span><br><span class="line">    <span class="comment">// 填充结构体</span></span><br><span class="line">    PIMAGE_TLS_DIRECTORY pTLS = (PIMAGE_TLS_DIRECTORY)(<span class="built_in">RVAToFOA</span>(pDataDir-&gt;VirtualAddress, buffer) + buffer);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;StartAddressOfRawData: %#08x\n&quot;</span>, pTLS-&gt;StartAddressOfRawData);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;EndAddressOfRawData: %#08x\n&quot;</span>, pTLS-&gt;EndAddressOfRawData);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;AddressOfIndex: %#08x\n&quot;</span>, pTLS-&gt;AddressOfIndex);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;AddressOfCallBacks: %#08x\n&quot;</span>, pTLS-&gt;AddressOfCallBacks);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;SizeOfZeroFill: %#08x\n&quot;</span>, pTLS-&gt;SizeOfZeroFill);</span><br><span class="line">    <span class="built_in">prinf</span>(<span class="string">&quot;Characteristics: %#08x\n&quot;</span>, pTLS-&gt;Characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IMAGE-DELAYLOAD-DESCRIPTOR-延时加载表"><a href="#IMAGE-DELAYLOAD-DESCRIPTOR-延时加载表" class="headerlink" title="_IMAGE_DELAYLOAD_DESCRIPTOR(延时加载表)"></a>_IMAGE_DELAYLOAD_DESCRIPTOR(延时加载表)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DELAYLOAD_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD AllAttributes;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            DWORD RvaBased : <span class="number">1</span>;             <span class="comment">// Delay load version 2</span></span><br><span class="line">            DWORD ReservedAttributes : <span class="number">31</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; Attributes;</span><br><span class="line"></span><br><span class="line">    DWORD DllNameRVA;                       <span class="comment">// RVA to the name of the target library (NULL-terminate ASCII string)</span></span><br><span class="line">    DWORD ModuleHandleRVA;                  <span class="comment">// RVA to the HMODULE caching location (PHMODULE)</span></span><br><span class="line">    DWORD ImportAddressTableRVA;            <span class="comment">// RVA to the start of the IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    DWORD ImportNameTableRVA;               <span class="comment">// RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData)</span></span><br><span class="line">    DWORD BoundImportAddressTableRVA;       <span class="comment">// RVA to an optional bound IAT</span></span><br><span class="line">    DWORD UnloadInformationTableRVA;        <span class="comment">// RVA to an optional unload info table</span></span><br><span class="line">    DWORD TimeDateStamp;                    <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// Otherwise, date/time of the target DLL</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;</span><br></pre></td></tr></table></figure><h3 id="解析延时加载表"><a href="#解析延时加载表" class="headerlink" title="解析延时加载表"></a>解析延时加载表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOS</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line"><span class="comment">// NT</span></span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line"><span class="comment">// 定位DelayImportTable</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDataDir = (PIMAGE_DATA_DIRECTORY)(pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);</span><br><span class="line"><span class="comment">// 填充结构体</span></span><br><span class="line">PIMAGE_DELAYLOAD_DESCRIPTOR pDelayLoad = (PIMAGE_DELAYLOAD_DESCRIPTOR)(<span class="built_in">RVAToFileOffset</span>(pDataDir-&gt;VirtualAddress, buffer) + buffer);</span><br><span class="line"><span class="type">char</span>* szDllName = (<span class="type">char</span>*)(<span class="built_in">RVAToFileOffset</span>(pDelayLoad-&gt;DllNameRVA, buffer) + buffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, szDllName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Attributes: %#08x\n&quot;</span>, pDelayLoad-&gt;Attributes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ModuleHandleRVA: %#08x\n&quot;</span>, pDelayLoad-&gt;ModuleHandleRVA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImportAddressTableRVA: %#08x\n&quot;</span>, pDelayLoad-&gt;ImportAddressTableRVA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImportNameTableRVA: %#08x\n&quot;</span>, pDelayLoad-&gt;ImportNameTableRVA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BoundImportAddressTableRVA: %#08x\n&quot;</span>, pDelayLoad-&gt;BoundImportAddressTableRVA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UnloadInformationTableRVA: %#08x\n&quot;</span>, pDelayLoad-&gt;UnloadInformationTableRVA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TimeDateStamp: %#08x\n&quot;</span>, pDelayLoad-&gt;TimeDateStamp);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;基础知识&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;基地址(ImageBase): 当PE文件通过Windows加载器载入内存后，内存中的版本称为模块，映射文件的起始地址称为模块句柄，可通过句柄访问内存中其他数据结构，这个内存起始地址称为基地址。&lt;/li&gt;&lt;li&gt;虚拟地址(VA): 在Windows系统中，PE文件被系统加载到内存后，每个程序都有自己的虚拟空间，这个虚拟空间的内存地址称为虚拟地址。&lt;/li&gt;&lt;li&gt;相对虚拟地址(RVA): 可执行文件中，有许多地方需要指定内存中的地址。例如，应用全局变量时需要指定它的地址。为了避免在PE文件中出现绝对内存地址引入了相对虚拟地址，它就是在内存中相对于PE文件载入地址的偏移量。&lt;/li&gt;&lt;li&gt;文件偏移地址(FOA): 当PE文件存储在磁盘中时，某个数据的位置相对于文件头的偏移量称为文件偏移地址(FOA)。文件偏移地址从PE文件中的第一个字节开始计数，起始值为0。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;它们之间的关系：虚拟地址(VA) &amp;#x3D; 基地址(ImageBase) + 相对虚拟地址(RVA)&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows PE" scheme="http://example.com/categories/Windows-PE/"/>
    
    
    <category term="Windows PE" scheme="http://example.com/tags/Windows-PE/"/>
    
  </entry>
  
  <entry>
    <title>Windows PE</title>
    <link href="http://example.com/bd80384e.html"/>
    <id>http://example.com/bd80384e.html</id>
    <published>2023-05-07T03:11:00.000Z</published>
    <updated>2023-12-14T13:17:06.486Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>Windows PE</strong></p><ul><li>可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件</li><li>可执行文件的格式：<ul><li>Windows 平台<br>  PE（Portable Executable）文件结构</li><li>Linux 平台<br>  ELF（Executable and Linking Format）文件结构</li></ul></li></ul></div><span id="more"></span><h2 id="PE-文件结构"><a href="#PE-文件结构" class="headerlink" title="PE 文件结构"></a>PE 文件结构</h2><h3 id="PE-文件的整体结构"><a href="#PE-文件的整体结构" class="headerlink" title="PE 文件的整体结构"></a>PE 文件的整体结构</h3><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E7%BB%93%E6%9E%84.png' data-fancybox='default' data-caption='PE 结构示例图'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E7%BB%93%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PE 结构示例图"></a><span class='image-caption'>PE 结构示例图</span></div></div><h3 id="PE-文件主要结构"><a href="#PE-文件主要结构" class="headerlink" title="PE 文件主要结构"></a>PE 文件主要结构</h3><div class="note message"><p>PE 文件结构体宽度</p></div><table><thead><tr><th>结构体</th><th>宽度(字节)</th></tr></thead><tbody><tr><td>IMAGE_DOS_HEADER</td><td>64</td></tr><tr><td>IMAGE_FILE_HEADER</td><td>20</td></tr><tr><td>INAGE_OPTIONAL_HEADER32</td><td>244</td></tr><tr><td>IMAGE_SECTION_HEADER</td><td>40</td></tr></tbody></table><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%A4%A7%E5%B0%8F.png' data-fancybox='default' data-caption='PE 文件结构大小示例图'><img fancybox itemprop="contentUrl" src="https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%A4%A7%E5%B0%8F.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/Dooookey/Photos/main/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%A4%A7%E5%B0%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PE 文件结构大小示例图"></a><span class='image-caption'>PE 文件结构大小示例图</span></div></div><h3 id="PE文件的两种状态"><a href="#PE文件的两种状态" class="headerlink" title="PE文件的两种状态"></a>PE文件的两种状态</h3><div class="note info"><p><strong>PE文件的两种状态</strong></p><ul><li>PE文件在运行前（静态，存储在磁盘上）和运行时（动态，运行在内存中）的格式是有差异的，这种差异对于我们理解PE文件是如何执行的来说很重要。</li><li>我们在之前的文件分析过程中实际上所看到的是静态的内容，其大小是要根据FileAlignment的值进行文件对齐的，但是在运行时则整体按照扩展PE头的成员SectionAlignment的值进行内存对齐，默认情况下该值为0x1000：</li></ul></div><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://i.328888.xyz/2023/05/07/iaQAbN.png' data-fancybox='default' data-caption='PE文件的两种状态'><img fancybox itemprop="contentUrl" src="https://i.328888.xyz/2023/05/07/iaQAbN.png" class="lazyload" data-srcset="https://i.328888.xyz/2023/05/07/iaQAbN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PE文件的两种状态"></a><span class='image-caption'>PE文件的两种状态</span></div></div><h2 id="DOS头结构体"><a href="#DOS头结构体" class="headerlink" title="DOS头结构体"></a>DOS头结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info"><p><strong></strong></p><ul><li><code>e_magic</code> 为DOS可执行文件标识符，占用2字节，值为<code>0x5A4D</code></li><li><code>e_lfanew</code> 保存了PE头的起始位置</li></ul></div><h2 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>_IMAGE_NT_HEADERS</strong></p><ul><li><code>Signature</code>: PE标识, 值为<code>0x00004550</code></li><li><code>FileHeader</code>: 文件头</li><li><code>OptionalHeader</code>: 扩展头</li></ul></div><h3 id="文件头（标准PE头）"><a href="#文件头（标准PE头）" class="headerlink" title="文件头（标准PE头）"></a>文件头（标准PE头）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>_IMAGE_FILE_HEADER</strong></p><ol><li><code>Machine</code>: 该字段为WORD类型，占用2字节，该字段标识可执行文件的目标CPU类型</li><li><code>NumberOfSections</code>: 该字段为WORD类型，占用2字节，该字段标识PE文件的节区个数</li><li><code>TimeDateStamp</code>: 该字段表示编译器填写的时间戳与文件属性中（创建时间、修改时间无关），这个值是自1970年1月1日以来用格林威治时间计算的秒数</li><li><code>PointerToSymbolTable</code>: 该字段很少使用，调试相关</li><li><code>NumberOfSymbols</code>: 该字段很少使用，调试相关</li><li><code>SizeOfOptionalHeader</code>: 该字段为WORD类型，占用2字节；该字段指定<code>IMAGE_OPTIONAL_HEADER</code>结构大小(32位PE文件：0xEO 64位PE文件：0xF0)</li><li><code>Characteristics</code>: 该字段为WORD，占用2字节；该字段指定文件属性</li></ol></div><h4 id="Machine-字段取值范围"><a href="#Machine-字段取值范围" class="headerlink" title="Machine 字段取值范围"></a><code>Machine</code> 字段取值范围</h4><table><thead><tr><th>宏定义</th><th>值</th><th>意义</th></tr></thead><tbody><tr><td>IMAGE_FILE_MACHINE_I386</td><td>0x014C</td><td>Intel</td></tr><tr><td>IMAGE_FILE_MACHINE_ALPHA</td><td>0x0184</td><td>DEC Alpha</td></tr><tr><td>IMAGE_FILE_MACHINE_IA64</td><td>0x200</td><td>Intel(64-bit)</td></tr><tr><td>IMAGE_FILE_MACHINE_AXP64</td><td>0x0284</td><td>DEC Alpha(64-bit)</td></tr><tr><td>IMAGE_FILE_MACHINE_AMD64</td><td>0x8664</td><td>AMD64 (K8)</td></tr></tbody></table><h4 id="Characteristics-字段取值范围"><a href="#Characteristics-字段取值范围" class="headerlink" title="Characteristics 字段取值范围"></a><code>Characteristics</code> 字段取值范围</h4><table><thead><tr><th>数据位</th><th>宏定义</th><th>值</th><th>为1时的含义</th></tr></thead><tbody><tr><td>0</td><td>IMAGE_FILE_RELOCS_STRIPPED</td><td>0x0001</td><td>文件中不存在重定位信息</td></tr><tr><td>1</td><td>IMAGE_FILE_EXECUTABLE_IMAGE</td><td>0x0002</td><td>文件是可执行的</td></tr><tr><td>2</td><td>IMAGE_FILE_LINE_NUMS_STRIPPED</td><td>0x0004</td><td>不存在行信息</td></tr><tr><td>3</td><td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td><td>0x0008</td><td>不存在符号信息</td></tr><tr><td>4</td><td>IMAGE_FILE_AGGRESIVE_WS_TRIM</td><td>0x0010</td><td>调整工作集</td></tr><tr><td>5</td><td>IMAGE_FILE_LARGE_ADDRESS_AWARE</td><td>0x0020</td><td>应用程序可处理大于2GB的地址</td></tr><tr><td>6</td><td></td><td></td><td>此标志位保留</td></tr><tr><td>7</td><td>IMAGE_FILE_BYTES_REVERSED_LO</td><td>0x0080</td><td>小尾方式</td></tr><tr><td>8</td><td>IMAGE_FILE_32BIT_MACHINE</td><td>0x0100</td><td>只在32平台运行</td></tr><tr><td>9</td><td>IMAGE_FILE_DEBUG_STRIPPED</td><td>0x0200</td><td>不包含调试信息</td></tr><tr><td>10</td><td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP</td><td>0x0400</td><td>不能从可移动盘运行</td></tr><tr><td>11</td><td>IMAGE_FILE_NET_RUN_FROM_SWAP</td><td>0x0800</td><td>不能从网络运行</td></tr><tr><td>12</td><td>IMAGE_FILE_SYSTEM</td><td>0x1000</td><td>系统文件（驱动程序），不能直接运行</td></tr><tr><td>13</td><td>IMAGE_FILE_DLL</td><td>0x2000</td><td>DLL文件</td></tr><tr><td>14</td><td>IMAGE_FILE_UP_SYSTEM_ONLY</td><td>0x4000</td><td>文件不能在多处理器计算机上运行</td></tr><tr><td>15</td><td>IMAGE_FILE_BYTES_REVERSED_HI</td><td>0x8000</td><td>大尾方式</td></tr></tbody></table><figure class="highlight plaintext"><figcaption><span>Characteristics 计算方式 C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：0102</span><br><span class="line">0000 0001 0000 0010</span><br><span class="line"></span><br><span class="line">下标是1和8位为1；表示文件是一个可执行文件，只在32平台运行</span><br></pre></td></tr></table></figure><h3 id="可选头（扩展头）"><a href="#可选头（扩展头）" class="headerlink" title="可选头（扩展头）"></a>可选头（扩展头）</h3><figure class="highlight plaintext"><figcaption><span>扩展头（32位） C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    WORD    Magic;                                  // 32位PE程序：10B 64位PE程序：20B 重要</span><br><span class="line">    BYTE    MajorLinkerVersion;                     // 链接器版本号</span><br><span class="line">    BYTE    MinorLinkerVersion;                     // 链接器版本号</span><br><span class="line">    DWORD   SizeOfCode;                             // 所有代码节的总和，文件对齐后的大小，编译器填的 没用</span><br><span class="line">    DWORD   SizeOfInitializedData;                  // 包含所有已经初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用</span><br><span class="line">    DWORD   SizeOfUninitializedData;                // 包含未初始化数据的节的总大小，文件对齐后的大小，编译器填的 没用</span><br><span class="line">    DWORD   AddressOfEntryPoint;                    // 程序入口 重要</span><br><span class="line">    DWORD   BaseOfCode;                             // 代码开始的基址，编译器填的 没用</span><br><span class="line">    DWORD   BaseOfData;                             // 数据开始的基址，编译器填的 没用</span><br><span class="line">    DWORD   ImageBase;                              // 内存镜像基址 重要</span><br><span class="line">    DWORD   SectionAlignment;                       // 内存对齐 重要</span><br><span class="line">    DWORD   FileAlignment;                          // 文件对齐 重要</span><br><span class="line">    WORD    MajorOperatingSystemVersion;            // 标识操作系统版本号 主版本号</span><br><span class="line">    WORD    MinorOperatingSystemVersion;            // 标识操作系统版本号 次版本号</span><br><span class="line">    WORD    MajorImageVersion;                      // PE文件自身的版本号</span><br><span class="line">    WORD    MinorImageVersion;                      // PE文件自身的版本号</span><br><span class="line">    WORD    MajorSubsystemVersion;                  // 运行所需子系统版本号</span><br><span class="line">    WORD    MinorSubsystemVersion;                  // 运行所需子系统版本号</span><br><span class="line">    DWORD   Win32VersionValue;                      // 子系统版本值，必须位0</span><br><span class="line">    DWORD   SizeOfImage;                            // 内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment整数倍 重要</span><br><span class="line">    DWORD   SizeOfHeaders;                          // 所有头 + 节表按照文件对齐后的大小，否则加载会出错 重要</span><br><span class="line">    DWORD   CheckSum;                               // 校验和，一些系统文件有要求用来判断文件是否被修改 重要</span><br><span class="line">    WORD    Subsystem;                              // 子系统 驱动程序（1）图形界面（2）控制台、DLL（3）</span><br><span class="line">    WORD    DllCharacteristics;                     // 文件特性 不是针对DLL文件的</span><br><span class="line">    DWORD   SizeOfStackReserve;                     // 初始化时保留的栈大小</span><br><span class="line">    DWORD   SizeOfStackCommit;                      // 初始化实际提交的大小</span><br><span class="line">    DWORD   SizeOfHeapReserve;                      // 初始化保留的堆大小</span><br><span class="line">    DWORD   SizeOfHeapCommit;                       // 初始化实际提交的大小</span><br><span class="line">    DWORD   LoaderFlags;                            // 调试相关</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;                    // 目录项目数</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><div class="note info"><p><strong></strong></p><ul><li>程序真正入口：<code>ImageBase</code> 内存镜像基址 + <code>AddressOfEntryPoint</code> 程序入口</li></ul></div><h2 id="IMAGE-SECTION-HEADER-节表"><a href="#IMAGE-SECTION-HEADER-节表" class="headerlink" title="_IMAGE_SECTION_HEADER(节表)"></a>_IMAGE_SECTION_HEADER(节表)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><h2 id="空白区域添加代码"><a href="#空白区域添加代码" class="headerlink" title="空白区域添加代码"></a>空白区域添加代码</h2><div class="note info"><p><strong></strong></p><ul><li>构造跳转地址公式<br>  要跳转的地址 - E8指令当前的地址 - 5</li></ul></div><h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><div class="note info"><p><strong>新增节的步骤</strong></p><ol><li>判断是否有足够的空间，可以添加一个节表</li><li>在节表中新增一个成员</li><li>修改PE头中节的数量</li><li>修改SizeOfImage的大小</li><li>在原有数据的最后，新增一个节的数据（内存对齐的整数倍）</li><li>修正新增节表的属性</li></ol></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;Windows PE&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可执行文件（Executable file）指的是可以由操作系统进行加载执行的文件&lt;/li&gt;&lt;li&gt;可执行文件的格式：&lt;ul&gt;&lt;li&gt;Windows 平台&lt;br&gt;  PE（Portable Executable）文件结构&lt;/li&gt;&lt;li&gt;Linux 平台&lt;br&gt;  ELF（Executable and Linking Format）文件结构&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="Windows PE" scheme="http://example.com/categories/Windows-PE/"/>
    
    
    <category term="Windows PE" scheme="http://example.com/tags/Windows-PE/"/>
    
  </entry>
  
  <entry>
    <title>原型链的应用</title>
    <link href="http://example.com/85f7c1f6.html"/>
    <id>http://example.com/85f7c1f6.html</id>
    <published>2023-04-22T02:51:25.000Z</published>
    <updated>2023-04-22T16:42:19.311Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong></strong></p><ol><li>面向对象编程思维<ul><li>提高代码的可复用率 &#x3D;&gt; 更加合理的数据关系</li></ul></li><li>隐式原型和显式原型<ul><li>对象的隐式原型和构造函数的显式原型的连接</li></ul></li><li>原型链机制核心<br> a. new: <emp>执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型</emp><br> b. <code>[[GET]]</code></li></ol></div><span id="more"></span><h2 id="Object和Function"><a href="#Object和Function" class="headerlink" title="Object和Function"></a>Object和Function</h2><div class="note info"><p><strong>关键点</strong></p><ol><li>Object.prototype.<code>__proto__</code> &#x3D; null &#x3D;&gt; 原型链的终点; 不是所有对象都是Object的实例</li><li>Function.prototype.<code>__proto__</code> &#x3D; Object.prototype &#x3D;&gt; new Object()</li><li>Object.<code>__proto__</code> &#x3D; Function.prototype &#x3D;&gt; new Function()</li><li>Function.<code>__proto__</code> &#x3D; Function.prototype &#x3D;&gt; 指向自己, 执行前通过代码注入</li></ol></div><h2 id="instanceof方法"><a href="#instanceof方法" class="headerlink" title="instanceof方法"></a>instanceof方法</h2><div class="note info"><p><strong>instanceof</strong></p><p>a instanceof Func</p><ol><li>本质：递归</li><li>作用：判断 a 是不是 Func 的一个实例 <ul><li>s1.<code>__proto__</code> &#x3D; Student.prototype -&gt; false</li><li>Student.prototype.<code>__proto__</code> &#x3D; Object.prototype -&gt; true</li></ul></li></ol></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, sex, age, major</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">major</span> = major;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;cs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;english&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己封装instanceof</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">myInstanceOf</span> = <span class="keyword">function</span>(<span class="params">obj, Func</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">myInstanceOf</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj, <span class="title class_">Func</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.getPrototypeOf() -&gt; 返回对象的隐式原型</span></span><br></pre></td></tr></table></figure><h2 id="数组和类数组"><a href="#数组和类数组" class="headerlink" title="数组和类数组"></a>数组和类数组</h2><div class="note info"><p><strong>数组和类数组的区别</strong></p><p>本质上是原型链上的区别</p></div> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类数组</span></span><br><span class="line">a = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: xxx</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">demo</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="隐式原型的修改"><a href="#隐式原型的修改" class="headerlink" title="隐式原型的修改"></a>隐式原型的修改</h2><div class="note info"><p><strong>隐式原型的修改</strong></p><ul><li>Object.getPrototypeOf(obj) -&gt; 返回参数对象的隐式原型</li><li>Object.setPrototypeOf(obj, obj) &#x2F;&#x2F; 不推荐</li><li>Object.create()   &#x2F;&#x2F; 返回一个以obj为隐式原型的值的对象<ul><li>如何得到一个没有任何属性的对象<br>  var o &#x3D; Object.create(null);</li></ul></li></ul></div><h2 id="PUT-GET"><a href="#PUT-GET" class="headerlink" title="[[PUT]]&amp;&amp;[[GET]]"></a><code>[[PUT]]</code>&amp;&amp;<code>[[GET]]</code></h2><div class="note info"><p><strong>[[PUT]]</strong></p><p>[[PUT]] -&gt; LHS 左查询</p><ol><li>判断对象中有没有属性<ul><li>如果有, 就找到并返回该地址</li></ul></li><li>如果没找到<ul><li>(1) 沿着原型链找<ul><li>A. 找到这个属性<ul><li>(a). 如果是基本类型 -&gt; 覆盖 -&gt; 在对象自身创建这个属性并返回</li><li>(b). 引用类型：<ul><li>xxx. 对引用类型的引用 -&gt; 覆盖</li><li>yyy. 对引用类型的访问 -&gt; 修改</li></ul></li></ul></li></ul></li><li>(2) 没有找到 -&gt; 直到原型链终点 -&gt; 给对象自身创建一个</li></ul></li></ol></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到该属性并且是基本类型 </span></span><br><span class="line"><span class="comment">// bar.prototype.b = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.b = 2;</span></span><br><span class="line"><span class="comment">// console.log(bar)</span></span><br><span class="line"><span class="comment">/** 返回结果: b为基本类型, 会在自身创建属性并返回, 原型链上不变</span></span><br><span class="line"><span class="comment"> * bar &#123;</span></span><br><span class="line"><span class="comment"> *  b: 2,</span></span><br><span class="line"><span class="comment"> *  [[prototype]]: Object &#123;</span></span><br><span class="line"><span class="comment"> *      b: 1</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到该属性并且是引用类型 -- 访问</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">demo</span> = &#123;</span><br><span class="line">    <span class="attr">m</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bar.demo.m = 2;</span></span><br><span class="line"><span class="comment">// console.log(Object.prototype);</span></span><br><span class="line"><span class="comment">/** 返回结果 对引用类型的访问会修改</span></span><br><span class="line"><span class="comment"> * Object &#123;</span></span><br><span class="line"><span class="comment"> *  demo: &#123;</span></span><br><span class="line"><span class="comment"> *      m: 2,</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到该属性 -- 对引用类型的引用</span></span><br><span class="line">bar.<span class="property">demo</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="comment">/** 返回结果 对引用类型的引用会覆盖</span></span><br><span class="line"><span class="comment"> * bar &#123;</span></span><br><span class="line"><span class="comment"> *  demo: 2,</span></span><br><span class="line"><span class="comment"> *  [[prototype]]: Object &#123;</span></span><br><span class="line"><span class="comment"> *      demo: &#123; m: 1 &#125;,</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">bar.<span class="property">a</span> = <span class="number">1</span> <span class="comment">// 会在对象自身创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回</span></span><br><span class="line"><span class="comment"> * bar &#123;</span></span><br><span class="line"><span class="comment"> *  a: 1,</span></span><br><span class="line"><span class="comment"> *  [[prototype]]: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="面试题-01"><a href="#面试题-01" class="headerlink" title="面试题 - 01"></a>面试题 - 01</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">3</span>;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">n</span>++;</span><br><span class="line">    <span class="comment">// this.n = this.n + 1 RHS [[GET]]</span></span><br><span class="line">    <span class="comment">// 左边this.n =&gt; LHS -&gt; [[PUT]] =&gt; 基本类型(自身创建覆盖) =&gt; A &#123; n: 4 &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">a.<span class="title function_">add1</span>();</span><br><span class="line"><span class="comment">/** 分析 通过点(.)的方式调用函数会绑定this</span></span><br><span class="line"><span class="comment"> * (1). a.add1 -&gt; 属于RHS: 读操作，获取a.add1的返回值</span></span><br><span class="line"><span class="comment"> * (2). RHS -&gt; [[GET]] -&gt; a.[[__proto__]] -&gt; A.prototype.[[__proto__]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">b.<span class="title function_">add1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">n</span>, b.<span class="property">n</span>, c.<span class="property">n</span>); <span class="comment">// 4, 4, 3</span></span><br></pre></td></tr></table></figure><h3 id="面试题-02"><a href="#面试题-02" class="headerlink" title="面试题 - 02"></a>面试题 - 02</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span> () &#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">m</span> = &#123;</span><br><span class="line">    <span class="attr">t</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">m</span> = &#123;&#125;;    <span class="comment">// 写操作 =&gt; 对引用对象的引用 =&gt; 覆盖 =&gt; d &#123; m: &#123;&#125;, prototype: Object &#123; add2: f(), m: &#123;t: 1&#125;&#125;&#125;</span></span><br><span class="line">    <span class="comment">// LHS -&gt; [[PUT]]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">d.<span class="title function_">add2</span>(); <span class="comment">// RHS =&gt; [[GET]] -&gt; d.[[__proto__]] -&gt; A.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">m</span>.<span class="property">t</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="面试题-03"><a href="#面试题-03" class="headerlink" title="面试题 - 03"></a>面试题 - 03</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;在吃饭.&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jsliang&#x27;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jsliang&#x27;</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的引用的值判断 -&gt; 判断地址</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">eat</span> === p2.<span class="property">eat</span>); <span class="comment">// false =&gt; new的时候指向不同的地址</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">run</span> === p2.<span class="property">run</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">walk</span> === p2.<span class="property">walk</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="面试题-04"><a href="#面试题-04" class="headerlink" title="面试题 - 04"></a>面试题 - 04</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">some</span> = <span class="string">&#x27;222&#x27;</span>;  <span class="comment">// 能访问到</span></span><br><span class="line">    <span class="keyword">let</span> ccc = <span class="string">&#x27;ccc&#x27;</span>;</span><br><span class="line">    foo.<span class="property">obkorou1</span>= <span class="string">&#x27;obkorou1&#x27;</span>;</span><br><span class="line">    foo.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;aaa&#x27;</span>;    <span class="comment">// 能访问到</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">koro</span> = <span class="string">&#x27;扣肉&#x27;</span>;</span><br><span class="line">foo.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="string">&#x27;test&#x27;</span> <span class="comment">// 被修改</span></span><br><span class="line"><span class="keyword">let</span> foo1 = <span class="keyword">new</span> <span class="title function_">foo</span>();</span><br><span class="line">foo.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="string">&#x27;test2&#x27;</span>;   <span class="comment">// 能访问到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1 访问到哪些属性?</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;面向对象编程思维&lt;ul&gt;&lt;li&gt;提高代码的可复用率 &amp;#x3D;&amp;gt; 更加合理的数据关系&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;隐式原型和显式原型&lt;ul&gt;&lt;li&gt;对象的隐式原型和构造函数的显式原型的连接&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;原型链机制核心&lt;br&gt; a. new: &lt;emp&gt;执行前绑定this并指向空对象, 将对象的隐式原型指向函数的显式原型&lt;/emp&gt;&lt;br&gt; b. &lt;code&gt;[[GET]]&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://example.com/bf8cf30.html"/>
    <id>http://example.com/bf8cf30.html</id>
    <published>2023-04-16T13:12:07.000Z</published>
    <updated>2023-04-22T09:17:05.792Z</updated>
    
    <content type="html"><![CDATA[<div class="note message"><p><strong>理解原型链</strong></p><ol><li>理解<code>new</code>关键字的作用机制（写）</li><li>理解[[GET]]（读）</li></ol></div><span id="more"></span><h2 id="new的执行流程"><a href="#new的执行流程" class="headerlink" title="new的执行流程"></a>new的执行流程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">foo</span>(); <span class="comment">// 第二步用代码表示：this.__proto__ = foo.prototype； 返回值：this指向的对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure><div class="note info"><p><strong>new的执行流程</strong></p><ol><li>绑定this为空对象</li><li>让空对象<code>[[Prototype]](__protot__)</code> –&gt; 函数的<code>prototype</code>属性<br>  (1) 所有对象都有<code>[[Prototype]](隐式属性 __protot__)</code> -&gt; 所有对象本质上都是new出来的<br>  (2) 所有的函数对象 -&gt; prototype</li><li>正常执行函数</li><li>如果函数返回的基本类型，返回this的值，否则返回原函数的返回值</li></ol></div><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://i.328888.xyz/2023/04/17/izUScq.png' data-fancybox='default' data-caption='new执行流程图解'><img fancybox itemprop="contentUrl" src="https://i.328888.xyz/2023/04/17/izUScq.png" class="lazyload" data-srcset="https://i.328888.xyz/2023/04/17/izUScq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="new执行流程图解"></a><span class='image-caption'>new执行流程图解</span></div></div><h2 id="GET"><a href="#GET" class="headerlink" title="[[GET]]"></a><code>[[GET]]</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">foo</span>(); </span><br><span class="line">a.<span class="property">b</span>                   <span class="comment">// 不报错返回undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>)      <span class="comment">// 访问对象属性的本质，底层帮调用</span></span><br></pre></td></tr></table></figure><div class="note info"><p><strong>[[GET]]流程</strong></p><ol><li>判断对象里面有没有</li><li>判断它的__proto__指向的对象里面有没有</li></ol></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span>  = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> F = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">a</span>)  <span class="comment">// 打印a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">a</span>)  <span class="comment">// 打印undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">a</span>)  <span class="comment">// 打印a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">b</span>)  <span class="comment">// 打印b</span></span><br></pre></td></tr></table></figure><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" href='https://i.328888.xyz/2023/04/19/i6E8WA.png' data-fancybox='default' data-caption='原型链面试题图解'><img fancybox itemprop="contentUrl" src="https://i.328888.xyz/2023/04/19/i6E8WA.png" class="lazyload" data-srcset="https://i.328888.xyz/2023/04/19/i6E8WA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="原型链面试题图解"></a><span class='image-caption'>原型链面试题图解</span></div></div><div class="note info"><p><strong></strong></p><p>原型链的终点是：Object.prototype.[[prototype]] &#x3D; null</p><ul><li>Object.prototype.<code>__proto__</code> &#x3D; null;  &#x2F;&#x2F; 不是所有对象都是Object的实例</li><li>Function.prototype._<code>_proto__</code> &#x3D; Object.prototype;  &#x2F;&#x2F; new Object()</li><li>Object.<code>__proto__</code> &#x3D; Function.prototype;  &#x2F;&#x2F; new Funtion()</li><li>Function.<code>__proto__</code> &#x3D; Function.prototype</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note message&quot;&gt;&lt;p&gt;&lt;strong&gt;理解原型链&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;理解&lt;code&gt;new&lt;/code&gt;关键字的作用机制（写）&lt;/li&gt;&lt;li&gt;理解[[GET]]（读）&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>变量</title>
    <link href="http://example.com/13ffbe88.html"/>
    <id>http://example.com/13ffbe88.html</id>
    <published>2023-04-16T02:18:20.000Z</published>
    <updated>2023-04-16T12:53:28.963Z</updated>
    
    <content type="html"><![CDATA[<div class="note todo"><p><strong></strong></p><ol><li>变量的本质</li><li>深拷贝</li><li>垃圾回收</li></ol></div><span id="more"></span><h2 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h2><div class="note bug"><p><strong>栈(stack)的特性</strong></p><ol><li>结构性强，内存连续</li><li>寻址速度快</li><li>数据稳定</li><li>容量小</li></ol></div><div class="note warning"><p><strong>原始类型</strong></p><ol><li>原始类型存于栈中</li><li>原始类型<u>不可修改</u>; 无法<u>直接修改指向内存中的值</u>, 需要新开辟一块内存</li></ol><table><thead><tr><th>类型</th><th>typeof返回值</th><th>对象包装器</th></tr></thead><tbody><tr><td>Null</td><td>“object”</td><td>N&#x2F;A</td></tr><tr><td>Undefined</td><td>“undefined”</td><td>N&#x2F;A</td></tr><tr><td>Boolean</td><td>“boolean”</td><td>Boolean</td></tr><tr><td>Number</td><td>“number”</td><td>Number</td></tr><tr><td>BigInt</td><td>“bigint”</td><td>BigInt</td></tr><tr><td>String</td><td>“string”</td><td>String</td></tr><tr><td>Symbol</td><td>“symbol”</td><td>Symbol</td></tr></tbody></table></div><hr><div class="note bug"><p><strong>堆(heap)的特性</strong></p><ol><li>类似于书架</li><li>存储以坨为单位</li><li>容量大</li><li>不同数据间内存不连续</li></ol></div><div class="note warning"><p><strong>引用类型</strong></p><ol><li>在js中引用类型指的是对象（Object）;</li></ol></div><h3 id="示例代码-01"><a href="#示例代码-01" class="headerlink" title="示例代码-01"></a>示例代码-01</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> </span><br><span class="line">    b1 = <span class="number">1</span>,</span><br><span class="line">    b2 = b1;    <span class="comment">// RHS right head-side search 右查询（本质：读了内存中存的值）</span></span><br><span class="line">b2 = b1;    <span class="comment">// 本质是在内存中指向了新的数据（2），旧数据（1）将被回收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1, b2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">    r1 = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    r2 = r1;    <span class="comment">// 程序本身只允许访问栈，无法访问堆；栈和堆通过标识符建立连接</span></span><br><span class="line"></span><br><span class="line">r2.<span class="property">a</span> = <span class="number">2</span>;   <span class="comment">// 因为r1和r2同时指向了堆中的数据，所以修改r2，r1随之改变</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">a</span>, r2.<span class="property">a</span>)</span><br></pre></td></tr></table></figure><hr><div class="note warning"><p><strong>字符串(特殊)</strong></p><p>字符串本质上是存放在堆中，但是它是一个原始类型，原始类型不能直接修改栈中的数据，而是新建了一个标识符并指向了堆中的新数据</p></div><h3 id="示例代码-02"><a href="#示例代码-02" class="headerlink" title="示例代码-02"></a>示例代码-02</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello word&#x27;</span>,</span><br><span class="line">    b = a;</span><br><span class="line">b = <span class="string">&#x27;hello&#x27;</span>;    <span class="comment">// 栈中会新建标识符指向新数据，旧数据则被回收</span></span><br><span class="line">consoel.<span class="title function_">log</span>(a, b);</span><br></pre></td></tr></table></figure><h3 id="变量总结"><a href="#变量总结" class="headerlink" title="变量总结"></a>变量总结</h3><div class="note success"><p><strong>知识总结</strong></p><ol><li>数据组织的方式不同 – 栈中的内存是连续的，堆中不是</li><li>用户权限不同 – 用户能读取栈中的数据不能读取堆中的数据</li><li>大小不同 – 栈的空间小堆的空间大</li><li>寻址速度不同 – 栈的寻址速度快而堆的寻址速度慢</li><li>作用不同 – 栈中存的是基本类型、引用类型的标识符以及字符串的标识符；堆中存放大小不确定的数据</li></ol></div><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><div class="note info"><p><strong></strong></p><p>所谓的引用传递取决于传递的是值还是地址；在javascript中本质上就是值传递（读栈<code>stack</code>内存中的值）</p></div><h3 id="示例代码-01-1"><a href="#示例代码-01-1" class="headerlink" title="示例代码-01"></a>示例代码-01</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">change1</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    arg = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change2</span>(<span class="params">arg</span>)&#123;</span><br><span class="line">    arg.<span class="property">a</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123; <span class="attr">a</span>: <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">change1</span>(foo);</span><br><span class="line"><span class="title function_">change2</span>(bar);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo, bar);</span><br></pre></td></tr></table></figure><h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝&amp;浅拷贝"></a>深拷贝&amp;浅拷贝</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">28</span>,</span><br><span class="line">    <span class="attr">hobby</span>: <span class="string">&#x27;学习&#x27;</span>,</span><br><span class="line">    <span class="attr">son</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">hobby</span>: <span class="string">&#x27;drink milk&#x27;</span>,</span><br><span class="line">        <span class="attr">friends</span>: [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clonePerson = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        clonePerson[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clonePerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="title function_">clonePerson</span>(person1);</span><br><span class="line">newPerson.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">age</span>);</span><br><span class="line">newPerson.<span class="property">son</span>.<span class="property">age</span> = <span class="number">100</span>;    <span class="comment">// 会改变，son是一个object属于引用类型存放于堆中，newPerson.son和person1.son指向同一个</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson.<span class="property">son</span>.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用递归实现深拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone2</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">clone2</span>(obj[key])</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            clone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><div class="note info"><p><strong></strong></p><ol><li>stack存储基本变量和引用类型的指向;</li><li>heap存储复杂数据和字符串;</li><li>stack会自动回收,<br>heap借助垃圾回收机制进行回收，但需要一定的手动操作;</li></ol></div><h2 id="视频地址"><a href="#视频地址" class="headerlink" title="视频地址"></a>视频地址</h2><div class="tag link"><a class="link-card" title="变量的本质&深拷贝&垃圾回收" href="https://www.bilibili.com/video/BV1Ed4y1x7oN/?p=6&spm_id_from=pageDriver&vd_source=cb73e5c2249f330a061d8900da3573a8"><div class="left"><img src="https://gcore.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></div><div class="right"><p class="text">变量的本质&深拷贝&垃圾回收</p><p class="url">https://www.bilibili.com/video/BV1Ed4y1x7oN/?p=6&spm_id_from=pageDriver&vd_source=cb73e5c2249f330a061d8900da3573a8</p></div></a></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note todo&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;变量的本质&lt;/li&gt;&lt;li&gt;深拷贝&lt;/li&gt;&lt;li&gt;垃圾回收&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise异步任务并发</title>
    <link href="http://example.com/5d76cec.html"/>
    <id>http://example.com/5d76cec.html</id>
    <published>2023-04-05T05:23:21.000Z</published>
    <updated>2023-04-16T12:54:15.168Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p><strong>背景</strong></p><p>设计一个方法doSomething来限制异步任务的最大并发数</p></div><span id="more"></span><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span> (<span class="attr">timeout</span>: <span class="built_in">number</span>, <span class="attr">taskName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;taskName&#125;</span>开始啦`</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;taskName&#125;</span>结束啦`</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">sleep</span>(<span class="number">1000</span>, <span class="string">&#x27;睡觉&#x27;</span>),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">sleep</span>(<span class="number">2000</span>, <span class="string">&#x27;吃饭&#x27;</span>),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">sleep</span>(<span class="number">3000</span>, <span class="string">&#x27;打游戏&#x27;</span>),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">sleep</span>(<span class="number">5000</span>, <span class="string">&#x27;写代码&#x27;</span>),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">sleep</span>(<span class="number">7000</span>, <span class="string">&#x27;做运动&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">tasks:(()=&gt;<span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;)[], limit=<span class="number">2</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 正在执行中的任务的集合</span></span><br><span class="line">    <span class="keyword">const</span> taskPool = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">        <span class="keyword">const</span> promise = <span class="title function_">task</span>();</span><br><span class="line">        taskPool.<span class="title function_">add</span>(promise);</span><br><span class="line">        promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> taskPool.<span class="title function_">delete</span>(promise));</span><br><span class="line">        <span class="keyword">if</span> (taskPool.<span class="property">size</span> &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(taskPool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(taskPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 如果存在同步任务情况</span></span><br><span class="line"><span class="comment">async function doSomething(tasks:(()=&gt;Promise&lt;void&gt;)[], limit=2) &#123;</span></span><br><span class="line"><span class="comment">    // 正在执行中的任务的集合</span></span><br><span class="line"><span class="comment">    const taskPool = new Set();</span></span><br><span class="line"><span class="comment">    for (const task of tasks) &#123;</span></span><br><span class="line"><span class="comment">        const promise = task();</span></span><br><span class="line"><span class="comment">        const p = Promise.resolve(promise)  // 包装Promise, 同步任务直接返回</span></span><br><span class="line"><span class="comment">        taskPool.add(p);</span></span><br><span class="line"><span class="comment">        promise.then(() =&gt; taskPool.delete(p));</span></span><br><span class="line"><span class="comment">        if (taskPool.size &gt;= limit) &#123;</span></span><br><span class="line"><span class="comment">            await Promise.race(taskPool);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return Promise.all(taskPool);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomethin</span>(tasks).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务全部执行完了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTasks</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tasks = [];</span><br><span class="line">    urls.<span class="title function_">forEach</span>(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">        tasks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">                img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                img.<span class="property">src</span> = url;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="title function_">getTasks</span>([<span class="string">&#x27;xxxx.jpg&#x27;</span>, <span class="string">&#x27;xxxx.png&#x27;</span>])).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全部执行完了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视频地址"><a href="#视频地址" class="headerlink" title="视频地址"></a>视频地址</h2><div class="tag link"><a class="link-card" title="【Promise的异步任务并发限制还不会写？还只会Promise.all ？今天一次性教会你实现思路与细节！】" href="ttps://www.bilibili.com/video/BV1i24y1L72L/?share_source=copy_web&vd_source=a11f39cbd36d0048998b780fa95bc7df"><div class="left"><img src="https://gcore.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="/></div><div class="right"><p class="text">【Promise的异步任务并发限制还不会写？还只会Promise.all ？今天一次性教会你实现思路与细节！】</p><p class="url">ttps://www.bilibili.com/video/BV1i24y1L72L/?share_source=copy_web&vd_source=a11f39cbd36d0048998b780fa95bc7df</p></div></a></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设计一个方法doSomething来限制异步任务的最大并发数&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>async/await 学习</title>
    <link href="http://example.com/ca9ee217.html"/>
    <id>http://example.com/ca9ee217.html</id>
    <published>2023-04-04T14:40:36.000Z</published>
    <updated>2023-04-04T15:26:12.522Z</updated>
    
    <content type="html"><![CDATA[<div class="note info cyan"><p><strong></strong></p><p>async 函数可能包含 0 个或者多个 <emp>await</emp> 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 <emp>async&#x2F;await</emp> 关键字就可以在异步代码中使用普通的 <emp>try&#x2F;catch</emp> 代码块。</p></div><span id="more"></span><div class="note warning"><p><strong>备注</strong></p><p><emp>await</emp>关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 <emp>SyntaxError</emp>。</p></div><div class="note warning"><p><strong>备注</strong></p><p><emp>async&#x2F;await</emp>的目的为了简化使用基于 promise 的 API 时所需的语法。<emp>async&#x2F;await</emp> 的行为就好像搭配使用了生成器和 promise。</p></div><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span> (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(url + count ++);     </span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用async/await语法糖</span></span><br><span class="line"><span class="comment">// async function run () &#123;</span></span><br><span class="line"><span class="comment">//     const res1 = await request(&#x27;1111&#x27;);</span></span><br><span class="line"><span class="comment">//     const res2 = await request(res1);</span></span><br><span class="line"><span class="comment">//     console.log(res2);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于生成器函数模拟async/await</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> <span class="title function_">request</span>(res);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用递归实现连续调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">generate</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">exec</span> (params) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = g.<span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            value.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">exec</span>(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note info cyan&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;async 函数可能包含 0 个或者多个 &lt;emp&gt;await&lt;/emp&gt; 表达式。await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。promise 的解决值会被当作该 await 表达式的返回值。使用 &lt;emp&gt;async&amp;#x2F;await&lt;/emp&gt; 关键字就可以在异步代码中使用普通的 &lt;emp&gt;try&amp;#x2F;catch&lt;/emp&gt; 代码块。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this 指向</title>
    <link href="http://example.com/6cfe1ad3.html"/>
    <id>http://example.com/6cfe1ad3.html</id>
    <published>2023-04-01T12:15:04.000Z</published>
    <updated>2023-04-03T16:09:03.414Z</updated>
    
    <content type="html"><![CDATA[<details cyan><summary> this到底指向什么？ </summary>              <div class='content'>              <div class="note message light"><p>函数在调用时，JavaScript会默认给this绑定一个值</p></div><div class="note message light"><p>this的绑定和定义的位置（编写的位置）没有关系</p></div><div class="note message light"><p>this的绑定和调用方式以及调用的位置有关系</p></div><div class="note message light"><p>this是在运行时被绑定的</p></div>              </div>            </details><span id="more"></span><hr><h2 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h2><div class="note info"><p><strong>this的绑定规则</strong></p><ul><li><p class='p gray'>绑定一：默认绑定</p></li><li><p class='p gray'>绑定二：隐式绑定</p></li><li><p class='p gray'>绑定三：显示绑定</p></li><li><p class='p gray'>绑定四：new绑定</p></li></ul></div><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><div class="note info"><p>独立的函数调用可以理解成函数没有被绑定到某个对象上进行调用</p></div><div class="note warning"><p>严格模式，独立调用的函数中的this指向的是undefined</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 普通函数被独立调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数定义在对象中，但是独立调用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.bar(); // 指向obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = obj.<span class="property">bar</span>;</span><br><span class="line"><span class="title function_">baz</span>() <span class="comment">// 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 严格模式，独立调用的函数中的this指向的是undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="title function_">test3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test3</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test1</span>();</span><br></pre></td></tr></table></figure><h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (func) &#123;</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(obj.<span class="property">bar</span>); <span class="comment">// 属于独立调用</span></span><br></pre></td></tr></table></figure><hr><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><div class="note info"><p>通过某个对象进行调用；也就是它的调用位置中，是通过某个对象发起的函数调用</p></div><div class="note warning"><p><strong>隐式绑定的前提条件</strong></p><ul><li>必须<emp>在调用的对象内部有一个对函数的引用</emp>（比如一个属性）；</li><li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li><li>正是通过这样的引用，间接的将this绑定到这个对象上；</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">bar</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">bar</span>();  <span class="comment">// 指向obj对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">  <span class="attr">obj1</span>: obj2,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> obj2.<span class="property">obj1</span>.<span class="title function_">foo</span>(); <span class="comment">// 指向obj1对象</span></span><br></pre></td></tr></table></figure><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = obj1.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">// 指向obj1对象</span></span><br></pre></td></tr></table></figure><hr><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><div class="note info"><p>不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用；可以使用显式绑定</p></div><div class="note success"><p><strong>call和apply方法</strong></p><ul><li>第一个参数是相同的，要求传入一个对象<ul><li><u>这个对象的作用就是给this准备的</u></li><li><u>在调用这个函数时，会将this绑定到这个传入的对象上</u></li></ul></li><li>后面的参数；apply为数组，call为参数列表</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (name, age, height) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo 函数被调用 &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印参数 &#x27;</span>, name, age, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ()调用</span></span><br><span class="line"><span class="comment">// foo(&#x27;why&#x27;, 18, 180);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply</span></span><br><span class="line"><span class="comment">// 第一个参数：绑定this</span></span><br><span class="line"><span class="comment">// 第二个参数：传入额外的实参，以数组的形式</span></span><br><span class="line"><span class="comment">// foo.apply(&#x27;apply&#x27;, [&#x27;kobe&#x27;, 30, 198])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="comment">// 第一个参数：绑定this</span></span><br><span class="line"><span class="comment">// 第二个参数：后续的参数以多参数的形式传递，会作为实参</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;james&#x27;</span>, <span class="number">35</span>, <span class="number">205</span>);</span><br></pre></td></tr></table></figure><h3 id="bind-的显示绑定"><a href="#bind-的显示绑定" class="headerlink" title="bind 的显示绑定"></a>bind 的显示绑定</h3><div class="note info"><p><strong></strong></p><ul><li>如果我们希望一个函数总是显式的绑定到一个对象上，可以使用 bind 方法；bind()方法创建一个新的<emp>绑定函数(bound function, BF)</emp></li><li>绑定函数是一个<emp>exotic function object(怪异函数对象，ECMAScript 2015 中的术语)</emp></li><li>在bind() 被调用时，这个新函数的this被指定为bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (name, age, height) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：调用foo时，总是绑定到obj对象身上（不希望obj对象上有函数）</span></span><br><span class="line"><span class="comment">// 1. bind函数的基本使用</span></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">// this --&gt; obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. bind函数的其他参数</span></span><br><span class="line"><span class="keyword">const</span> test = foo.<span class="title function_">bind</span>(obj, <span class="string">&#x27;kobe&#x27;</span>, <span class="number">30</span>, <span class="number">198</span>)</span><br><span class="line"><span class="title function_">test</span>() </span><br></pre></td></tr></table></figure><hr><h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><div class="note info"><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</p></div><div class="note success"><p><strong>使用new关键字调用函数执行的操作</strong></p><ol><li>创建新的空对象；</li><li>新对象会被执行prototype连接；</li><li>新对象会绑定到函数调用的this上（this绑定在这个步骤完成）；</li><li>没有显示返回非空对象时，默认返回这个对象；</li></ol></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">foo</span>();  <span class="comment">// 指向foo对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">// Person &#123;&#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;   <span class="comment">// Person &#123; name: &#x27;why&#x27; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure><hr><h2 id="内置函数的调用绑定"><a href="#内置函数的调用绑定" class="headerlink" title="内置函数的调用绑定"></a>内置函数的调用绑定</h2>]]></content>
    
    
    <summary type="html">&lt;details cyan&gt;&lt;summary&gt; this到底指向什么？ &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;函数在调用时，JavaScript会默认给this绑定一个值&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this的绑定和定义的位置（编写的位置）没有关系&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this的绑定和调用方式以及调用的位置有关系&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this是在运行时被绑定的&lt;/p&gt;&lt;/div&gt;
              &lt;/div&gt;
            &lt;/details&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>openProcess</title>
    <link href="http://example.com/59bbde9c.html"/>
    <id>http://example.com/59bbde9c.html</id>
    <published>2023-04-01T11:41:00.000Z</published>
    <updated>2023-04-07T14:08:38.858Z</updated>
    
    <content type="html"><![CDATA[<p>openProcess</p><span id="more"></span><p>openProcess 释义</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;openProcess&lt;/p&gt;</summary>
    
    
    
    <category term="Windows API" scheme="http://example.com/categories/Windows-API/"/>
    
    
    <category term="Windows API" scheme="http://example.com/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>createProcess</title>
    <link href="http://example.com/e0165a92.html"/>
    <id>http://example.com/e0165a92.html</id>
    <published>2023-04-01T11:06:25.000Z</published>
    <updated>2023-04-01T11:48:29.945Z</updated>
    
    <content type="html"><![CDATA[<p>createProcess</p><span id="more"></span><p>createProcess 释义</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;createProcess&lt;/p&gt;</summary>
    
    
    
    <category term="Windows API" scheme="http://example.com/categories/Windows-API/"/>
    
    
    <category term="Windows API" scheme="http://example.com/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocket配置</title>
    <link href="http://example.com/fc41ab04.html"/>
    <id>http://example.com/fc41ab04.html</id>
    <published>2023-04-01T07:08:18.000Z</published>
    <updated>2023-04-01T10:53:09.625Z</updated>
    
    <content type="html"><![CDATA[<p class='p center large'>记录一下shadowsocket的配置</p><p class='p center small'>为了愉快的使用Google</p><h3 id="国内-209-配置"><a href="#国内-209-配置" class="headerlink" title="国内[209]配置"></a>国内[209]配置</h3><details cyan><summary> 国内[209]配置 </summary>              <div class='content'>              <div class="note "><p><strong>server配置</strong></p><p>[common]<br>bind_port &#x3D; 7001</p></div><div class="note "><p><strong>client配置</strong></p><p>[common]<br>server_addr &#x3D; 127.0.0.1<br>server_port &#x3D; 7000</p><p>[ssh]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 22<br>remote_port &#x3D; 6000</p></div>              </div>            </details><hr><h3 id="硅谷-184-配置"><a href="#硅谷-184-配置" class="headerlink" title="硅谷[184]配置"></a>硅谷[184]配置</h3><details cyan><summary> 硅谷[184]配置 </summary>              <div class='content'>              <div class="note "><p><strong>新加坡[188]server配置</strong></p><p>[common]<br>bind_port &#x3D; 7001</p></div><div class="note "><p><strong>新加披[188]client配置</strong></p><p>[common]<br>server_addr &#x3D; 国内[209]<br>server_port &#x3D; 7001</p><p>[frp_shadow]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8890<br>remote_port &#x3D; 8889</p><p>[frp_shh]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 6002<br>remote_port &#x3D; 6667</p></div>              </div>            </details><hr><h3 id="新加坡-188-配置"><a href="#新加坡-188-配置" class="headerlink" title="新加坡[188]配置"></a>新加坡[188]配置</h3><details cyan><summary> 新加坡[188]配置 </summary>              <div class='content'>              <div class="note "><p><strong>server配置</strong></p><p>bind_port &#x3D; 7000</p></div><div class="note "><p><strong>新加坡[188]client配置</strong></p><p>[common]<br>server_addr &#x3D; [硅谷]184<br>server_port &#x3D; 7001</p><p>[frp_client_188]<br>type &#x3D; tcp<br>local_ip &#x3D; 1270.0.1<br>local_port &#x3D; 22<br>remote_port &#x3D; 6002</p><p>[shadowrocket_client_188]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8388<br>remote_port &#x3D; 8890</p></div>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;p class=&#39;p center large&#39;&gt;记录一下shadowsocket的配置&lt;/p&gt;
&lt;p class=&#39;p center small&#39;&gt;为了愉快的使用Google&lt;/p&gt;

&lt;h3 id=&quot;国内-209-配置&quot;&gt;&lt;a href=&quot;#国内-209-配置&quot; class</summary>
      
    
    
    
    <category term="网络安全" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 调度算法的评价指标</title>
    <link href="http://example.com/10785.html"/>
    <id>http://example.com/10785.html</id>
    <published>2022-08-03T15:44:00.000Z</published>
    <updated>2023-03-25T14:35:06.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统 - 调度算法的评价指标</p></blockquote><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p><img src="/images/pasted-122.png" class="lazyload" data-srcset="/images/pasted-122.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p><img src="/images/pasted-123.png" class="lazyload" data-srcset="/images/pasted-123.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><blockquote><p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔<br>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p></blockquote><ul><li>周转时间 &#x3D; 作业完成时间 - 作业提交时间</li></ul><h4 id="周转时间、平均周转时间"><a href="#周转时间、平均周转时间" class="headerlink" title="周转时间、平均周转时间"></a>周转时间、平均周转时间</h4><ul><li>平均周转时间<br><img src="/images/pasted-124.png" class="lazyload" data-srcset="/images/pasted-124.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul><h4 id="带权周转时间、平均带权周转时间"><a href="#带权周转时间、平均带权周转时间" class="headerlink" title="带权周转时间、平均带权周转时间"></a>带权周转时间、平均带权周转时间</h4><p><img src="/images/pasted-125.png" class="lazyload" data-srcset="/images/pasted-125.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><ul><li>等待时间，指进程&#x2F;作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li><li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li><li>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，前面指标类似，也有“平均等待时间”来评价整体性能。</li></ul><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><ul><li>对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应</li><li>响应时间，指从用户提交请求到首次产生响应所用地时间。</li></ul><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-126.png" class="lazyload" data-srcset="/images/pasted-126.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统 - 调度算法的评价指标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;调度算法的评价指标&quot;&gt;&lt;a href=&quot;#调度算法的评价指标&quot; class=&quot;headerlink&quot; title=&quot;调度算法的评价指标&quot;&gt;&lt;/a&gt;调度算法的评价指</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
</feed>
