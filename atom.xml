<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dokey_</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-03T16:09:03.414Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dokey_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>this 指向</title>
    <link href="http://example.com/6cfe1ad3.html"/>
    <id>http://example.com/6cfe1ad3.html</id>
    <published>2023-04-01T12:15:04.000Z</published>
    <updated>2023-04-03T16:09:03.414Z</updated>
    
    <content type="html"><![CDATA[<details cyan><summary> this到底指向什么？ </summary>              <div class='content'>              <div class="note message light"><p>函数在调用时，JavaScript会默认给this绑定一个值</p></div><div class="note message light"><p>this的绑定和定义的位置（编写的位置）没有关系</p></div><div class="note message light"><p>this的绑定和调用方式以及调用的位置有关系</p></div><div class="note message light"><p>this是在运行时被绑定的</p></div>              </div>            </details><span id="more"></span><hr><h2 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h2><div class="note info"><p><strong>this的绑定规则</strong></p><ul><li><p class='p gray'>绑定一：默认绑定</p></li><li><p class='p gray'>绑定二：隐式绑定</p></li><li><p class='p gray'>绑定三：显示绑定</p></li><li><p class='p gray'>绑定四：new绑定</p></li></ul></div><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><div class="note info"><p>独立的函数调用可以理解成函数没有被绑定到某个对象上进行调用</p></div><div class="note warning"><p>严格模式，独立调用的函数中的this指向的是undefined</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 普通函数被独立调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数定义在对象中，但是独立调用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.bar(); // 指向obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = obj.<span class="property">bar</span>;</span><br><span class="line"><span class="title function_">baz</span>() <span class="comment">// 指向window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 严格模式，独立调用的函数中的this指向的是undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="title function_">test3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test3</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test1</span>();</span><br></pre></td></tr></table></figure><h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (func) &#123;</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(obj.<span class="property">bar</span>); <span class="comment">// 属于独立调用</span></span><br></pre></td></tr></table></figure><hr><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><div class="note info"><p>通过某个对象进行调用；也就是它的调用位置中，是通过某个对象发起的函数调用</p></div><div class="note warning"><p><strong>隐式绑定的前提条件</strong></p><ul><li>必须<emp>在调用的对象内部有一个对函数的引用</emp>（比如一个属性）；</li><li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li><li>正是通过这样的引用，间接的将this绑定到这个对象上；</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">bar</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">bar</span>();  <span class="comment">// 指向obj对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">  <span class="attr">obj1</span>: obj2,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> obj2.<span class="property">obj1</span>.<span class="title function_">foo</span>(); <span class="comment">// 指向obj1对象</span></span><br></pre></td></tr></table></figure><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = obj1.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">// 指向obj1对象</span></span><br></pre></td></tr></table></figure><hr><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><div class="note info"><p>不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用；可以使用显式绑定</p></div><div class="note success"><p><strong>call和apply方法</strong></p><ul><li>第一个参数是相同的，要求传入一个对象<ul><li><u>这个对象的作用就是给this准备的</u></li><li><u>在调用这个函数时，会将this绑定到这个传入的对象上</u></li></ul></li><li>后面的参数；apply为数组，call为参数列表</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (name, age, height) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo 函数被调用 &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印参数 &#x27;</span>, name, age, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ()调用</span></span><br><span class="line"><span class="comment">// foo(&#x27;why&#x27;, 18, 180);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply</span></span><br><span class="line"><span class="comment">// 第一个参数：绑定this</span></span><br><span class="line"><span class="comment">// 第二个参数：传入额外的实参，以数组的形式</span></span><br><span class="line"><span class="comment">// foo.apply(&#x27;apply&#x27;, [&#x27;kobe&#x27;, 30, 198])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="comment">// 第一个参数：绑定this</span></span><br><span class="line"><span class="comment">// 第二个参数：后续的参数以多参数的形式传递，会作为实参</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;james&#x27;</span>, <span class="number">35</span>, <span class="number">205</span>);</span><br></pre></td></tr></table></figure><h3 id="bind-的显示绑定"><a href="#bind-的显示绑定" class="headerlink" title="bind 的显示绑定"></a>bind 的显示绑定</h3><div class="note info"><p><strong></strong></p><ul><li>如果我们希望一个函数总是显式的绑定到一个对象上，可以使用 bind 方法；bind()方法创建一个新的<emp>绑定函数(bound function, BF)</emp></li><li>绑定函数是一个<emp>exotic function object(怪异函数对象，ECMAScript 2015 中的术语)</emp></li><li>在bind() 被调用时，这个新函数的this被指定为bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用</li></ul></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (name, age, height) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：调用foo时，总是绑定到obj对象身上（不希望obj对象上有函数）</span></span><br><span class="line"><span class="comment">// 1. bind函数的基本使用</span></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">// this --&gt; obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. bind函数的其他参数</span></span><br><span class="line"><span class="keyword">const</span> test = foo.<span class="title function_">bind</span>(obj, <span class="string">&#x27;kobe&#x27;</span>, <span class="number">30</span>, <span class="number">198</span>)</span><br><span class="line"><span class="title function_">test</span>() </span><br></pre></td></tr></table></figure><hr><h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><div class="note info"><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</p></div><div class="note success"><p><strong>使用new关键字调用函数执行的操作</strong></p><ol><li>创建新的空对象；</li><li>新对象会被执行prototype连接；</li><li>新对象会绑定到函数调用的this上（this绑定在这个步骤完成）；</li><li>没有显示返回非空对象时，默认返回这个对象；</li></ol></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">foo</span>();  <span class="comment">// 指向foo对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">// Person &#123;&#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;   <span class="comment">// Person &#123; name: &#x27;why&#x27; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure><hr><h2 id="内置函数的调用绑定"><a href="#内置函数的调用绑定" class="headerlink" title="内置函数的调用绑定"></a>内置函数的调用绑定</h2>]]></content>
    
    
    <summary type="html">&lt;details cyan&gt;&lt;summary&gt; this到底指向什么？ &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;函数在调用时，JavaScript会默认给this绑定一个值&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this的绑定和定义的位置（编写的位置）没有关系&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this的绑定和调用方式以及调用的位置有关系&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note message light&quot;&gt;&lt;p&gt;this是在运行时被绑定的&lt;/p&gt;&lt;/div&gt;
              &lt;/div&gt;
            &lt;/details&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>openProcess</title>
    <link href="http://example.com/59bbde9c.html"/>
    <id>http://example.com/59bbde9c.html</id>
    <published>2023-04-01T11:41:00.000Z</published>
    <updated>2023-04-01T11:48:03.499Z</updated>
    
    <content type="html"><![CDATA[<p>openProcess</p><span id="more"></span><p>openProcess 释义</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;openProcess&lt;/p&gt;</summary>
    
    
    
    <category term="Windows API" scheme="http://example.com/categories/Windows-API/"/>
    
    
    <category term="Windows API" scheme="http://example.com/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>createProcess</title>
    <link href="http://example.com/e0165a92.html"/>
    <id>http://example.com/e0165a92.html</id>
    <published>2023-04-01T11:06:25.000Z</published>
    <updated>2023-04-01T11:48:29.945Z</updated>
    
    <content type="html"><![CDATA[<p>createProcess</p><span id="more"></span><p>createProcess 释义</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;createProcess&lt;/p&gt;</summary>
    
    
    
    <category term="Windows API" scheme="http://example.com/categories/Windows-API/"/>
    
    
    <category term="Windows API" scheme="http://example.com/tags/Windows-API/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocket配置</title>
    <link href="http://example.com/fc41ab04.html"/>
    <id>http://example.com/fc41ab04.html</id>
    <published>2023-04-01T07:08:18.000Z</published>
    <updated>2023-04-01T10:53:09.625Z</updated>
    
    <content type="html"><![CDATA[<p class='p center large'>记录一下shadowsocket的配置</p><p class='p center small'>为了愉快的使用Google</p><h3 id="国内-209-配置"><a href="#国内-209-配置" class="headerlink" title="国内[209]配置"></a>国内[209]配置</h3><details cyan><summary> 国内[209]配置 </summary>              <div class='content'>              <div class="note "><p><strong>server配置</strong></p><p>[common]<br>bind_port &#x3D; 7001</p></div><div class="note "><p><strong>client配置</strong></p><p>[common]<br>server_addr &#x3D; 127.0.0.1<br>server_port &#x3D; 7000</p><p>[ssh]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 22<br>remote_port &#x3D; 6000</p></div>              </div>            </details><hr><h3 id="硅谷-184-配置"><a href="#硅谷-184-配置" class="headerlink" title="硅谷[184]配置"></a>硅谷[184]配置</h3><details cyan><summary> 硅谷[184]配置 </summary>              <div class='content'>              <div class="note "><p><strong>新加坡[188]server配置</strong></p><p>[common]<br>bind_port &#x3D; 7001</p></div><div class="note "><p><strong>新加披[188]client配置</strong></p><p>[common]<br>server_addr &#x3D; 国内[209]<br>server_port &#x3D; 7001</p><p>[frp_shadow]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8890<br>remote_port &#x3D; 8889</p><p>[frp_shh]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 6002<br>remote_port &#x3D; 6667</p></div>              </div>            </details><hr><h3 id="新加坡-188-配置"><a href="#新加坡-188-配置" class="headerlink" title="新加坡[188]配置"></a>新加坡[188]配置</h3><details cyan><summary> 新加坡[188]配置 </summary>              <div class='content'>              <div class="note "><p><strong>server配置</strong></p><p>bind_port &#x3D; 7000</p></div><div class="note "><p><strong>新加坡[188]client配置</strong></p><p>[common]<br>server_addr &#x3D; [硅谷]184<br>server_port &#x3D; 7001</p><p>[frp_client_188]<br>type &#x3D; tcp<br>local_ip &#x3D; 1270.0.1<br>local_port &#x3D; 22<br>remote_port &#x3D; 6002</p><p>[shadowrocket_client_188]<br>type &#x3D; tcp<br>local_ip &#x3D; 127.0.0.1<br>local_port &#x3D; 8388<br>remote_port &#x3D; 8890</p></div>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;p class=&#39;p center large&#39;&gt;记录一下shadowsocket的配置&lt;/p&gt;
&lt;p class=&#39;p center small&#39;&gt;为了愉快的使用Google&lt;/p&gt;

&lt;h3 id=&quot;国内-209-配置&quot;&gt;&lt;a href=&quot;#国内-209-配置&quot; class</summary>
      
    
    
    
    <category term="网络安全" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 调度算法的评价指标</title>
    <link href="http://example.com/10785.html"/>
    <id>http://example.com/10785.html</id>
    <published>2022-08-03T15:44:00.000Z</published>
    <updated>2023-03-25T14:35:06.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统 - 调度算法的评价指标</p></blockquote><h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p><img src="/images/pasted-122.png" class="lazyload" data-srcset="/images/pasted-122.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p><img src="/images/pasted-123.png" class="lazyload" data-srcset="/images/pasted-123.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><blockquote><p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔<br>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p></blockquote><ul><li>周转时间 &#x3D; 作业完成时间 - 作业提交时间</li></ul><h4 id="周转时间、平均周转时间"><a href="#周转时间、平均周转时间" class="headerlink" title="周转时间、平均周转时间"></a>周转时间、平均周转时间</h4><ul><li>平均周转时间<br><img src="/images/pasted-124.png" class="lazyload" data-srcset="/images/pasted-124.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul><h4 id="带权周转时间、平均带权周转时间"><a href="#带权周转时间、平均带权周转时间" class="headerlink" title="带权周转时间、平均带权周转时间"></a>带权周转时间、平均带权周转时间</h4><p><img src="/images/pasted-125.png" class="lazyload" data-srcset="/images/pasted-125.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><ul><li>等待时间，指进程&#x2F;作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</li><li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li><li>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，前面指标类似，也有“平均等待时间”来评价整体性能。</li></ul><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><ul><li>对于计算机用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应</li><li>响应时间，指从用户提交请求到首次产生响应所用地时间。</li></ul><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-126.png" class="lazyload" data-srcset="/images/pasted-126.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统 - 调度算法的评价指标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;调度算法的评价指标&quot;&gt;&lt;a href=&quot;#调度算法的评价指标&quot; class=&quot;headerlink&quot; title=&quot;调度算法的评价指标&quot;&gt;&lt;/a&gt;调度算法的评价指</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 线程概念多线程模型</title>
    <link href="http://example.com/54937.html"/>
    <id>http://example.com/54937.html</id>
    <published>2022-08-01T15:44:00.000Z</published>
    <updated>2023-03-25T14:35:06.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统 - 线程概念多线程模型</p></blockquote><h2 id="线程概念多线程模型"><a href="#线程概念多线程模型" class="headerlink" title="线程概念多线程模型"></a>线程概念多线程模型</h2><h3 id="什么是线程，为什么要引入线程"><a href="#什么是线程，为什么要引入线程" class="headerlink" title="什么是线程，为什么要引入线程"></a>什么是线程，为什么要引入线程</h3><ul><li>可以把线程理解为“轻量级进程”</li><li>线程是一个<strong>基本的CPU执行单元</strong>， 也是程序执行流的最小单位</li><li>引入线程之后不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</li><li>引入线程之后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</li></ul><h3 id="引入线程机制后，有什么变化"><a href="#引入线程机制后，有什么变化" class="headerlink" title="引入线程机制后，有什么变化"></a>引入线程机制后，有什么变化</h3><h4 id="资源分配、调度"><a href="#资源分配、调度" class="headerlink" title="资源分配、调度"></a>资源分配、调度</h4><ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul><h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后，并发所带来的系统开销减小</li></ul><h3 id="线程有哪些重要的属性"><a href="#线程有哪些重要的属性" class="headerlink" title="线程有哪些重要的属性"></a>线程有哪些重要的属性</h3><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种状态</li><li>线程几乎并拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预</li><li>同一进程中线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><pre><code>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n &gt; m）</code></pre><p><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机？</strong></p><h4 id="用户级线程（User-Level-Thread-ULT）"><a href="#用户级线程（User-Level-Thread-ULT）" class="headerlink" title="用户级线程（User-Level Thread, ULT）"></a>用户级线程（User-Level Thread, ULT）</h4><ul><li>用户级线程由应用程序通过线程库实现。所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来是有多个线程，但是在操作系统内核看来，是意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）</li><li><strong>“用户级线程”</strong>就是<strong>“从用户视角能看到的线程”</strong></li></ul><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><ul><li>内核级线程的管理工作由操作系统内核完成。线程的调度、切换工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li><strong>“内核级线程”</strong>就是<strong>“从操作系统内核视角看能看到的线程”</strong></li></ul><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><blockquote><p>多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程</p></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><pre><code>用户级线程的切换在用户空间即可完成，不需要切换至核心态，线程管理的系统开销小，效率高</code></pre><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><pre><code>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</code></pre><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><blockquote><p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程</p></blockquote><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><pre><code>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</code></pre><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大。</p><h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><blockquote><p>n用户及线程映射到m个内核级线程（n &gt;&#x3D; m）。每个用户进程对应m个内核级线程</p></blockquote><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><pre><code>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</code></pre><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-116.png" class="lazyload" data-srcset="/images/pasted-116.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>1.当一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序。<br>2.在多道程序系统中，进程的数量往往是多余处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度</strong>，就是从就绪队列中按照一定地算法选择一个进程并将处理机分配给它运行，以实现进程地并发执行。</p></blockquote><h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h3><h4 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h4><ol><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序</li><li><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并<strong>建立相应进程（建立PCB）</strong>，以使它（们）<strong>获得竞争处理机的权利</strong>。</li><li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB</strong>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li></ol><h4 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h4><ol><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</li><li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>，值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。</li><li>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调出内存，因此中级调度发生的频率要比高级调度更高。</li></ol><h4 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h4><ol><li>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。，</li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</li></ol><h3 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h3><p><img src="/images/pasted-118.png" class="lazyload" data-srcset="/images/pasted-118.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="进程的“挂起态”"><a href="#进程的“挂起态”" class="headerlink" title="进程的“挂起态”"></a>进程的“挂起态”</h4><ul><li>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）</li><li>挂起态又可以进一步细分为就绪挂起、阻塞挂起两中状态</li></ul><h4 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h4><p><img src="/images/pasted-117.png" class="lazyload" data-srcset="/images/pasted-117.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="知识回顾-1"><a href="#知识回顾-1" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-119.png" class="lazyload" data-srcset="/images/pasted-119.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="进程调度的时机切换与过程调度方式"><a href="#进程调度的时机切换与过程调度方式" class="headerlink" title="进程调度的时机切换与过程调度方式"></a>进程调度的时机切换与过程调度方式</h2><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p><img src="/images/pasted-120.png" class="lazyload" data-srcset="/images/pasted-120.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h4 id="什么时候需要进程调度"><a href="#什么时候需要进程调度" class="headerlink" title="什么时候需要进程调度"></a>什么时候需要进程调度</h4><h5 id="当前运行的进程主动放弃处理机"><a href="#当前运行的进程主动放弃处理机" class="headerlink" title="当前运行的进程主动放弃处理机"></a>当前运行的进程主动放弃处理机</h5><ol><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如 等待I&#x2F;O）</li></ol><h5 id="当前运行的进程被动放弃处理机"><a href="#当前运行的进程被动放弃处理机" class="headerlink" title="当前运行的进程被动放弃处理机"></a>当前运行的进程被动放弃处理机</h5><ol><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如I&#x2F;O中断）</li><li>有更高优先级的进程进入就绪队列</li></ol><h4 id="什么时候不能进行进程调度"><a href="#什么时候不能进行进程调度" class="headerlink" title="什么时候不能进行进程调度"></a>什么时候不能进行进程调度</h4><ol><li>在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在操作系统内核程序临界区中</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如 修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol><h3 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h3><h4 id="“狭义的调度”与“切换”的区别"><a href="#“狭义的调度”与“切换”的区别" class="headerlink" title="“狭义的调度”与“切换”的区别"></a>“狭义的调度”与“切换”的区别</h4><ul><li><p><strong>狭义的进程调度</strong>指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p></li><li><p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。</p></li><li><p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p></li><li><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存</li><li>对新进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ol></li><li><p><strong>注意：</strong>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，是系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p></li></ul><h4 id="进程切换的过程需要做什么"><a href="#进程切换的过程需要做什么" class="headerlink" title="进程切换的过程需要做什么"></a>进程切换的过程需要做什么</h4><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><h4 id="非剥夺调度式（非抢占式）"><a href="#非剥夺调度式（非抢占式）" class="headerlink" title="非剥夺调度式（非抢占式）"></a>非剥夺调度式（非抢占式）</h4><ul><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul><h4 id="剥夺调度方式（抢占式）"><a href="#剥夺调度方式（抢占式）" class="headerlink" title="剥夺调度方式（抢占式）"></a>剥夺调度方式（抢占式）</h4><ul><li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的过程，将处理机分配给更重要紧迫的那个进程。</li><li>可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</li></ul><h3 id="知识回顾-2"><a href="#知识回顾-2" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-121.png" class="lazyload" data-srcset="/images/pasted-121.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统 - 线程概念多线程模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程概念多线程模型&quot;&gt;&lt;a href=&quot;#线程概念多线程模型&quot; class=&quot;headerlink&quot; title=&quot;线程概念多线程模型&quot;&gt;&lt;/a&gt;线程概念多线程模</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 进程的状态与转换</title>
    <link href="http://example.com/60210.html"/>
    <id>http://example.com/60210.html</id>
    <published>2022-07-31T13:29:00.000Z</published>
    <updated>2023-03-25T14:35:06.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统的状态与转换</p></blockquote><h2 id="操作系统的状态与转换"><a href="#操作系统的状态与转换" class="headerlink" title="操作系统的状态与转换"></a>操作系统的状态与转换</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><blockquote><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态</p></blockquote><h4 id="运行态（Running）"><a href="#运行态（Running）" class="headerlink" title="运行态（Running）"></a>运行态（Running）</h4><blockquote><p>单核处理机环境下，每一个时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态）</p></blockquote><ul><li>占有CPU，并在CPU上运行</li></ul><h4 id="就绪态（Ready）"><a href="#就绪态（Ready）" class="headerlink" title="就绪态（Ready）"></a>就绪态（Ready）</h4><blockquote><p>进程已经拥有了除处理机之外所有需要地资源，一旦获得处理机，即可立即进入运行态开始运行</p></blockquote><ul><li>已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li></ul><h4 id="阻塞态（Waiting-x2F-Blocked，又称：等待态）"><a href="#阻塞态（Waiting-x2F-Blocked，又称：等待态）" class="headerlink" title="阻塞态（Waiting&#x2F;Blocked，又称：等待态）"></a>阻塞态（Waiting&#x2F;Blocked，又称：等待态）</h4><blockquote><p>等待操作系统分配打印机、等待读磁盘操作地结果。CPU是计算机中最昂贵地部件，为了提高CPU地利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p></blockquote><ul><li>因等待某一事件而暂时不能运行</li></ul><h4 id="创建态（New，又称：新建态）"><a href="#创建态（New，又称：新建态）" class="headerlink" title="创建态（New，又称：新建态）"></a>创建态（New，又称：新建态）</h4><blockquote><p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB</p></blockquote><ul><li>进程正在被创建，操作系统为进程分配资源、初始化PCB</li></ul><h4 id="终止态（Terminated，又称：结束态）"><a href="#终止态（Terminated，又称：结束态）" class="headerlink" title="终止态（Terminated，又称：结束态）"></a>终止态（Terminated，又称：结束态）</h4><blockquote><p>进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p></blockquote><ul><li>进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li></ul><h3 id="进程状态间的转换"><a href="#进程状态间的转换" class="headerlink" title="进程状态间的转换"></a>进程状态间的转换</h3><h4 id="就绪态-x3D-gt-运行态"><a href="#就绪态-x3D-gt-运行态" class="headerlink" title="就绪态 &#x3D;&gt; 运行态"></a>就绪态 &#x3D;&gt; 运行态</h4><ul><li>拥有除处理机外的所有需要的资源</li><li>进程被调度</li></ul><h4 id="运行态-x3D-gt-就绪态"><a href="#运行态-x3D-gt-就绪态" class="headerlink" title="运行态 &#x3D;&gt; 就绪态"></a>运行态 &#x3D;&gt; 就绪态</h4><ul><li>时间片到或处理机被抢占</li></ul><h4 id="运行态-x3D-gt-阻塞态"><a href="#运行态-x3D-gt-阻塞态" class="headerlink" title="运行态 &#x3D;&gt; 阻塞态"></a>运行态 &#x3D;&gt; 阻塞态</h4><ul><li>进程用“系统调用”的方式申请某种系统资源，或者请求等待某个事件发生</li><li>是一种进程自身做出的<strong>主动行为</strong></li></ul><h4 id="阻塞态-x3D-gt-就绪态"><a href="#阻塞态-x3D-gt-就绪态" class="headerlink" title="阻塞态 &#x3D;&gt; 就绪态"></a>阻塞态 &#x3D;&gt; 就绪态</h4><ul><li>申请的资源被分配，或等待的事件发生</li><li>不是进程自身能控制的，是一种<strong>被动行为</strong></li></ul><blockquote><p><strong>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p></blockquote><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-112.png" class="lazyload" data-srcset="/images/pasted-112.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是进程控制"><a href="#什么是进程控制" class="headerlink" title="什么是进程控制"></a>什么是进程控制</h4><blockquote><p>进程控制就是要实现进程状态的转换</p></blockquote><ul><li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</li></ul><h4 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h4><p><img src="/images/pasted-113.png" class="lazyload" data-srcset="/images/pasted-113.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h3><blockquote><ul><li>用原语实现进程控制。原语的特点是执行期间<strong>不允许中断</strong>，只能一气呵成。这种不可被中断的操作即<strong>原子操作</strong>。原语采用“关中断指令”和“开中断指令”实现。</li><li>关&#x2F;开中断指令的权限非常大，必然是只允许在<strong>核心态</strong>下执行的<strong>特权指令</strong></li></ul></blockquote><p><strong>进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</strong></p><ol><li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<br> a. 所有的进程控制原语一定都会修改进程状态标志<br> b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br> c.某进程开始运行前必然要恢复其运行环境</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配&#x2F;回收资源</p></li></ol><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><h5 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h5><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul><h5 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h5><ul><li><p>用户登录</p><ul><li>分时系统中，用户登录成功，系统会为其建立一个新进程</li></ul></li><li><p>作业调度</p><ul><li>多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li></ul></li><li><p>提供服务</p><ul><li>用户向操作系统提出某些请求时，会建立一个进程处理该请求</li></ul></li><li><p>应用请求</p><ul><li>由用户进程主动请求创建一个子进程</li></ul></li></ul><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><h5 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h5><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul><h5 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h5><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><h5 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h5><ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul><h5 id="引起进程阻塞的事件"><a href="#引起进程阻塞的事件" class="headerlink" title="引起进程阻塞的事件"></a>引起进程阻塞的事件</h5><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><h4 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h4><h5 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h5><ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置状态为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul><h5 id="引起进程唤醒的事件"><a href="#引起进程唤醒的事件" class="headerlink" title="引起进程唤醒的事件"></a>引起进程唤醒的事件</h5><ul><li>等待的事件发生</li></ul><h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><h5 id="切换原语"><a href="#切换原语" class="headerlink" title="切换原语"></a>切换原语</h5><ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul><h5 id="引起进程切换的事件"><a href="#引起进程切换的事件" class="headerlink" title="引起进程切换的事件"></a>引起进程切换的事件</h5><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="知识回顾-1"><a href="#知识回顾-1" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-114.png" class="lazyload" data-srcset="/images/pasted-114.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote><p>进程通信就是指进程之间信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相对独立<br>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong></p></blockquote><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><blockquote><p>两个进程对共享空间的访问必须是互斥的<br>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p></blockquote><h4 id="基于数据结构的共享"><a href="#基于数据结构的共享" class="headerlink" title="基于数据结构的共享"></a>基于数据结构的共享</h4><ul><li>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式</li></ul><h4 id="基于存储区的共享"><a href="#基于存储区的共享" class="headerlink" title="基于存储区的共享"></a>基于存储区的共享</h4><ul><li>在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><blockquote><p>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的“发送消息&#x2F;接受消息”两个原语进行数据交换<br>传递结构化的消息（消息头&#x2F;消息体）；消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p></blockquote><h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><ul><li>消息直接挂到接收进程的消息缓冲队列中</li></ul><h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><ul><li>消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。</li></ul><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><blockquote><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。就是在内存中开辟一个大小固定的缓冲区</p></blockquote><ol><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则需要设置两个管道。</li><li>各进程要互斥的访问管道</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的writer()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会读错数据的情况。</li></ol><h3 id="知识回顾-2"><a href="#知识回顾-2" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-115.png" class="lazyload" data-srcset="/images/pasted-115.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统的状态与转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;操作系统的状态与转换&quot;&gt;&lt;a href=&quot;#操作系统的状态与转换&quot; class=&quot;headerlink&quot; title=&quot;操作系统的状态与转换&quot;&gt;&lt;/a&gt;操作系统的状态与转换&lt;</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 中断和异常</title>
    <link href="http://example.com/4461.html"/>
    <id>http://example.com/4461.html</id>
    <published>2022-07-20T16:11:00.000Z</published>
    <updated>2023-03-25T14:35:06.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统的中断和异常</p></blockquote><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h3><blockquote><p>本质：发生中断就意味着需要操作系统介入，开展管理工作</p></blockquote><h3 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a>中断的概念和作用</h3><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><ul><li><p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态。使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p></li><li><p>用户态、核心态之间的切换是怎么实现的？</p><ul><li>“用户态 &#x3D;&gt; 核心态”是通过中断实现的，并且中断是唯一途径</li><li>“核心态 &#x3D;&gt; 用户态”的切换时通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</li></ul></li></ul><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><ul><li>区别<ul><li>内中断信号来源：CPU内部与当前执行的指令有关</li><li>外中断信号来源：CPU外部与当前执行的指令无关</li></ul></li></ul><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><blockquote><p>也称异常、例外、陷入</p></blockquote><ul><li>自愿中断 – 指令中断（系统调用）</li><li>强迫中断<ul><li>硬件故障（缺页）</li><li>软件中断（如：整数除0）</li></ul></li></ul><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><ul><li>外设请求</li><li>人工干预</li></ul><h4 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h4><p><img src="/images/pasted-107.png" class="lazyload" data-srcset="/images/pasted-107.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h3><ol><li>每条指令执行结束后，CPU检查是否有外部中断信号</li><li>若有外部中断信号，则需要保护被中断进程的CPU环境</li><li>根据中断信号类型转入相应中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-108.png" class="lazyload" data-srcset="/images/pasted-108.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote></blockquote><h3 id="系统调用的概念"><a href="#系统调用的概念" class="headerlink" title="系统调用的概念"></a>系统调用的概念</h3><blockquote><p>“系统调用” 是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p></blockquote><ul><li>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;O操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</li></ul><h4 id="系统调用（按功能分类）"><a href="#系统调用（按功能分类）" class="headerlink" title="系统调用（按功能分类）"></a>系统调用（按功能分类）</h4><blockquote><p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行</p></blockquote><pre><code>1. 设备管理：完成设备的 请求/释放/启动 等功能2. 文件管理：完成文件的读/写/创建/删除 等功能3. 进程控制：完成进程的 创建/撤销/阻塞/唤醒/ 等功能4. 进程通信：完成进程之间的 消息传递/信号传递 等功能5. 内存管理：完成内存的分配/回收 等功能</code></pre><h3 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h3><p><img src="/images/pasted-109.png" class="lazyload" data-srcset="/images/pasted-109.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="知识回顾-1"><a href="#知识回顾-1" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-110.png" class="lazyload" data-srcset="/images/pasted-110.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="进程的定义、组成、组织方式、特征"><a href="#进程的定义、组成、组织方式、特征" class="headerlink" title="进程的定义、组成、组织方式、特征"></a>进程的定义、组成、组织方式、特征</h2><blockquote></blockquote><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><blockquote><p>为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念</p></blockquote><ul><li>系统为每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如进程代码存放位置）</li><li>PCB、程序段、数据段三部分构成了进程实体（进程映像）。一般情况下，我们把进程实体简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB</li><li>PCB是进程存在的唯一标志</li></ul><h4 id="从不同的角度，进程可以有不同的定义，比较传统典型的定义有："><a href="#从不同的角度，进程可以有不同的定义，比较传统典型的定义有：" class="headerlink" title="从不同的角度，进程可以有不同的定义，比较传统典型的定义有："></a>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：</h4><ol><li>进程是程序的一次<strong>执行过程</strong>。</li><li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li><li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>（强调“动态性”），它是系统进行资源分配和调度的一个独立单位</li></ol><ul><li>引入进程实体的概念后，可把进程定义为：<br>  <strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</li></ul><p><strong>注：严格来说，进程实体和进程并不一样，进程实体是</strong>静态的<strong>，进程则是</strong>动态的<strong>，除非题目专门考察二者的区别，否则可以认为进程实体就是进程。</strong></p><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><blockquote><p>进程（进程实体）由程序段、数据段、PCB三部分组成</p></blockquote><ul><li>程序代码存放在程序段</li><li>程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量存放在数据段内</li><li>操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息。</li></ul><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><blockquote><p>进程的管理者（操作系统）所需的数据都在PCB中</p></blockquote><h5 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h5><ul><li><p>进程标识符PID</p><blockquote><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。</p></blockquote></li><li><p>用户标识符UID</p></li></ul><h5 id="进程控制和管理信息"><a href="#进程控制和管理信息" class="headerlink" title="进程控制和管理信息"></a>进程控制和管理信息</h5><ul><li>进程当前状态</li><li>进程优先级</li></ul><h5 id="资源分配清单"><a href="#资源分配清单" class="headerlink" title="资源分配清单"></a>资源分配清单</h5><ul><li>程序段指针</li><li>数据段指针</li><li>键盘</li><li>鼠标</li></ul><h5 id="处理机相关信息"><a href="#处理机相关信息" class="headerlink" title="处理机相关信息"></a>处理机相关信息</h5><ul><li>各种寄存器指<blockquote><p>当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句。</p></blockquote></li></ul><h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><ul><li>执行指针：指向当前处于运行态（执行态）的进程</li><li>就绪队列指针：指向当前处于就绪态的进程</li><li>阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列</li></ul><h4 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h4><ol><li>按照进程状态将PCB发为多个队列</li><li>操作系统持有指向各个队列的指针</li></ol><h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h4><ol><li>根据进程状态的不同，建立几张索引表</li><li>操作系统持有指向各个索引表的指针</li></ol><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><h4 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h4><ul><li>进程是程序的一次执行过程，是动态地产生、变化、消亡的</li></ul><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><ul><li>内存中有多个进程实体，各进程可并发执行</li></ul><h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><ul><li>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li></ul><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><ul><li>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li><li>异步性会导致并发程序执行结果的不确定性</li></ul><h4 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h4><ul><li>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ul><h3 id="知识回顾-2"><a href="#知识回顾-2" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-111.png" class="lazyload" data-srcset="/images/pasted-111.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统的中断和异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;中断和异常&quot;&gt;&lt;a href=&quot;#中断和异常&quot; class=&quot;headerlink&quot; title=&quot;中断和异常&quot;&gt;&lt;/a&gt;中断和异常&lt;/h2&gt;&lt;h3 id=&quot;中断机制的诞生&quot;</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 操作系统的特征</title>
    <link href="http://example.com/51415.html"/>
    <id>http://example.com/51415.html</id>
    <published>2022-07-19T15:47:00.000Z</published>
    <updated>2023-03-25T14:35:06.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统的四个特征</p></blockquote><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><blockquote><p>并发和共享是两个最基本的特征，二者互为存在条件</p></blockquote><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的</li><li>并行：指两个或多个事件在同一时刻同时发生</li><li>操作系统的并发性：指计算机系统中同时存在着多个运行着的程序</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li><li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><ul><li>没有并发性虚拟性就无意义</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的</li><li>空分复用技术（虚拟存储技术）</li><li>时分复用技术（虚拟处理器）</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</li></ul><hr><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><ul><li>主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低</li></ul><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3><ul><li><p>单道批处理系统：引入脱机输入&#x2F;输出技术（用磁带完成），并监督程序负责控制作业的输入、输出</p><ul><li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序，CPU有大量的时间是在等待I&#x2F;O完成。资源利用率依然很低</li></ul></li><li><p>多道批处理系统（操作系统开始出现）</p><ul><li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</li><li>主要缺点：用户响应时间过长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul></li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><blockquote><p>计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互</p></blockquote><ul><li>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li><li>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务地紧急性</li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><blockquote><p>在实时操作系统地控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格地时限内处理完事件。实时操作系统地主要特点是及时性和可靠性。</p></blockquote><ul><li><p>硬实时系统：必须在绝对严格的规定时间内完成处理（如：导弹控制系统、自动驾驶系统）</p></li><li><p>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</p></li><li><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队</p></li></ul><h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><blockquote><p>伴随着计算机网络的发展而诞生，能把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p></blockquote><h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><blockquote><p>主要特点是分布式和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</p></blockquote><h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3><blockquote><p>Windows XP、MacOS，方便个人使用</p></blockquote><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-105.png" class="lazyload" data-srcset="/images/pasted-105.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr><h2 id="操作系统的运行机制、体系结构"><a href="#操作系统的运行机制、体系结构" class="headerlink" title="操作系统的运行机制、体系结构"></a>操作系统的运行机制、体系结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ul><li>两种指令<ul><li>特权指令（如：内存清零指令）</li><li>非特权指令 （如：普通的运算指令）</li></ul><p>  </p></li><li>两种处理器状态<blockquote><p>用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为和心态</p></blockquote><ul><li>核心态（管态）</li><li>用户态（目态）</li></ul><p>  </p></li><li>两种程序<ul><li>内核程序：是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态</li><li>应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</li></ul></li></ul><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><blockquote><p>内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分；实现操作系统内核功能的那些程序就是内核程序</p></blockquote><ul><li><p>时钟管理：实现计时功能</p></li><li><p>中断管理</p></li><li><p>原语</p><blockquote><p>设备驱动、CPU切换等</p></blockquote><ul><li>是一种特殊的程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序的运行具有原子性 – 其运行只能一气呵成，不可中断</li><li>运行时间较短、调用频繁</li></ul></li><li><p>对系统资源进行管理的功能</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul><h3 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h3><ul><li><p>大内核</p><ul><li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li><p>微内核</p><ul><li>只把最基本的功能保留在内核</li><li>优点：内核功能少，结构清晰，方便为何</li><li>缺点：需要频繁的在核心态和用户态之间切换，性能低</li></ul></li></ul><h3 id="知识回顾-1"><a href="#知识回顾-1" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-106.png" class="lazyload" data-srcset="/images/pasted-106.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统的四个特征&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;操作系统的特征&quot;&gt;&lt;a href=&quot;#操作系统的特征&quot; class=&quot;headerlink&quot; title=&quot;操作系统的特征&quot;&gt;&lt;/a&gt;操作系统的特征&lt;/h2&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 - 概念功能和目标</title>
    <link href="http://example.com/30168.html"/>
    <id>http://example.com/30168.html</id>
    <published>2022-07-19T14:27:00.000Z</published>
    <updated>2023-03-25T14:35:06.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p>操作系统的概念（定义）功能和目标</p></blockquote><h3 id="操作系统的概念（定义）"><a href="#操作系统的概念（定义）" class="headerlink" title="操作系统的概念（定义）"></a>操作系统的概念（定义）</h3><blockquote><p>操作系统（Operating System， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件</p></blockquote><ol><li>负责管理协调硬件、软件等计算机资源的工作</li><li>为上层的应用程序、用户提供简单易用的服务</li><li>操作系统是系统软件，而不是硬件</li></ol><h3 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h3><blockquote><p>补充知识：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p></blockquote><ul><li>操作系统作为系统资源的管理（这些资源包括软件、硬件、文件等），需要提供什么功能？<br>  追求的目标：安全、高效</li></ul><pre><code>1. 处理机管理2. 存储器管理3. 文件管理4. 设备管理</code></pre><p>     </p><ul><li><p>操作系统作为用户与计算机硬件之间的接口，要为其上层的用户、应用程序提供简单易用的服务，需要实现什么功能？</p><ol><li>命令接口：允许用户直接使用</li></ol></li></ul><pre><code>2. 程序接口：允许用户通过程序间接使用3. GUI：现代操作系统中最流行的图形用户接口</code></pre><p>        </p><ul><li>操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？<ul><li>实现对硬件机器的拓展</li><li>没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ul></li></ul><p>    </p><h4 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h4><ul><li><p>提供的功能 – 用户接口</p><ul><li>命令接口</li></ul></li></ul><p>   1. 联机命令接口：用户说一句，系统做一句（交互式命令接口）<br>    2. 脱机命令接口：用户说一堆，系统做一堆</p><ul><li>程序接口：由一组系统调用组成（程序接口 &#x3D; 系统调用）<ul><li>如 C:\Windows\System32\user32.dll 程序员在程序中调用user32.dll（该调用过程即为系统调用）即可实现创建窗口等功能。只能通过用户程序间接使用。</li></ul></li><li>GUI用户界面</li></ul><ul><li>目标：方便用户使用</li></ul><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-104.png" class="lazyload" data-srcset="/images/pasted-104.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;操作系统的概念（定义）功能和目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;操作系统的概</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>循环冗余校验码</title>
    <link href="http://example.com/40131.html"/>
    <id>http://example.com/40131.html</id>
    <published>2022-07-10T03:31:00.000Z</published>
    <updated>2023-03-25T14:35:06.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第二章 数据的表示和运算</p></blockquote><h2 id="循环冗余校验码（CRC码）"><a href="#循环冗余校验码（CRC码）" class="headerlink" title="循环冗余校验码（CRC码）"></a>循环冗余校验码（CRC码）</h2><blockquote><p>循环冗余校验码（Cyclic Redundancy Check, CRC）</p></blockquote><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul><li><p>数据发送、接收方约定一个“除数”，数据出错导致余数改变 – 检测到错误<br> <img src="/images/pasted-99.png" class="lazyload" data-srcset="/images/pasted-99.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>理论上可以证明循环冗余校验码的检错能力有以下特点：</p><ol><li>可以检测出所有奇数个错误</li><li>可检测出所有双比特的错误</li><li>可检测出所有小于等于校验位长度的连续错误<br><img src="/images/pasted-100.png" class="lazyload" data-srcset="/images/pasted-100.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ol></li></ul><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p><img src="/images/pasted-101.png" class="lazyload" data-srcset="/images/pasted-101.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><ul><li><p>整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。</p></li><li><p>原码：用尾数表示真值的绝对值，符号位“0&#x2F;1”对应“正&#x2F;负”<br><img src="/images/pasted-102.png" class="lazyload" data-srcset="/images/pasted-102.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>反码：</p><ul><li>若符号位为0，则反码与原码相同</li><li>若符号位为1，则数值位全部取反   <br><img src="/images/pasted-103.png" class="lazyload" data-srcset="/images/pasted-103.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul></li><li><p>补码</p><ul><li>正数的补码 &#x3D; 原码<br>    + 负数的补码 &#x3D; 反码末位 + 1（要考虑进位）</li></ul></li></ul><p>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;第二章 数据的表示和运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;循环冗余校验码（CRC码）&quot;&gt;&lt;a href=&quot;#循环冗余校验码（CRC码）&quot; class=&quot;headerlink&quot; title=&quot;循环冗余校验码（CRC码）&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机组成" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据的表示和运算</title>
    <link href="http://example.com/55074.html"/>
    <id>http://example.com/55074.html</id>
    <published>2022-07-05T14:29:00.000Z</published>
    <updated>2023-03-25T14:35:06.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第二章 数据的表示和运算</p></blockquote><ul><li>数据如何在计算机中表示？</li><li>运算器如何实现数据的算数、逻辑运算？</li></ul><hr><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><ul><li><strong>十进制、二进制、八进制、十六进制</strong><ul><li>十进制：逢十进一</li><li>二进制：逢二进一</li><li>八进制：逢八进一</li><li>十六进制：逢十六进一</li></ul></li><li><strong>其他进制 &#x3D;&#x3D;&#x3D;&gt; 十进制</strong>  <em><strong>r进制</strong></em><br>   <img src="/images/pasted-82.png" class="lazyload" data-srcset="/images/pasted-82.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>   <img src="/images/pasted-83.png" class="lazyload" data-srcset="/images/pasted-83.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful">   </li><li><strong>二进制、八进制、十六进制之间的相互转换</strong><br>  <img src="/images/pasted-84.png" class="lazyload" data-srcset="/images/pasted-84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>   <img src="/images/pasted-85.png" class="lazyload" data-srcset="/images/pasted-85.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li><li><strong>十进制 &#x3D;&#x3D;&#x3D;&gt; 其他进制</strong><br>  <img src="/images/pasted-86.png" class="lazyload" data-srcset="/images/pasted-86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>   <img src="/images/pasted-87.png" class="lazyload" data-srcset="/images/pasted-87.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li><li><strong>真值和机器数</strong><ul><li>真值：符合人类习惯的数字</li><li>机器数：数字实际存到机器里的形式，正负号需要被“数字化”</li></ul></li><li><strong>知识回顾与重要考点</strong><br>  <img src="/images/pasted-88.png" class="lazyload" data-srcset="/images/pasted-88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421码-加法"><a href="#8421码-加法" class="headerlink" title="8421码 加法"></a>8421码 加法</h3><blockquote><p>当结果不在映射表中时，需要+6(0110)进行修正</p></blockquote><pre><code>![upload successful](/images/pasted-89.png)</code></pre><h4 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h4><pre><code>![upload successful](/images/pasted-90.png)</code></pre><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><blockquote><p>英文字符 &#x3D;&#x3D;&#x3D;&gt; ASCII码</p></blockquote><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p><img src="/images/pasted-92.png" class="lazyload" data-srcset="/images/pasted-92.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/pasted-91.png" class="lazyload" data-srcset="/images/pasted-91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="中文字符"><a href="#中文字符" class="headerlink" title="中文字符"></a>中文字符</h3><blockquote><p>汉字的表示和编码</p></blockquote><p><img src="/images/pasted-93.png" class="lazyload" data-srcset="/images/pasted-93.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/images/pasted-94.png" class="lazyload" data-srcset="/images/pasted-94.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h4 id="知识回顾与重要考点-1"><a href="#知识回顾与重要考点-1" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h4><p><img src="/images/pasted-95.png" class="lazyload" data-srcset="/images/pasted-95.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="海明码求解步骤"><a href="#海明码求解步骤" class="headerlink" title="海明码求解步骤"></a>海明码求解步骤</h3><p><img src="/images/pasted-96.png" class="lazyload" data-srcset="/images/pasted-96.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>纠错<br>   <img src="/images/pasted-97.png" class="lazyload" data-srcset="/images/pasted-97.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul><h4 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h4><p><img src="/images/pasted-98.png" class="lazyload" data-srcset="/images/pasted-98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;第二章 数据的表示和运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据如何在计算机中表示？&lt;/li&gt;
&lt;li&gt;运算器如何实现数据的算数、逻辑运算？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;进位计数制&quot;&gt;&lt;a href=&quot;#进位</summary>
      
    
    
    
    <category term="计算机组成" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统的层次结构</title>
    <link href="http://example.com/51751.html"/>
    <id>http://example.com/51751.html</id>
    <published>2022-07-04T15:54:00.000Z</published>
    <updated>2023-03-25T14:35:06.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机系统的层次结构</p></blockquote><p><img src="/images/pasted-79.png" class="lazyload" data-srcset="/images/pasted-79.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><p><img src="/images/pasted-80.png" class="lazyload" data-srcset="/images/pasted-80.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><p><img src="/images/pasted-81.png" class="lazyload" data-srcset="/images/pasted-81.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机系统的层次结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-79.png&quot; class=&quot;lazyload&quot; data-srcset=&quot;/images/pasted-79.png&quot; srcset</summary>
      
    
    
    
    <category term="计算机组成" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机硬件的工作原理</title>
    <link href="http://example.com/18947.html"/>
    <id>http://example.com/18947.html</id>
    <published>2022-07-04T14:43:25.000Z</published>
    <updated>2022-07-04T14:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机各个硬件的工作原理</p></blockquote><ul><li>内部细节</li></ul><p><img src="/images/pasted-69.png" class="lazyload" data-srcset="/images/pasted-69.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><h4 id="主存储器结构"><a href="#主存储器结构" class="headerlink" title="主存储器结构"></a>主存储器结构</h4><p><img src="/images/pasted-70.png" class="lazyload" data-srcset="/images/pasted-70.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>存储体 – 数据在存储体内按地址存储<ul><li>存储单元：每个存储单元存放一串二进制代码；每个地址对应一个存储单元</li><li>存储字（word）：存储单元中二进制代码的组合</li><li>存储字长存储单元中二进制代码的位数</li><li>存储元：即存储二进制的电子元件，每个存储元可存1bit</li></ul></li><li>MAR(Memory Address Register) 存储地址寄存器<ul><li>MAR位数反应存储单元的个数</li><li>MAR &#x3D; 4位 &#x3D;&#x3D;&gt; 总共有2^4个存储单元</li></ul></li><li>MDR(Memory Data Register) 存储数据寄存器<ul><li>MDR位数 &#x3D; 存储字长</li><li>MDR &#x3D; 16位 &#x3D;&#x3D;&gt; 每个 存储单元可存放16bit；1个字（word）&#x3D; 16bit</li></ul></li></ul><h3 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h3><blockquote><p>运算器用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</p></blockquote><h4 id="运算器结构"><a href="#运算器结构" class="headerlink" title="运算器结构"></a>运算器结构</h4><p><img src="/images/pasted-71.png" class="lazyload" data-srcset="/images/pasted-71.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>ACC：累加器，用于存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</li><li>X：通用的操作数寄存器，用于存放操作数</li><li>ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li></ul><p><img src="/images/pasted-72.png" class="lazyload" data-srcset="/images/pasted-72.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h3><h4 id="控制器结构"><a href="#控制器结构" class="headerlink" title="控制器结构"></a>控制器结构</h4><p><img src="/images/pasted-73.png" class="lazyload" data-srcset="/images/pasted-73.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>CU(Control Unit)：控制单元，分析指令，给出控制信号</li><li>IR(Instruction Register)：指令寄存器，存放当前执行的指令</li><li>PC(Program Counter)：程序计数器，存放下一条指令地址，有自动加1功能</li></ul><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="/images/pasted-75.png" class="lazyload" data-srcset="/images/pasted-75.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><p><img src="/images/pasted-78.png" class="lazyload" data-srcset="/images/pasted-78.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="冯·诺伊曼计算机的特点"><a href="#冯·诺伊曼计算机的特点" class="headerlink" title="冯·诺伊曼计算机的特点"></a>冯·诺伊曼计算机的特点</h3><ol><li>计算机有五大部分组成</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心（现在一般以存储器为中心）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机各个硬件的工作原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内部细节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-69.png&quot; class=&quot;lazyload&quot; data-srcset=&quot;/i</summary>
      
    
    
    
    <category term="计算机组成" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
    <category term="bilibili大学" scheme="http://example.com/tags/bilibili%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>vue-day01</title>
    <link href="http://example.com/15312.html"/>
    <id>http://example.com/15312.html</id>
    <published>2022-07-04T14:15:28.000Z</published>
    <updated>2023-03-25T14:35:06.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue特性"><a href="#vue特性" class="headerlink" title="vue特性"></a>vue特性</h2><h3 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a>数据驱动视图</h3><p>在使用了vue的页面中，vue会监听数据的变化，从而自动重新渲染页面的结构。<br>· 数据驱动视图是单向的数据绑定</p><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p><img src="/images/pasted-29.png" class="lazyload" data-srcset="/images/pasted-29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/images/pasted-30.png" class="lazyload" data-srcset="/images/pasted-30.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>mvvm工作原理</li></ul><p><img src="/images/pasted-31.png" class="lazyload" data-srcset="/images/pasted-31.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>内容渲染指令</li></ul><p><img src="/images/pasted-32.png" class="lazyload" data-srcset="/images/pasted-32.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><pre><code>+ v-text会覆盖原有内容+ `&#123;&#123;&#125;&#125;`--插值表达式，不会覆盖原有内容+ v-html 渲染包含html标签的字符串</code></pre><ul><li><p>属性绑定指令</p><ul><li>v-bind: 简写为:</li></ul></li><li><p>事件绑定指令</p><ul><li>v-on指令或者@</li></ul></li><li><p>事件修饰符</p></li></ul><p><img src="/images/pasted-33.png" class="lazyload" data-srcset="/images/pasted-33.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>    + @click.prevent&#x3D;xxx()</p><ul><li>按键修饰符</li></ul><p><img src="/images/pasted-34.png" class="lazyload" data-srcset="/images/pasted-34.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>v-model指令的修饰符</li></ul><p><img src="/images/pasted-35.png" class="lazyload" data-srcset="/images/pasted-35.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li><p>v-if：动态创建或移除元素，实现元素的显示和隐藏</p><ul><li>如果刚进入页面，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能更好</li></ul></li><li><p>v-show：动态添加或移除<code>display:none</code>样式来实现元素的显示和隐藏</p><ul><li>如果需要频繁的切换元素的显示状态，使用v-show性能会更好</li></ul></li><li><p>列表渲染指令</p><ul><li>v-for：官方建议，只要用到v-for指令，那么一定要绑定一个 :key 属性；而且尽量把id作为key的值</li></ul></li></ul><p><img src="/images/pasted-37.png" class="lazyload" data-srcset="/images/pasted-37.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue特性&quot;&gt;&lt;a href=&quot;#vue特性&quot; class=&quot;headerlink&quot; title=&quot;vue特性&quot;&gt;&lt;/a&gt;vue特性&lt;/h2&gt;&lt;h3 id=&quot;数据驱动视图&quot;&gt;&lt;a href=&quot;#数据驱动视图&quot; class=&quot;headerlink&quot; title=&quot;数</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-day05</title>
    <link href="http://example.com/63697.html"/>
    <id>http://example.com/63697.html</id>
    <published>2022-07-04T14:15:00.000Z</published>
    <updated>2023-03-25T14:35:06.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-day05"><a href="#vue-day05" class="headerlink" title="vue-day05"></a>vue-day05</h3><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><ul><li><p>component标签是vue内置的，作用：组建的占位符</p></li><li><p>is 属性的值，表示要渲染的组件的名字</p></li><li><p>is 属性的值，应该是组件在components节点下注册名称<br><img src="/images/pasted-57.png" class="lazyload" data-srcset="/images/pasted-57.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>当组件第一次被创建的时候，既会执行created生命周期，也会执行activated生命周期</p></li><li><p>当组件被激活的时候，只会触发activated生命周期，不再触发created，因为组件没有被重新创建</p></li></ul><h4 id="keep-alive-的-include属性"><a href="#keep-alive-的-include属性" class="headerlink" title="keep-alive 的 include属性"></a>keep-alive 的 include属性</h4><ul><li>keep-alive 可以把内部的组件进行缓存，而不是销毁组件</li><li>include属性用来指定：只有名称匹配的组件会被缓存。多个组件之间使用英文逗号分隔<br><img src="/images/pasted-58.png" class="lazyload" data-srcset="/images/pasted-58.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li><li>通过exclude属性指定哪些组件不需要被缓存；但是不要同时使用include和exclude这两个属性</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ul><li>如果在“声明组件”的时候，没有为组件指定name名称，则组件的名称默认就是“注册的时候的名称”</li><li>当提供了 name 属性之后，组件的名称就是 name 属性的值</li><li>对比：<br>  1. 组件的“注册名称”的主要应用场景：以标签的形式，把注册好的组件，渲染和使用到页面结构之中<br>  2. 组件声明时候的“name”名称的主要应用场景：结合<keep-alive>标签实现组件缓存功能；以及在调试工具中看到组件的 name 名称</li></ul><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><ul><li><p>插槽(Slot)是vue为组件的封装者提供的能力。允许开发者在封装组件时，把不确定、希望由用户指定的部分定义为插槽<br><img src="/images/pasted-59.png" class="lazyload" data-srcset="/images/pasted-59.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>vue官方规定：每一个slot插槽，都要有一个 name 名称</p></li><li><p>如果省略了slot的 name 属性，则有一个默认名称叫做default</p></li><li><p>默认情况下，在使用组件的时候，提供的内容都会被填充到名称为default 的插槽之中<br><img src="/images/pasted-60.png" class="lazyload" data-srcset="/images/pasted-60.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>v-slot指令<br>   1. 如果要把内容填充到指定名称的插槽中，需要使用v-slot: 这个指令<br>   2. v-slot: 后面要跟上插槽名称<br>   3. v-slot: 指令不能直接用在元素身上，必须用在template标签上<br>   4. template是一个虚拟的标签，只起到包裹性质的作用，但是，不会被渲染为任何实质性的 html 元素<br><img src="/images/pasted-61.png" class="lazyload" data-srcset="/images/pasted-61.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>   5. v-slot: 指令的简写形式是 #</p></li><li><p>后备内容<br>   + 封装组件时，可以为预留的<slot>插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效<br><img src="/images/pasted-62.png" class="lazyload" data-srcset="/images/pasted-62.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>具名插槽</p></li><li><p>作用域插槽</p><ul><li>在封装组件时，为预留的<slot>提供属性对应的值，这种做法叫做“作用域插槽”</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-day05&quot;&gt;&lt;a href=&quot;#vue-day05&quot; class=&quot;headerlink&quot; title=&quot;vue-day05&quot;&gt;&lt;/a&gt;vue-day05&lt;/h3&gt;&lt;h4 id=&quot;动态组件&quot;&gt;&lt;a href=&quot;#动态组件&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-day06</title>
    <link href="http://example.com/63889.html"/>
    <id>http://example.com/63889.html</id>
    <published>2021-11-22T12:43:27.000Z</published>
    <updated>2023-03-25T14:35:06.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-day06"><a href="#vue-day06" class="headerlink" title="vue-day06"></a>vue-day06</h3><ul><li>私有自定义指令</li></ul><h4 id="如何创建自定义指令"><a href="#如何创建自定义指令" class="headerlink" title="如何创建自定义指令"></a>如何创建自定义指令</h4><p><img src="/images/pasted-63.png" class="lazyload" data-srcset="/images/pasted-63.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h4 id="定义并使用自定义指令"><a href="#定义并使用自定义指令" class="headerlink" title="定义并使用自定义指令"></a>定义并使用自定义指令</h4><p><img src="/images/pasted-64.png" class="lazyload" data-srcset="/images/pasted-64.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre><code>+ 当指令第一次被绑定到元素上的时候会立即触发bind函数+ 形参中的el表示当前指令所绑定到的这个DOM对象</code></pre><h4 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h4><p><img src="/images/pasted-65.png" class="lazyload" data-srcset="/images/pasted-65.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"><br>    + bind函数只调用一次：当指令第一次绑定到元素时调用，当DOM更新时bind函数不会被触发。update函数会在每次DOM更新时被调用</p><h4 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h4><p><img src="/images/pasted-66.png" class="lazyload" data-srcset="/images/pasted-66.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>如果bind和update函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式</li></ul><h4 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h4><ul><li>全局共享的自定义指令需要通过”Vue.directive()”进行声明<br><img src="/images/pasted-67.png" class="lazyload" data-srcset="/images/pasted-67.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul><h4 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h4><p>p168</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-day06&quot;&gt;&lt;a href=&quot;#vue-day06&quot; class=&quot;headerlink&quot; title=&quot;vue-day06&quot;&gt;&lt;/a&gt;vue-day06&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;私有自定义指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;如何创建自定义指令</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-day04</title>
    <link href="http://example.com/14352.html"/>
    <id>http://example.com/14352.html</id>
    <published>2021-10-25T07:29:00.000Z</published>
    <updated>2023-03-25T14:35:06.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-day04"><a href="#vue-day04" class="headerlink" title="vue-day04"></a>vue-day04</h3><h4 id="组件之间的样式冲突问题"><a href="#组件之间的样式冲突问题" class="headerlink" title="组件之间的样式冲突问题"></a>组件之间的样式冲突问题</h4><ul><li>默认情况下，写在.vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题</li><li>导致组件之间样式冲突的根本原因是：<ul><li>单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的</li><li>每个组件中的样式，都会影响整个index.html页面中的DOM元素<br>    + 通过scoped来解决样式冲突<br>    + 当使用第三方组件库的时候，如果有修改第三方组件默认样式的需求，需要用到 &#x2F;deep&#x2F;</li></ul></li></ul><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><ul><li><p>生命周期是指一个组件从创建 &#x3D;&gt; 运行 &#x3D;&gt; 销毁的整个阶段，强调的是一个时间段</p></li><li><p>组件生命周期函数的分类<br><img src="/images/pasted-52.png" class="lazyload" data-srcset="/images/pasted-52.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>created 生命周期函数</p><ul><li>经常在created中调用methods中的方法，请求服务器的数据，并且把请求到的数据转存到data中，供template模板渲染的时候使用</li></ul></li><li><p>mounted 生命周期函数</p><ul><li>操作页面DOM结构可在mounted函数中进行</li></ul></li><li><p>updated 生命周期函数</p><ul><li>当数据变化之后，为了能够操作到最新的 DOM 结构，必须把代码写到 updated 生命周期函数</li></ul></li></ul><h4 id="组件之间的数据共享"><a href="#组件之间的数据共享" class="headerlink" title="组件之间的数据共享"></a>组件之间的数据共享</h4><ul><li><p>自定义属性：props来接收父向子传递过来的数据</p></li><li><p>子组件向父组件传值<br><img src="/images/pasted-53.png" class="lazyload" data-srcset="/images/pasted-53.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>兄弟组件之间的数据共享</p><ul><li><p>在vue 2.x中，兄弟组件之间数据共享的方案时EventBus<br><img src="/images/pasted-54.png" class="lazyload" data-srcset="/images/pasted-54.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>EventBus 的使用步骤</p></li></ul></li></ul><p>   1.创建eventBus.js模块，并向外共享一个Vue实例对象<br>    2.在数据发送方，调用bus.$emit(‘事件名称’，要发送的数据)方法触发自定义事件<br>      3.在数据接收方，调用bus.$on(‘事件名称’，事件处理函数)方法注册一个自定义事件</p><h4 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h4><ul><li>组件的$nextTick(cb)方法，会把cb推迟到下一个DOM更新周期之后执行。通俗的理解是：等组件的DOM更新完成之后，再执行cb回调函数，从而保证cb回调函数可以操作到最新的DOM元素</li></ul><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul><li>forEach循环一旦开始，无法在中间被停止</li><li>arr.some(){} 可在中间停止循环，节省性能</li><li>判断数组中水果是否被全选可用arr.every()<br><img src="/images/pasted-55.png" class="lazyload" data-srcset="/images/pasted-55.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li><li>reduce()累加器使用方法<br><img src="/images/pasted-56.png" class="lazyload" data-srcset="/images/pasted-56.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-day04&quot;&gt;&lt;a href=&quot;#vue-day04&quot; class=&quot;headerlink&quot; title=&quot;vue-day04&quot;&gt;&lt;/a&gt;vue-day04&lt;/h3&gt;&lt;h4 id=&quot;组件之间的样式冲突问题&quot;&gt;&lt;a href=&quot;#组件之间的样式冲突问题&quot; c</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-day03</title>
    <link href="http://example.com/64081.html"/>
    <id>http://example.com/64081.html</id>
    <published>2021-10-20T02:09:36.000Z</published>
    <updated>2023-03-25T14:35:06.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-day03"><a href="#vue-day03" class="headerlink" title="vue-day03"></a>vue-day03</h3><ul><li>vue运行流程：通过main.js把App.vue渲染到index.html的指定区域中<ul><li>其中：<br>    1. app.vue用来编写待渲染的模板结构<br>    2. index.html中需要预留一个el区域<br>    3. main.js把App.vue渲染到了index.html所预留的区域中</li></ul></li></ul><h4 id="vue项目中src目录的构成"><a href="#vue项目中src目录的构成" class="headerlink" title="vue项目中src目录的构成"></a>vue项目中src目录的构成</h4><ul><li>assets 文件夹：存放项目中用到的静态资源文件。例如：css样式表、图片资源</li><li>components文件夹：自己封装的、可复用的组件</li><li>main.js 是项目的入口文件，整个项目的运行，要先执行main.js</li></ul><h4 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h4><ul><li><p>组件化开发：根据封装的思想，把页面上可重用的UI结构封装为组件，从而方便项目的开发和维护</p></li><li><p>vue组件的三个组成部分</p><ol><li>template &#x3D;&gt; 组件的模板结构</li><li>script &#x3D;&gt; 组件Javascript行为</li><li>style &#x3D;&gt; 组件的样式</li></ol></li><li><p>使用组件的三个步骤</p><ol><li>使用import语法导入需要的组件<br>2.使用components节点注册组件<br>3.以标签形式使用刚才注册的组件<br><img src="/images/pasted-46.png" class="lazyload" data-srcset="/images/pasted-46.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ol></li><li><p>通过components注册的是私有子组件</p></li><li><p>注册全局组件</p><ul><li>在vue项目中的main.js入口文件中，通过Vue.component()方法，可以注册全局组件 <br><img src="/images/pasted-47.png" class="lazyload" data-srcset="/images/pasted-47.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></li></ul></li><li><p>组件的props</p><ul><li><p>props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大的提高组件的复用性<br><img src="/images/pasted-48.png" class="lazyload" data-srcset="/images/pasted-48.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>props是只读的</p></li></ul></li></ul><p>    <br><img src="/images/pasted-49.png" class="lazyload" data-srcset="/images/pasted-49.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><pre><code>+ props的default默认值</code></pre><p><img src="/images/pasted-50.png" class="lazyload" data-srcset="/images/pasted-50.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><pre><code>+ props的type值类型</code></pre><p><img src="/images/pasted-51.png" class="lazyload" data-srcset="/images/pasted-51.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><pre><code>+ props的required必填项校验 </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-day03&quot;&gt;&lt;a href=&quot;#vue-day03&quot; class=&quot;headerlink&quot; title=&quot;vue-day03&quot;&gt;&lt;/a&gt;vue-day03&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vue运行流程：通过main.js把App.vue渲染到index.ht</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-day02</title>
    <link href="http://example.com/14992.html"/>
    <id>http://example.com/14992.html</id>
    <published>2021-10-19T02:08:32.000Z</published>
    <updated>2023-03-25T14:35:06.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-day02"><a href="#vue-day02" class="headerlink" title="vue-day02"></a>vue-day02</h2><p><img src="/images/pasted-38.png" class="lazyload" data-srcset="/images/pasted-38.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h3><p><img src="/images/pasted-39.png" class="lazyload" data-srcset="/images/pasted-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>过滤器函数必须被定义到filters节点之下（私有过滤器），过滤器本质上是一个函数，过滤器中一定要有一个返回值；过滤器函数形参中的val永远都是”管道符”前面那个值。</li><li>字符串有charAt()方法，这个方法接收索引值，表示从字符串中把索引对应的字符获取出来</li><li>字符串的slice方法可以截取字符串，从指定索引往后截取</li></ul><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><p><img src="/images/pasted-40.png" class="lazyload" data-srcset="/images/pasted-40.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>如果全局过滤器和私有过滤器一致，此时按照”就近原则”，调用的是”私有过滤器”</li></ul><h4 id="连续调用过滤器"><a href="#连续调用过滤器" class="headerlink" title="连续调用过滤器"></a>连续调用过滤器</h4><p><img src="/images/pasted-41.png" class="lazyload" data-srcset="/images/pasted-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><ul><li><p>watch侦听器<br><img src="/images/pasted-42.png" class="lazyload" data-srcset="/images/pasted-42.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>所有侦听器，都应该被定义到watch节点下</p></li><li><p>侦听器本质上是一个函数，要监视哪个数据的变化，就把数据名作为方法名即可</p></li><li><p>对象格式watch侦听器<br><img src="/images/pasted-43.png" class="lazyload" data-srcset="/images/pasted-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>immediate选项的默认值是false</p></li><li><p>immediate的作用是：控制侦听器是否自己触发一次</p></li><li><p>深度侦听</p></li><li><p>通过deep参数开启深度监听，只要对象中任何一个属性变化了都会触发”对象的侦听器”<br><img src="/images/pasted-44.png" class="lazyload" data-srcset="/images/pasted-44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p></li><li><p>如果要侦听的是对象的子属性的变化（info.username），则必须包裹一层单引号</p></li></ul><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><img src="/images/pasted-45.png" class="lazyload" data-srcset="/images/pasted-45.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="upload successful"></p><ul><li>所有计算属性都要定义到computed节点之下</li><li>计算属性在定义的时候，要定义成”定义格式”</li></ul><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><blockquote><p>专注于网络请求的库</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue-day02&quot;&gt;&lt;a href=&quot;#vue-day02&quot; class=&quot;headerlink&quot; title=&quot;vue-day02&quot;&gt;&lt;/a&gt;vue-day02&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-38.png&quot; class=&quot;la</summary>
      
    
    
    
    <category term="vue" scheme="http://example.com/categories/vue/"/>
    
    
  </entry>
  
</feed>
